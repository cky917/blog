<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只很酷的蘑菇</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.chenkeyi.com/"/>
  <updated>2018-05-07T04:43:55.833Z</updated>
  <id>http://blog.chenkeyi.com/</id>
  
  <author>
    <name>陈柯伊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>纪念一下发布的第一个npm模块</title>
    <link href="http://blog.chenkeyi.com/2018/05/07/ip-proxy-request/"/>
    <id>http://blog.chenkeyi.com/2018/05/07/ip-proxy-request/</id>
    <published>2018-05-07T04:36:00.000Z</published>
    <updated>2018-05-07T04:43:55.833Z</updated>
    
    <content type="html"><![CDATA[<p>纪念一下发布的第一个npm模块😂， 因为最近研究node爬虫，需要免费动态ip代理发出请求，所以搞了一个模块，用于获取免费ip代理并且发出请求。地址:<a href="https://www.npmjs.com/package/ip-proxy-request" target="_blank" rel="noopener">https://www.npmjs.com/package/ip-proxy-request</a></p><p>主要学习一下npm的发布流程，还顺便学习实践了一下单测<code>jest</code>和持续集成<code>travis</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;纪念一下发布的第一个npm模块😂， 因为最近研究node爬虫，需要免费动态ip代理发出请求，所以搞了一个模块，用于获取免费ip代理并且发出请求。地址:&lt;a href=&quot;https://www.npmjs.com/package/ip-proxy-request&quot; targ
      
    
    </summary>
    
    
      <category term="web前端知识" scheme="http://blog.chenkeyi.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>vue源码学习笔记--事件机制</title>
    <link href="http://blog.chenkeyi.com/2018/03/21/vue-source-code-study-4/"/>
    <id>http://blog.chenkeyi.com/2018/03/21/vue-source-code-study-4/</id>
    <published>2018-03-21T13:40:00.000Z</published>
    <updated>2018-03-21T14:17:32.068Z</updated>
    
    <content type="html"><![CDATA[<p>今天来看看vue的事件相关方法，本来想先看模板渲染和虚拟dom相关的内容，但是看了2天之后，感觉那一块内容很多而且难- -，所以先啃这块比较简单一点的骨头好了。<br><a id="more"></a><br>在实例化<code>Vue</code>的时候，初始化过程会调用一个<code>initEvent</code>函数，<a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/events.js" target="_blank" rel="noopener">initEvent</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initEvents</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// _events对象来缓存事件</span></span><br><span class="line">  vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  vm._hasHookEvent = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// init parent attached events</span></span><br><span class="line">  <span class="comment">// 模板事件相关，先不说</span></span><br><span class="line">  <span class="comment">// const listeners = vm.$options._parentListeners</span></span><br><span class="line">  <span class="comment">// if (listeners) &#123;</span></span><br><span class="line">  <span class="comment">//   updateComponentListeners(vm, listeners)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化事件的方法里，主要是生成了一个<code>vm._events</code>对象来缓存事件，<code>vm._hasHookEvent</code>来标识是否有钩子事件</p><p><code>Vue</code>提供了4个实例方法供我们注册和触发事件。<a href="https://cn.vuejs.org/v2/api/#vm-on" target="_blank" rel="noopener">vm.$on</a>、<a href="https://cn.vuejs.org/v2/api/#vm-once" target="_blank" rel="noopener">vm.$once</a>、<a href="https://cn.vuejs.org/v2/api/#vm-off" target="_blank" rel="noopener">vm.$off</a>、<a href="https://cn.vuejs.org/v2/api/#vm-emit" target="_blank" rel="noopener">vm.$emit</a></p><p>下面来分别看看它们的实现</p><h2 id="vm-on"><a href="#vm-on" class="headerlink" title="vm.$on"></a>vm.$on</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hookRE = <span class="regexp">/^hook:/</span></span><br><span class="line">Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string | Array&lt;string&gt;, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 如果传入的event是数组，则循环每个event，递归调用$on绑定</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$on(event[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果vm._events[event]是一个数组，里面储存了触发这个事件时的回调方法定义</span></span><br><span class="line">    <span class="comment">// 如果存在就直接push，否则初始化[]</span></span><br><span class="line">    (vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class="line">    <span class="comment">// optimize hook:event cost by using a boolean flag marked at registration</span></span><br><span class="line">    <span class="comment">// instead of a hash lookup</span></span><br><span class="line">    <span class="comment">// 如果event包含 hook:xx 则标记_hasHookEvent为true</span></span><br><span class="line">    <span class="keyword">if</span> (hookRE.test(event)) &#123;</span><br><span class="line">      vm._hasHookEvent = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vm-emit"><a href="#vm-emit" class="headerlink" title="vm.$emit"></a>vm.$emit</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> lowerCaseEvent = event.toLowerCase()</span><br><span class="line">    <span class="keyword">if</span> (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123;</span><br><span class="line">      <span class="comment">// 如果小写形式的event被注册了，但是本身传入的不是小写形式，则友情提示</span></span><br><span class="line">      <span class="comment">// tip(</span></span><br><span class="line">      <span class="comment">//   `Event "$&#123;lowerCaseEvent&#125;" is emitted in component ` +</span></span><br><span class="line">      <span class="comment">//   `$&#123;formatComponentName(vm)&#125; but the handler is registered for "$&#123;event&#125;". ` +</span></span><br><span class="line">      <span class="comment">//   `Note that HTML attributes are case-insensitive and you cannot use ` +</span></span><br><span class="line">      <span class="comment">//   `v-on to listen to camelCase events when using in-DOM templates. ` +</span></span><br><span class="line">      <span class="comment">//   `You should probably use "$&#123;hyphenate(event)&#125;" instead of "$&#123;event&#125;".`</span></span><br><span class="line">      <span class="comment">// )</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 该event的回调函数列表</span></span><br><span class="line">  <span class="keyword">let</span> cbs = vm._events[event]</span><br><span class="line">  <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">    cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs</span><br><span class="line">    <span class="comment">// 将剩余的参数转为数组</span></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// 依次调用回调函数</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cbs[i].apply(vm, args)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`event handler for "<span class="subst">$&#123;event&#125;</span>"`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以下代码试试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a.$on(<span class="string">'say'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'say'</span> + name)</span><br><span class="line">&#125;)</span><br><span class="line">a.$on(<span class="string">'say'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'say2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">a.$on(<span class="string">'sing'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">song</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sing a song: '</span> + song)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/15.png"><br><img src="/images/16.png"><br>可以看到事件注册到了<code>_events</code>里，然后<code>$emit</code>触发。而且方法返回的是<code>vm</code>实例，所以我们还可以进行链式调用<br><img src="/images/17.png"></p><h2 id="vm-off"><a href="#vm-off" class="headerlink" title="vm.$off"></a>vm.$off</h2><blockquote><p>参数：<br><code>{string | Array&lt;string&gt;} event</code> (只在 2.2.2+ 支持数组)<br><code>{Function} [callback]</code></p></blockquote><blockquote><p>用法：</p><ul><li>移除自定义事件监听器。</li><li>如果没有提供参数，则移除所有的事件监听器；</li><li>如果只提供了事件，则移除该事件所有的监听器；</li><li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string | Array&lt;string&gt;, fn?: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// all</span></span><br><span class="line">  <span class="comment">// 如果没有提供参数，则移除所有事件监听，_events设为空对象</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// array of events</span></span><br><span class="line">  <span class="comment">// 如果传了数组event，则循环递归调用$off移除每个event</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$off(event[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// specific event</span></span><br><span class="line">  <span class="comment">// 单个event，如果没被注册，则返回</span></span><br><span class="line">  <span class="keyword">const</span> cbs = vm._events[event]</span><br><span class="line">  <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有传入fn，则这个event的回调全部清空</span></span><br><span class="line">  <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">    vm._events[event] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果传了fn, 则循环回调列表删除该fn</span></span><br><span class="line">  <span class="keyword">if</span> (fn) &#123;</span><br><span class="line">    <span class="comment">// specific handler</span></span><br><span class="line">    <span class="keyword">let</span> cb</span><br><span class="line">    <span class="keyword">let</span> i = cbs.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      cb = cbs[i]</span><br><span class="line">      <span class="comment">// cb.fn见$once</span></span><br><span class="line">      <span class="keyword">if</span> (cb === fn || cb.fn === fn) &#123;</span><br><span class="line">        cbs.splice(i, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vm-once"><a href="#vm-once" class="headerlink" title="vm.$once"></a>vm.$once</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">on</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    vm.$off(event, on)</span><br><span class="line">    fn.apply(vm, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在$on方法注册event，且重新定义一个回调，在回调里调$off方法移除事件绑定，把原来的fn赋值给on.fn</span></span><br><span class="line">  on.fn = fn</span><br><span class="line">  vm.$on(event, on)</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hook-event"><a href="#hook-event" class="headerlink" title="hook event"></a>hook event</h2><p>之前说的<code>_hasHookEvent</code>，用于标识是否有注册过钩子函数，钩子函数的单独注册就是用下面的方法。我感觉这个单独注册钩子函数的主要作用还是用于测试方便。平时使用还是在<code>options</code>里直接定义的多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$on(<span class="string">'hook:created'</span>, created)</span><br><span class="line"><span class="keyword">this</span>.$on(<span class="string">'hook:mounted'</span>, mounted)</span><br><span class="line"><span class="keyword">this</span>.$on(<span class="string">'hook:destroyed'</span>, destroyed)</span><br></pre></td></tr></table></figure><p>生命周期钩子函数等会在指定时期的代码内部调用<code>callHook</code>方法进行触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">callHook</span> (<span class="params">vm: Component, hook: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handlers = vm.$options[hook]</span><br><span class="line">  <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        handlers[i].call(vm)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(<span class="string">'hook:'</span> + hook)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来看看vue的事件相关方法，本来想先看模板渲染和虚拟dom相关的内容，但是看了2天之后，感觉那一块内容很多而且难- -，所以先啃这块比较简单一点的骨头好了。&lt;br&gt;
    
    </summary>
    
    
      <category term="vue源码学习" scheme="http://blog.chenkeyi.com/tags/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>blog折腾小记，and神器推荐</title>
    <link href="http://blog.chenkeyi.com/2018/03/21/blog-transfer/"/>
    <id>http://blog.chenkeyi.com/2018/03/21/blog-transfer/</id>
    <published>2018-03-21T07:38:00.000Z</published>
    <updated>2018-03-21T08:42:54.640Z</updated>
    
    <content type="html"><![CDATA[<p>这2天把博客换了个域名，那个<code>coolmogu</code>的域名不准备续费了- -，目前都强制302到了这个域名。跟着这个<a href="https://www.gaoshilei.com/2017/10/30/hexo-init/" target="_blank" rel="noopener">教程</a>搞了https+github的<code>webhook</code>，域名前面有个绿色的标志看上去就是爽~~<br><img src="https://t10.baidu.com/it/u=558790623,3064289337&amp;fm=170&amp;s=C55F38D29ED69E82E38D05730100A0E2&amp;w=198&amp;h=156&amp;img.JPEG" alt="力量!"></p><p>话说之前不是搞了个微信公众号爬虫咩，后来因为第三方验证码识别接口涨价了，就直接弃用了。而且我发现我爬的那些公众号其实都有自己的网站，也提供了<code>rss</code>，这种信息聚合的功能还是<code>rss</code>好用啊。这里要推荐一个mac的rss神器 – <code>reeder</code>，虽然要花几十块钱购买，但是完全物超所值啊。<br>界面主要大致如下，<br><img src="/images/rss.png"><br>订阅了一些前端文章博客之类的，感觉阅读体验和使用体验很棒。</p><p>我给我的博客也增加了rss功能，<a href="https://blog.chenkeyi.com/atom.xml">欢迎订阅~</a></p><p>之前在github上看见也有大佬自己写接口提供各种信息的rss页面，感觉之后也可以搞一波。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这2天把博客换了个域名，那个&lt;code&gt;coolmogu&lt;/code&gt;的域名不准备续费了- -，目前都强制302到了这个域名。跟着这个&lt;a href=&quot;https://www.gaoshilei.com/2017/10/30/hexo-init/&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="生活琐事" scheme="http://blog.chenkeyi.com/tags/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>vue源码学习笔记--Vue数据响应式原理</title>
    <link href="http://blog.chenkeyi.com/2018/03/19/vue-source-code-study-3/"/>
    <id>http://blog.chenkeyi.com/2018/03/19/vue-source-code-study-3/</id>
    <published>2018-03-19T10:32:00.000Z</published>
    <updated>2018-03-21T04:33:42.165Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/cky917/vue-source-code-study" target="_blank" rel="noopener">学习代码仓库</a></p><a id="more"></a><p>今天来看Vue的数据响应式原理，也就是watch一个值，改变了这个数据，能够得到通知并且在回调里获得新值和旧值从而进行操作，这一个功能的实现。本篇暂不包含与模板层的双向绑定。</p><h2 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo/index.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue3</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每次执行new Vue()操作都会执行的构造函数</span></span><br><span class="line">Vue3.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span></span><br><span class="line">  vm.$options = options || &#123;&#125;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">if</span> (vm.$options.data) initData(vm)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  <span class="comment">// 将配置项data的值挂载在vm._data上，如果data是个函数，则调用`getData`方法获取返回值</span></span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span> ? getData(data, vm) : data || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略data的校验步骤</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="comment">// ...省略data的key值校验步骤</span></span><br><span class="line">    <span class="comment">// 遍历 data 的 key，把 data 上的属性代理到 vm 实例上</span></span><br><span class="line">    proxy(vm, <span class="string">'_data'</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe(data, true /* asRootData */)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">data, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(e)</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">target, sourceKey, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: noop,</span><br><span class="line">    set: noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取 vm[key]值的时候，返回vm._data[key]</span></span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置 vm[key]值的时候，vm._data[key] = val</span></span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将[key]挂载在vm上</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.Vue3 = Vue3</span><br></pre></td></tr></table></figure><p>通过以上的初始化，成功让配置项里<code>data</code>的每个值都挂到了<code>vm</code>实例上。并且<code>vm[key]</code>的操作会同步到<code>vm._data[key]</code>上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Vue3(&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">'cky'</span>,</span><br><span class="line">      age: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/5.png"><br><img src="/images/6.png"></p><h2 id="Observer、Watcher、Dep"><a href="#Observer、Watcher、Dep" class="headerlink" title="Observer、Watcher、Dep"></a>Observer、Watcher、Dep</h2><p>接下来要说的三个类<code>Observer</code>、<code>Watcher</code>、<code>Dep</code>，我们先提前搞清楚他们三个的作用。<br><code>Observer</code>类是用来把一个值变得可观测的工具，它会循环传入的值，然后改写它们的<code>getter/setter</code>。它的实例方法有<code>observeArray</code>和<code>walk</code>，分别把数组和对象类型变得可观测。</p><p><code>Watcher</code>可以设定多个观察对象，然后对于它们的改变做出相应行为。它的实例方法有以下：</p><ul><li><code>get()</code>。根据传入的表达式或函数，计算出值</li><li><code>addDep(dep)</code>。如果没有将自身传入过该<code>dep</code>记录依赖,则将自身传入，调用<code>dep.addSub(this)</code></li><li><code>cleanupDeps()</code>。清理不再依赖的<code>dep</code>, 同时在<code>dep</code>的依赖列表中移除自身</li><li><code>update()</code>。订阅者接口，当订阅的值改变时会触发</li><li><code>run()</code>。对比前后值，如果前后值发生了改变，或者<code>deep</code>为<code>true</code>，或者该值为对象，则触发cb回调。</li><li><code>evaluate()</code>。触发<code>this.get()</code> 只会在<code>lazy watcher</code>里被触发</li><li><code>depend()</code>。循环触发<code>this.deps</code>的项的<code>depend()</code>方法</li><li><code>teardown()</code>。销毁<code>watcher</code>，从所有的<code>this.deps</code>里移除自身，并且将<code>active</code>设为<code>false</code></li></ul><p><code>Dep</code>类是针对某个值的依赖收集器，比如id为1的<code>Dep</code>实例对象是负责收集<code>_data.name</code>的依赖的，那以后所有对这个值的进行观测的<code>watcher</code>都会被统计到这个实例里。<br>它的实例方法有如下：</p><ul><li><code>addSub(sub: Watcher)</code>。 增加依赖</li><li><code>removeSub (sub: Watcher)</code>。 移除依赖</li><li><code>depend()</code>。如果有<code>Watcher</code>在<code>Dep.target</code>, 则将这个<code>Watcher</code>加入依赖</li><li><code>notify()</code>。调用所有的<code>subs</code>的<code>update()</code>方法。</li></ul><p>上面在<code>initData()</code>函数中注释了一句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br></pre></td></tr></table></figure><p>现在来看看这个函数是干什么的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /demo/observer.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; isObject &#125; <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, asRootData</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不是对象，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob</span><br><span class="line">  <span class="comment">// 如果value对象上有__ob__属性，而且这个属性是Observer类的一个实例</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则ob为一个新的Oserver实例</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是vm.$data, 那么 ob.vmCount++</span></span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hasOwn</span>(<span class="params">obj, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hasOwnProperty.call(obj, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">obj, key, val, enumerable</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下上面干了什么，<code>observe</code>函数返回的是一个<code>Observer</code>类的实例，如果传入的value有<code>__ob__</code>属性，直接返回，如果没有 则传入<code>value</code>值去构造一个<code>Observer</code>的实例并返回。</p><p>我们再来看看<code>Observer</code>类的定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// value</span></span><br><span class="line">  <span class="comment">// dep</span></span><br><span class="line">  <span class="comment">// vmCount // number of vms that has this object as root $data</span></span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 给value添加'__ob__'属性，就是这个实例</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.walk(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 循环每个属性，并转换它们的getter/setters，这个方法只能用于Object类型的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk(obj) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 第一次初始化时， obj: vm._data  keys[i]: key, obj[keys[i]]: value</span></span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个对象上定义一个响应式的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val, customSetter, shallow</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果之前这个字段已经定义过getter了就用之前的getter</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="comment">// 如果值没有改变 或者类似 NaN !== NaN这种情况</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`我被改变了，新值:<span class="subst">$&#123;newVal&#125;</span>, 旧值:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下上面的操作，<code>Observer</code>的构造函数给传入的<code>value</code>值增加<code>__ob__</code>属性，也就是这个构造出的实例，并且如果<code>value</code>是对象类型，会循环它的每个属性，调用<code>defineReactive</code>方法，而这个方法就是改写每个属性的<code>getter/setter</code>，从而可以在进行值获取和赋值的时候进行某些操作，也就能监听到值的改变。</p><p>看看执行上面代码的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Vue3(&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">'cky'</span>,</span><br><span class="line">      age: <span class="number">18</span>,</span><br><span class="line">      mom: &#123;</span><br><span class="line">      name: <span class="string">'zj'</span>,</span><br><span class="line">        age: <span class="number">28</span></span><br><span class="line">      &#125;,</span><br><span class="line">      friends: [<span class="string">'aa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/7.png"><br><img src="/images/9.png"><br><img src="/images/8.png"></p><p>之前对于<code>vm.age</code>和<code>vm.name</code>也有<code>getter</code>和<code>setter</code>的重写，和这里的<code>vm._data.age</code>的<code>getter/setter</code>是不一样的，在<code>vm.age</code>的<code>getter</code>是去读<code>vm._data.age</code>，从而触发<code>vm._data.age</code>的<code>getter</code>，<code>setter</code>同理。其实真正对于数据改变的监听是在<code>_data</code>属性上的<code>getter</code>和<code>setter</code>上完成的。</p><h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><p>上面的操作在数组执行<code>push</code>这类的会改变数组的方法的时候，却没有任何作用，因为这个并不会触发<code>setter</code>。那对于数组<code>Vue</code>又是怎么处理的呢。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /demo/observer.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; arrayMethods &#125; <span class="keyword">from</span> <span class="string">'./array'</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      value.__proto__ = arrayMethods</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// walk()...</span></span><br><span class="line">  observeArray (items) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /demo/array.js</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我是数组，被<span class="subst">$&#123;method&#125;</span>方法改变了`</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个<code>array.js</code>文件<code>export</code>出了一个 <code>arrayMethods</code>，<code>arrayMethods</code> 继承了 <code>Array.prototype</code>，并在自身定义了那些变异方法来拦截原始数组的那些方法调用。<br>我们知道，当我们访问对象上的一个属性的时候，假如对象自身不存在这个属性，则会延续到它的 <code>__proto__</code> 上去找，找不到就继续。所以上面只需要把数组的 <code>__proto__</code> 指向 vue 自己的 <code>ArrayMethods</code> 就实现了拦截部分属性并继承原始 <code>Array</code> 的其他原型方法，十分巧妙。</p><p><img src="/images/10.png"></p><p>官方文档说，不支持直接对数组<code>this.xx[n] = xyz</code>这样的赋值监听，提供了<code>Vue.set</code>和<code>this.$set</code> 方法，其实这个方法内部在前一篇也讲了，就是调用了<code>splice</code>这个变异方法从而实现监听。</p><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p><br>上面的操作还是仅仅是观察者能够监听到了数组的变化，观察者看到发生变化后，就要去通知那些订阅者(<code>watcher</code>)。那这个订阅依赖是怎么统计起来的呢。首先，我们需要定义一个<code>Dep</code>类，这是观察者和订阅者的桥梁，它统计了所有的watcher，然后统一发出通知。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /demo/dep.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  addSub () &#123;...&#125;  <span class="comment">// 添加订阅者(依赖)</span></span><br><span class="line">  removeSub () &#123;...&#125;  <span class="comment">// 删除订阅者(依赖)</span></span><br><span class="line">  depend () &#123;...&#125;  <span class="comment">// 检查当前Dep.target是否存在以及判断这个watcher已经被添加到了相应的依赖当中，如果没有则添加订阅者(依赖)，如果已经被添加了那么就不做处理</span></span><br><span class="line">  notify () &#123;...&#125;  <span class="comment">// 通知订阅者(依赖)更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而什么时候该去添加依赖呢，其实就是你在获取这个值，而且说明自己是个订阅者的时候，就可以把你作为这个值的依赖了。<br>这一步就在<code>defineReactive</code>方法里实现，这一步重写了<code>getter</code>和<code>setter</code>，所以只需要在<code>getter</code>里记录依赖，在<code>setter</code>里通知改变就行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /demo/observer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val, customSetter, shallow</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep() <span class="comment">// 该值的依赖收集器</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val) <span class="comment">// 返回的是一个Observer实例</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123; <span class="comment">// 当订阅者存在的时候，才进行依赖收集</span></span><br><span class="line">        dep.depend() <span class="comment">// 依赖收集，</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Vue</code>的订阅者实现是一个<code>Watcher</code>类，在<code>Vue</code>的生命周期里，有四个地方会实例化这个类。</p><ul><li><code>Vue</code>实例化的过程中有<code>watch</code>选项</li><li><code>Vue</code>实例化的过程中有<code>computed</code>计算属性选项</li><li><code>Vue</code>原型上有挂载<code>$watch</code>方法: <code>Vue.prototype.$watch</code>，可以直接通过实例调用<code>this.$watch</code>方法</li><li><code>Vue</code>生成了<code>render</code>函数，更新视图时</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo/watcher.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (vm, expOrFn, cb, options) &#123;</span><br><span class="line">    <span class="comment">// 缓存这个实例vm</span></span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="comment">// vm实例中的_watchers中添加这个watcher</span></span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// eg: 'a.b.c'，parsePath方法返回了一个函数，接收obj参数，然后返回obj[a][b][c]的值</span></span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过get方法去获取最新的值</span></span><br><span class="line">    <span class="comment">// 如果lazy为true, 初始化的时候为undefined</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">  get () &#123;...&#125;</span><br><span class="line">  addDep () &#123;...&#125;</span><br><span class="line">  update () &#123;...&#125;</span><br><span class="line">  run () &#123;...&#125;</span><br><span class="line">  evaluate () &#123;...&#125;</span><br><span class="line">  run () &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在除了<code>computed</code>选项外，其他几种实例化<code>watcher</code>的方式都是在实例化过程中完成求值及依赖的收集工作：<code>this.value = this.lazy ? undefined : this.get()</code>.在<code>Watcher</code>的<code>get</code>方法中:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  <span class="comment">// pushTarget即设置当前的需要被执行的watcher</span></span><br><span class="line">  pushTarget(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// $watch(function () &#123;&#125;)</span></span><br><span class="line">    <span class="comment">// 调用this.getter的时候，触发了属性的getter函数</span></span><br><span class="line">    <span class="comment">// 在getter中进行了依赖的管理</span></span><br><span class="line">    value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// traverse方法其实就是遍历读取了value的值，从而遍历触发了下面的`getter`从而进行了依赖收集</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">    traverse(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 完成了依赖收集</span></span><br><span class="line">  popTarget()</span><br><span class="line">  <span class="comment">// 清理和删除老旧依赖</span></span><br><span class="line">  <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>get()</code>方法中触发了<code>getter</code>，调用<code>dep.depend()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo/dep.js</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="comment">// 检查当前Dep.target是否存在以及判断这个watcher已经被添加到了相应的依赖当中，如果没有则添加订阅者(依赖)，如果已经被添加了那么就不做处理</span></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      <span class="comment">// Dep.target为一个watcher</span></span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo/watcher.js</span></span><br><span class="line">  <span class="comment">// 添加依赖</span></span><br><span class="line">  addDep(dep) &#123;</span><br><span class="line">    <span class="comment">// 某值的依赖收集器实例，如果这个依赖没有被收集过</span></span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其他的细节代码就不细说了，现在完善代码, 并执行以下代码后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Vue3(&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">       name: <span class="string">'cky'</span>,</span><br><span class="line">       age: <span class="number">18</span>,</span><br><span class="line">       mom: &#123;</span><br><span class="line">     name: <span class="string">'zj'</span>,</span><br><span class="line">         age: <span class="number">28</span></span><br><span class="line">       &#125;,</span><br><span class="line">       friends: [<span class="string">'aa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>],</span><br><span class="line">       classmate: [<span class="string">'dd'</span>, <span class="string">'ee'</span>, <span class="string">'gg'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">a.$watch(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newValue, oldValue)</span><br><span class="line">&#125;)</span><br><span class="line">a.$watch(<span class="string">'age'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newValue, oldValue)</span><br><span class="line">&#125;)</span><br><span class="line">a.$watch(<span class="string">'age'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newValue, oldValue)</span><br><span class="line">&#125;)</span><br><span class="line">a.$watch(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newValue, oldValue)</span><br><span class="line">&#125;)</span><br><span class="line">a.$watch(<span class="string">'age'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newValue, oldValue)</span><br><span class="line">&#125;)</span><br><span class="line">a.$watch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newValue, oldValue)</span><br><span class="line">&#125;)</span><br><span class="line">a.$watch(<span class="string">'age'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newValue, oldValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/11.png"><br><img src="/images/12.png"><br><img src="/images/13.png"><br><img src="/images/14.png"></p><p>其中<code>Dep.id</code>为1的是对<code>name</code>值的依赖收集器，它下面有id为1、4、6的<code>watcher</code>。<br><code>Dep.id</code>为2的是对<code>age</code>的依赖收集器，它的收集的订阅者有<code>id</code>为2、3、5、6、7的<code>watcher</code><br><code>id</code>为6的<code>watcher</code>因为用到了<code>name</code>和<code>age</code>2个值，所以上面都有他，而它的<code>deps</code>字段也能看出来。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000010014281" target="_blank" rel="noopener">Vue的数据依赖实现原理简析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/cky917/vue-source-code-study&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;学习代码仓库&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue源码学习" scheme="http://blog.chenkeyi.com/tags/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue源码学习笔记--全局api解析</title>
    <link href="http://blog.chenkeyi.com/2018/03/09/vue-source-code-study-2/"/>
    <id>http://blog.chenkeyi.com/2018/03/09/vue-source-code-study-2/</id>
    <published>2018-03-09T11:58:00.000Z</published>
    <updated>2018-03-10T07:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/cky917/vue-source-code-study" target="_blank" rel="noopener">学习代码仓库</a></p><a id="more"></a><h1 id="全局api解析"><a href="#全局api解析" class="headerlink" title="全局api解析"></a>全局api解析</h1><p>友情提示：点击每个api的标题可以直接打开API的文档</p><p>上篇说到了vue的初始化流程，其中给原型初始化的过程我们之后再分析，先把不执行new就能用的全局Api看了。<br>我的思路是根据<a href="https://github.com/vuejs/vue/blob/dev/src/core/global-api/index.js" target="_blank" rel="noopener">initGlobalApi(Vue)</a>方法的顺序往下看</p><h2 id="Vue-config"><a href="#Vue-config" class="headerlink" title="Vue.config"></a><a href="https://cn.vuejs.org/v2/api/#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">Vue.config</a></h2><p>这是一个全局属性，默认是读取的这个<a href="https://github.com/vuejs/vue/blob/dev/src/core/config.js" target="_blank" rel="noopener">配置</a></p><ul><li>silent<ul><li>默认值：<code>false</code></li><li>作用：是否取消 Vue 所有的日志与警告。</li></ul></li><li>optionMergeStrategies<ul><li>类型：<code>{ [key: string]: Function }</code></li><li>默认值 <code>{}</code></li><li>作用：自定义合并策略的选项</li></ul></li><li>devtools<ul><li>默认值：开发版本默认为<code>true</code>，生产版本默认为<code>false</code></li><li>作用：配置是否允许<code>vue-devtools</code>检查代码。生产版本设为 true 可以启用检查。</li></ul></li><li>errorHandler<ul><li>类型： <code>function</code></li><li>默认值：<code>undefined</code></li><li>作用：指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</li></ul></li><li>warnHandler<ul><li>类型：<code>Function</code></li><li>默认值：<code>undefined</code></li><li>作用：为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。</li></ul></li><li>ignoredElements<ul><li>类型：<code>Array&lt;string | RegExp&gt;</code></li><li>默认值：<code>[]</code></li><li>作用：须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 <code>Web Components APIs</code>)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于<code>Unknown custom element</code>的警告。</li></ul></li><li>keyCodes<ul><li>类型：<code>{ [key: string]: number | Array&lt;number&gt; }</code></li><li>默认值：<code>{}</code></li><li>作用：给<code>v-on</code>自定义键位别名。</li></ul></li><li>performance<ul><li>类型：<code>boolean</code></li><li>默认值：<code>false</code></li><li>作用： 设置为<code>true</code>以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持<code>performance.mark API</code>的浏览器上</li></ul></li><li>productionTip<ul><li>类型：<code>boolean</code></li><li>默认值：<code>process.env.NODE_ENV !== &#39;production&#39;</code></li><li>作用：设置为<code>false</code>以阻止<code>vue</code>在启动时生成生产提示。</li></ul></li></ul><p>配置文件里还有一些属性，不过没有写到文档里，所以应该不推荐用户修改配置，所以就不说啦。</p><h2 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set"></a><a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">Vue.set</a></h2><p><a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">相关问题文档</a></p><p>设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开<code>Vue</code>不能检测属性被添加的限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./global-api/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; set, del &#125; <span class="keyword">from</span> <span class="string">'../observer/index'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Vue.set = set</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// './observer/index.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set a property on an object. Adds the new property and</span></span><br><span class="line"><span class="comment"> * triggers change notification if the property doesn't</span></span><br><span class="line"><span class="comment"> * already exist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果target是一个数组，而且key是一个数组的索引值，直接用数组方法splice()可以直接触发响应的监听，返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果key在target里，而且key不是在Object本身就有的属性，直接更新返回</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存观察者</span></span><br><span class="line">  <span class="keyword">const</span> ob = (target).__ob__</span><br><span class="line">  <span class="comment">// 判断target是否是Vue实例或者根数据对象，如果是，则报错,所以</span></span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(<span class="string">'Avoid adding reactive properties to a Vue instance or its root $data '</span> + <span class="string">'at runtime - declare it upfront in the data option.'</span>)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果target不是响应式的，就直接返回修改后的值</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 传入defineReactive方法，让target的key属性可响应式，然后触发观察者的依赖的notify()方法</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-delete"><a href="#Vue-delete" class="headerlink" title="Vue.delete"></a><a href="https://cn.vuejs.org/v2/api/#Vue-delete" target="_blank" rel="noopener">Vue.delete</a></h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./global-api/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">set</span>, del &#125; <span class="keyword">from</span> <span class="string">'../observer/index'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Vue.delete = del</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// './observer/index.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete a property and trigger change if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">del</span> (<span class="params">target: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; | <span class="built_in">Object</span>, key: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果target是一个数组，而且key是一个数组的索引值，直接用数组方法splice()可以直接触发响应的监听，返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.splice(key, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target).__ob__</span><br><span class="line">  <span class="comment">// 判断target是否是Vue实例或者根数据对象，如果是，则报错</span></span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'Avoid deleting properties on a Vue instance or its root $data '</span> +</span><br><span class="line">      <span class="string">'- just set it to null.'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果key不是target的属性，返回</span></span><br><span class="line">  <span class="keyword">if</span> (!hasOwn(target, key)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> target[key]</span><br><span class="line">  <span class="comment">// 如果target不是响应的，返回</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 手动通知</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a><a href="https://cn.vuejs.org/v2/api/#Vue-nextTick" target="_blank" rel="noopener">Vue.nextTick</a></h2><p>在下次<code>DOM</code>更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p><blockquote><p>2.1.0 起新增：如果没有提供回调且在支持 <code>Promise</code> 的环境中，则返回一个 <code>Promise</code>。</p></blockquote><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js" target="_blank" rel="noopener">代码</a>里的<code>microTimerFunc</code>和<code>macroTimerFunc</code>分别是 <strong>微任务</strong> 和 <strong>宏任务</strong> ，这里的<code>microTimerFunc</code>主要是用的<code>Promise</code>，若不支持<code>Promise</code>则<code>microTimerFunc=macroTimerFunc</code>。<code>macroTimerFunc</code>则是用的<code>setImmediate</code>,若不支持<code>setImmediate</code>则用<code>setTimeout</code></p><p>代码比较简单，就是推入一个<code>callback</code>数组，然后等待被调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Here we have async deferring wrappers using both micro and macro tasks.</span></span><br><span class="line"><span class="comment">// In &lt; 2.4 we used micro tasks everywhere, but there are some scenarios where</span></span><br><span class="line"><span class="comment">// micro tasks have too high a priority and fires in between supposedly</span></span><br><span class="line"><span class="comment">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span></span><br><span class="line"><span class="comment">// event (#6566). However, using macro tasks everywhere also has subtle problems</span></span><br><span class="line"><span class="comment">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span></span><br><span class="line"><span class="comment">// Here we use micro task by default, but expose a way to force macro task when</span></span><br><span class="line"><span class="comment">// needed (e.g. in event handlers attached by v-on).</span></span><br><span class="line"><span class="keyword">let</span> microTimerFunc</span><br><span class="line"><span class="keyword">let</span> macroTimerFunc</span><br><span class="line"><span class="keyword">let</span> useMacroTask = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (useMacroTask) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * macroTimerFunc = () =&gt; &#123;</span></span><br><span class="line"><span class="comment">       *   setImmediate(flushCallbacks)</span></span><br><span class="line"><span class="comment">       * &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * const p = Promise.resolve()</span></span><br><span class="line"><span class="comment">       * microTimerFunc = () =&gt; &#123;</span></span><br><span class="line"><span class="comment">       *  p.then(flushCallbacks)</span></span><br><span class="line"><span class="comment">       * &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a><a href="https://cn.vuejs.org/v2/api/#Vue-use" target="_blank" rel="noopener">Vue.use</a></h2><blockquote><p>安装 <code>Vue.js</code> 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 <code>install</code> 方法。<code>install</code> 方法调用时，会将 Vue 作为参数传入。当 <code>install</code> 方法被同一个插件多次调用，插件将只会被安装一次。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: Function | Object</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存或初始化 installedPlugins</span></span><br><span class="line">    <span class="keyword">const</span> installedPlugins = (<span class="keyword">this</span>._installedPlugins || (<span class="keyword">this</span>._installedPlugins = []))</span><br><span class="line">    <span class="comment">// 若已经存在该plugin(引用相同)，返回</span></span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// additional parameters</span></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>) <span class="comment">// Convert an Array-like object to a real Array</span></span><br><span class="line">    args.unshift(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin) <span class="comment">// this._installedPlugins同时会改变</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-mixin"><a href="#Vue-mixin" class="headerlink" title="Vue.mixin"></a><a href="https://cn.vuejs.org/v2/api/#Vue-mixin" target="_blank" rel="noopener">Vue.mixin</a></h2><p>全局注册一个混入，影响注册之后所有创建的每个 <code>Vue</code> 实例。插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  Vue.mixin = <span class="function"><span class="keyword">function</span> (<span class="params">mixin: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.options = mergeOptions(<span class="keyword">this</span>.options, mixin)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-extend"><a href="#Vue-extend" class="headerlink" title="Vue.extend"></a><a href="https://cn.vuejs.org/v2/api/#Vue-extend" target="_blank" rel="noopener">Vue.extend</a></h2><p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。<br><code>data</code> 选项是特例，需要注意 - 在 <code>Vue.extend()</code> 中它必须是函数。这里我的理解是因为创建出来的子类的实例会共享这个options.data配置，实例之间对于data的修改也会互相影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initExtend</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Each instance constructor, including Vue, has a unique</span></span><br><span class="line"><span class="comment">   * cid. This enables us to create wrapped "child</span></span><br><span class="line"><span class="comment">   * constructors" for prototypal inheritance and cache them.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Vue.cid = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> cid = <span class="number">1</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Class inheritance</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> Super = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> SuperId = Super.cid</span><br><span class="line">    <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> (cachedCtors[SuperId]) &#123; <span class="comment">// 如果有通过该构造器和options对象构造的示例缓存，直接返回</span></span><br><span class="line">      <span class="keyword">return</span> cachedCtors[SuperId]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> name = extendOptions.name || Super.options.name <span class="comment">// 读取name或Super的name</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; name) &#123;</span><br><span class="line">      <span class="comment">// 校验name属性值</span></span><br><span class="line">      validateComponentName(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123; <span class="comment">// Sub类，调用Vue的构造函数_init</span></span><br><span class="line">      <span class="keyword">this</span>._init(options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组合继承</span></span><br><span class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</span><br><span class="line">    Sub.prototype.constructor = Sub</span><br><span class="line"></span><br><span class="line">    Sub.cid = cid++</span><br><span class="line">    <span class="comment">// 合并options</span></span><br><span class="line">    Sub.options = mergeOptions(</span><br><span class="line">      Super.options,</span><br><span class="line">      extendOptions</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 在./instance/init.js resolveConstructorOptions等方法中会用到这个字段</span></span><br><span class="line">    Sub[<span class="string">'super'</span>] = Super</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For props and computed properties, we define the proxy getters on</span></span><br><span class="line">    <span class="comment">// the Vue instances at extension time, on the extended prototype. This</span></span><br><span class="line">    <span class="comment">// avoids Object.defineProperty calls for each instance created.</span></span><br><span class="line">    <span class="comment">// 把props和computed放在原型链上，这样可以避免每次实例创建都要去调用Object.defineProperty</span></span><br><span class="line">    <span class="keyword">if</span> (Sub.options.props) &#123;</span><br><span class="line">      initProps(Sub)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Sub.options.computed) &#123;</span><br><span class="line">      initComputed(Sub)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allow further extension/mixin/plugin usage</span></span><br><span class="line">    Sub.extend = Super.extend</span><br><span class="line">    Sub.mixin = Super.mixin</span><br><span class="line">    Sub.use = Super.use</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create asset registers, so extended classes</span></span><br><span class="line">    <span class="comment">// can have their private assets too.</span></span><br><span class="line">    ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">      Sub[type] = Super[type]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// enable recursive self-lookup</span></span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">      Sub.options.components[name] = Sub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存一个Super.options的引用，在之后实例化的时候我们可以判断是否父类的options发生了更新</span></span><br><span class="line">    Sub.superOptions = Super.options</span><br><span class="line">    Sub.extendOptions = extendOptions</span><br><span class="line">    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cache constructor 缓存</span></span><br><span class="line">    cachedCtors[SuperId] = Sub</span><br><span class="line">    <span class="keyword">return</span> Sub</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> props = Comp.options.props</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      proxy(Comp.prototype, <span class="string">`_props`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-components、Vue-directive、Vue-filter"><a href="#Vue-components、Vue-directive、Vue-filter" class="headerlink" title="Vue.components、Vue.directive、Vue.filter"></a><a href="https://cn.vuejs.org/v2/api/#Vue-component" target="_blank" rel="noopener">Vue.components</a>、<a href="https://cn.vuejs.org/v2/api/#Vue-directive" target="_blank" rel="noopener">Vue.directive</a>、<a href="https://cn.vuejs.org/v2/api/#Vue-filter" target="_blank" rel="noopener">Vue.filter</a></h2><p><code>Vue.components、Vue.directive、Vue.filter</code>三个方法的定义都写在了<code>initAssetRegisters</code>方法里。</p><ul><li>Vue.components：注册或获取全局组件。注册还会自动使用给定的<code>id</code>设置组件的名称 参考：<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">组件</a></li><li>Vue.directive: 注册或获取全局指令。 参考：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义指令</a></li><li>Vue.filter: 注册或获取全局过滤器。参考：<a href="https://cn.vuejs.org/v2/guide/filters.html" target="_blank" rel="noopener">过滤器</a></li></ul><p>它们的用法类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册组件，传入一个扩展过的构造器</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, Vue.extend(&#123; <span class="comment">/* ... */</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取注册的组件 (始终返回构造器)</span></span><br><span class="line"><span class="keyword">var</span> MyComponent = Vue.component(<span class="string">'my-component'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// directive</span></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="comment">// 钩子函数</span></span><br><span class="line">Vue.directive(<span class="string">'my-directive'</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</span></span><br><span class="line">  update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 所在组件的 VNode 更新时调用</span></span><br><span class="line">  componentUpdated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 指令所在组件的 VNode 及其子 VNode 全部更新后调用。</span></span><br><span class="line">  unbind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 只调用一次，指令与元素解绑时调用。</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 (指令函数)</span></span><br><span class="line">Vue.directive(<span class="string">'my-directive'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里将会被 `bind` 和 `update` 调用</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter，返回已注册的指令</span></span><br><span class="line"><span class="keyword">var</span> myDirective = Vue.directive(<span class="string">'my-directive'</span>)</span><br></pre></td></tr></table></figure><p>定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export const ASSET_TYPES = [</span></span><br><span class="line"><span class="comment">//   'component',</span></span><br><span class="line"><span class="comment">//   'directive',</span></span><br><span class="line"><span class="comment">//   'filter'</span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initAssetRegisters</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create asset registration methods.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    Vue[type] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      id: string,</span></span></span><br><span class="line"><span class="function"><span class="params">      definition: Function | Object</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>): <span class="title">Function</span> | <span class="title">Object</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果没有传入definition, 则通过id去返回之前注册过的</span></span><br><span class="line">      <span class="keyword">if</span> (!definition) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; type === <span class="string">'component'</span>) &#123;</span><br><span class="line">          <span class="comment">// 校验components的名字</span></span><br><span class="line">          validateComponentName(id)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; isPlainObject(definition)) &#123;</span><br><span class="line">          <span class="comment">// 如果是component, 且传入的是个对象，则用component被初始化前的状态去调用extend</span></span><br><span class="line">          definition.name = definition.name || id</span><br><span class="line">          definition = <span class="keyword">this</span>.options._base.extend(definition)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">'directive'</span> &amp;&amp; <span class="keyword">typeof</span> definition === <span class="string">'function'</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果是directive，且传入的是个函数，则给bind和update赋值</span></span><br><span class="line">          definition = &#123; <span class="attr">bind</span>: definition, <span class="attr">update</span>: definition &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id] = definition</span><br><span class="line">        <span class="keyword">return</span> definition</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li><a href="http://www.w3school.com.cn/jsref/jsref_splice.asp" target="_blank" rel="noopener">Array.splice()</a></li><li><a href="https://segmentfault.com/p/1210000008826901/read" target="_blank" rel="noopener">异步 JavaScript 之理解 macrotask 和 microtask</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/cky917/vue-source-code-study&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;学习代码仓库&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue源码学习" scheme="http://blog.chenkeyi.com/tags/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue源码学习笔记--初始化流程</title>
    <link href="http://blog.chenkeyi.com/2018/03/08/vue-source-code-study-1/"/>
    <id>http://blog.chenkeyi.com/2018/03/08/vue-source-code-study-1/</id>
    <published>2018-03-08T03:48:00.000Z</published>
    <updated>2018-03-08T03:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/cky917/vue-source-code-study" target="_blank" rel="noopener">学习代码仓库</a></p><a id="more"></a><h1 id="初始化Vue流程"><a href="#初始化Vue流程" class="headerlink" title="初始化Vue流程"></a>初始化Vue流程</h1><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/index.js" target="_blank" rel="noopener">入口</a></p><p><code>./core/instance/index.js</code><br>定义了一个构造函数</p><p>然后执行了以下方法，给构造函数的原型加了一些属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure><h2 id="初始化原型（实例）的方法和属性"><a href="#初始化原型（实例）的方法和属性" class="headerlink" title="初始化原型（实例）的方法和属性"></a>初始化原型（实例）的方法和属性</h2><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js" target="_blank" rel="noopener">initMixin</a>方法给原型增加了<code>_init</code>方法，也就是每次执行<code>new Vew()</code>的时候都会调用。具体的后面再说。// TODO</p><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js" target="_blank" rel="noopener">stateMixin</a>给原型挂载了<code>$data</code>、<code>$props</code>属性，并重写了它们的<code>getter</code>,分别读取实例的<code>_data</code>和<code>_props</code>。<br>然后挂载了<code>$set</code>、<code>$del</code>、<code>$watch</code>方法，这些后面再细看。 // TODO</p><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/events.js" target="_blank" rel="noopener">eventMixin</a>给原型挂载了<code>$on</code>、<code>$once</code>、<code>$off</code>、<code>$emit</code>方法，后续细看。// TODO</p><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js" target="_blank" rel="noopener">lifecycleMixin</a> 方法给原型定义了<code>_update</code>方法、以及<code>$forceUpdate</code>、<code>$destroy</code>, 后续细看 // TODO</p><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/render.js" target="_blank" rel="noopener">renderMixin</a>方法给原型定义了<code>$nextTick</code>方法，并且执行了<code>installRenderHelpers</code>方法给原型增加了一系列私有的方法，和<code>_render</code>方法,后续细看 //TODO</p><p>最后抛出Vue构造函数</p><h2 id="初始化全局api"><a href="#初始化全局api" class="headerlink" title="初始化全局api"></a>初始化全局api</h2><p>然后执行<a href="https://github.com/vuejs/vue/blob/dev/src/core/global-api/index.js" target="_blank" rel="noopener">initGlobalApi(Vue)</a>方法，将一些方法和属性挂在构造函数上成为全局api<br>如：</p><ul><li><code>Vue.config</code>（全局配置 <a href="https://cn.vuejs.org/v2/api/#silent" target="_blank" rel="noopener">文档</a>)</li><li><code>Vue.util</code>(暴露出来的方法，但不是作为全局api考虑的，不建议使用)</li><li><code>Vue.set</code> <a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">文档</a></li><li><code>Vue.delete</code> <a href="https://cn.vuejs.org/v2/api/#Vue-delete" target="_blank" rel="noopener">文档</a></li><li><code>Vue.nextTick</code> <a href="https://cn.vuejs.org/v2/api/#Vue-nextTick" target="_blank" rel="noopener">文档</a></li></ul><p>然后初始化options<br><code>Vue.options = Object.create(null)</code></p><p><code>Vue.options.components</code>、<br><code>Vue.options.directives</code>、<br><code>Vue.options.filters</code> 都为一个空对象( <code>Object.create(null)</code>)</p><p>将这个状态的构造函数保存到<code>Vue.options._base</code><br>然后执行<br><code>extend(Vue.options.components, builtInComponents)</code></p><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/components/keep-alive.js" target="_blank" rel="noopener">builtInComponents</a>返回的是一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'keep-alive'</span>,</span><br><span class="line">  abstract: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes,</span><br><span class="line">    exclude: patternTypes,</span><br><span class="line">    max: [<span class="built_in">String</span>, <span class="built_in">Number</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">this</span>.keys = []</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destroyed () &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="keyword">this</span>.cache) &#123;</span><br><span class="line">      pruneCacheEntry(<span class="keyword">this</span>.cache, key, <span class="keyword">this</span>.keys)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  watch: &#123;</span><br><span class="line">    include (val: string | <span class="built_in">RegExp</span> | <span class="built_in">Array</span>&lt;string&gt;) &#123;</span><br><span class="line">      pruneCache(<span class="keyword">this</span>, name =&gt; matches(val, name))</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude (val: string | <span class="built_in">RegExp</span> | <span class="built_in">Array</span>&lt;string&gt;) &#123;</span><br><span class="line">      pruneCache(<span class="keyword">this</span>, name =&gt; !matches(val, name))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">// 后面再细看</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>Vue.options.components</code>之前是初始化的一个空对象，所以<code>extend</code>处理之后，现在它变成了上述代码</p><p>然后顺序调用</p><ul><li><a href="https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js" target="_blank" rel="noopener">initUse(Vue)</a></li><li><a href="https://github.com/vuejs/vue/blob/dev/src/core/global-api/mixin.js" target="_blank" rel="noopener">initMixin(Vue)</a></li><li><a href="https://github.com/vuejs/vue/blob/dev/src/core/global-api/extend.js" target="_blank" rel="noopener">initExtend(Vue)</a></li><li><a href="https://github.com/vuejs/vue/blob/dev/src/core/global-api/assets.js" target="_blank" rel="noopener">initAssetRegisters(Vue)</a></li></ul><p>然后给<code>Vue.prototype</code>增加了<code>$isServer</code>、<code>$ssrContext</code><br>两个字段<br>最后<code>Vue</code>增加了<code>version</code>字段</p><p>所以在还未进行任何操作，只是引入了Vue时，Vue的状态如下</p><p><img src="/images/1.png"></p><p><img src="/images/2.png"></p><p><img src="/images/3.png"></p><p><img src="/images/4.png"></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/cky917/vue-source-code-study&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;学习代码仓库&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue源码学习" scheme="http://blog.chenkeyi.com/tags/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript学习笔记 - 函数</title>
    <link href="http://blog.chenkeyi.com/2018/02/28/typescript3/"/>
    <id>http://blog.chenkeyi.com/2018/02/28/typescript3/</id>
    <published>2018-02-28T06:25:00.000Z</published>
    <updated>2018-03-08T03:46:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript学习笔记 - 函数<br><a id="more"></a></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。</p><h2 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h2><p>JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是<code>undefined</code>。 在TypeScript里我们可以在参数名旁使用 ?实现可选参数的功能。 比如，我们想让<code>last name</code>是可选的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName?: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName)</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>);  <span class="comment">// works correctly now</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);  <span class="comment">// ah, just right</span></span><br></pre></td></tr></table></figure><p>可选参数必须跟在必须参数后面。 如果上例我们想让<code>first name</code>是可选的，那么就必须调整它们的位置，把<code>first name</code>放在后面。</p><p>在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是undefined时。 它们叫做有默认初始化值的参数。 让我们修改上例，把last name的默认值设置为”Smith”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName = <span class="string">"Smith"</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>);                  <span class="comment">// works correctly now, returns "Bob Smith"</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="literal">undefined</span>);       <span class="comment">// still works, also returns "Bob Smith"</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result4 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);         <span class="comment">// ah, just right</span></span><br></pre></td></tr></table></figure><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用 <code>arguments</code>来访问所有传入的参数。</p><p>在TypeScript里，你可以把所有参数收集到一个变量里：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, ...restOfName: string[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">"Joseph"</span>, <span class="string">"Samuel"</span>, <span class="string">"Lucas"</span>, <span class="string">"MacKinzie"</span>);</span><br></pre></td></tr></table></figure><p>// TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript学习笔记 - 函数&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端知识" scheme="http://blog.chenkeyi.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript学习笔记 - 接口、类</title>
    <link href="http://blog.chenkeyi.com/2018/02/28/typescript2/"/>
    <id>http://blog.chenkeyi.com/2018/02/28/typescript2/</id>
    <published>2018-02-28T03:42:00.000Z</published>
    <updated>2018-02-28T06:49:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript学习笔记 - 接口、类<br><a id="more"></a></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123;<span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">"Size 10 Object"</span>&#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure><p><code>LabelledValue</code>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 <code>label</code>属性且类型为<code>string</code>的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p><p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123;color: string; area: number&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123;<span class="attr">color</span>: <span class="string">"white"</span>, <span class="attr">area</span>: <span class="number">100</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123;<span class="attr">color</span>: <span class="string">"black"</span>&#125;);</span><br></pre></td></tr></table></figure><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p><p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。</p><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  readonly x: number;</span><br><span class="line">  readonly y: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>。 赋值后， x和y再也不能被改变了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1: Point = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p><code>TypeScript</code>具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> number[];</span><br></pre></td></tr></table></figure><p><strong>readonly vs const</strong></p><p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用<code>readonly</code>。</p><h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><p>最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code>带有上面定义的类型的<code>color</code>和<code>width</code>属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]或ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个 <code>索引签名</code>，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray;</span><br><span class="line">myArray = [<span class="string">"Bob"</span>, <span class="string">"Fred"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: string = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  greeting: string;</span><br><span class="line">  <span class="keyword">constructor</span>(message: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message;</span><br><span class="line">  &#125;</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">this</span>.greeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    <span class="keyword">constructor</span>(theName: string) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">    move(distanceInMeters: number = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snake</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: string) &#123; <span class="keyword">super</span>(name); &#125;</span><br><span class="line">    move(distanceInMeters = <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Slithering..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: string) &#123; <span class="keyword">super</span>(name); &#125;</span><br><span class="line">    move(distanceInMeters = <span class="number">45</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Galloping..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> Snake(<span class="string">"Sammy the Python"</span>);</span><br><span class="line"><span class="keyword">let</span> tom: Animal = <span class="keyword">new</span> Horse(<span class="string">"Tommy the Palomino"</span>);</span><br><span class="line"></span><br><span class="line">sam.move();</span><br><span class="line">tom.move(<span class="number">34</span>);</span><br></pre></td></tr></table></figure><p>我们使用 <code>extends</code>关键字创建了 <code>Animal</code>的两个子类： <code>Horse</code>和 <code>Snake</code>。</p><p>派生类包含了一个构造函数，它 <strong>必须调用</strong> <code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问 <code>this</code>的属性之前，我们 <strong>一定</strong>要调用 <code>super()</code>。 这个是TypeScript强制执行的一条重要规则。</p><p>这个例子演示了如何在子类里可以重写父类的方法。 <code>Snake</code>类和 <code>Horse</code>类都创建了 <code>move</code>方法，它们重写了从 <code>Animal</code>继承来的 <code>move</code>方法，使得 <code>move</code>方法根据不同的类而具有不同的功能。 注意，即使 <code>tom</code>被声明为 <code>Animal</code>类型，但因为它的值是 <code>Horse</code>，调用 <code>tom.move(34)</code>时，它会调用 <code>Horse</code>里重写的方法：</p><h2 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h2><p>在TypeScript里，成员都默认为 <code>public</code>,你也可以明确的将一个成员标记成 <code>public</code></p><p><strong> 理解 <code>private</code> </strong><br>当成员被标记成 <code>private</code>时，它就不能在声明它的类的外部访问，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    <span class="keyword">constructor</span>(theName: string) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Animal(<span class="string">"Cat"</span>).name; <span class="comment">// 错误: 'name' 是私有的.</span></span><br></pre></td></tr></table></figure><p><strong> 理解 <code>protected</code></strong><br><code>protected</code>修饰符与 <code>private</code>修饰符的行为很相似，但有一点不同， <code>protected</code>成员在派生类中仍然可以访问。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    <span class="keyword">constructor</span>(name: string) &#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    private department: string;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name: string, department: string) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.department = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public getElevatorPitch() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(howard.getElevatorPitch());</span><br><span class="line"><span class="built_in">console</span>.log(howard.name); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>注意，我们不能在<code>Person</code>类外使用 <code>name</code>，但是我们仍然可以通过 <code>Employee</code>类的实例方法访问，因为 <code>Employee</code>是由 <code>Person</code>派生而来的。</p><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>TypeScript支持通过<code>getters/setters</code>来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">"secret passcode"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    private _fullName: string;</span><br><span class="line"></span><br><span class="line">    get fullName(): string &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set fullName(newName: string) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">"secret passcode"</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._fullName = newName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Error: Unauthorized update of employee!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Bob Smith"</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">    alert(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> origin = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    calculateDistanceFromOrigin(point: &#123;<span class="attr">x</span>: number; y: number;&#125;) &#123;</span><br><span class="line">        <span class="keyword">let</span> xDist = (point.x - Grid.origin.x);</span><br><span class="line">        <span class="keyword">let</span> yDist = (point.y - Grid.origin.y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="keyword">this</span>.scale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> (public scale: number) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>);  <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">5.0</span>);  <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;));</span><br></pre></td></tr></table></figure><p>摘抄自 <a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">typescrpit中文文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript学习笔记 - 接口、类&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端知识" scheme="http://blog.chenkeyi.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript学习笔记 - 基础类型、变量声明</title>
    <link href="http://blog.chenkeyi.com/2018/02/28/typescript1/"/>
    <id>http://blog.chenkeyi.com/2018/02/28/typescript1/</id>
    <published>2018-02-28T02:48:00.000Z</published>
    <updated>2018-02-28T06:49:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript学习笔记 - 基础类型、变量声明<br><a id="more"></a></p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值："><a href="#布尔值：" class="headerlink" title="布尔值："></a>布尔值：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: boolean = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binaryLiteral: number = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octalLiteral: number = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: string = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> age: number = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: string = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I'll be <span class="subst">$&#123; age + <span class="number">1</span> &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [string, number];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>]; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当访问一个已知索引的元素，会得到正确的类型：</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)); <span class="comment">// Error, 'number' does not have 'substr'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当访问一个越界的元素，会使用联合类型替代：</span></span><br><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</span></span><br><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者，全部都采用手动赋值：</span></span><br><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: any = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">"maybe a string instead"</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure><p>在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为<code>Object</code>有相似的作用，就像它在其它语言中那样。 但是<code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: any = <span class="number">4</span>;</span><br><span class="line">notSure.ifItExists(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.toFixed(); <span class="comment">// okay, toFixed exists (but the compiler doesn't check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prettySure: <span class="built_in">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.toFixed(); <span class="comment">// Error: Property 'toFixed' doesn't exist on type 'Object'.</span></span><br></pre></td></tr></table></figure><p>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: any[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">"free"</span>];</span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">"This is my warning message"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p><p>然而，当你指定了<code>--strictNullChecks</code>标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string或null或undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。</p><blockquote><p>注意：我们鼓励尽可能地使用–strictNullChecks</p></blockquote><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code>类型，当它们被永不为真的类型保护所约束时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>someValue).length;</span></span><br></pre></td></tr></table></figure><p>另一个为as语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (someValue <span class="keyword">as</span> string).length;</span><br></pre></td></tr></table></figure><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 <code>as</code>语法断言是被允许的。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><h3 id="变量与作用域"><a href="#变量与作用域" class="headerlink" title="变量与作用域"></a>变量与作用域</h3><p>推荐使用<code>let</code>和<code>const</code>，基本用法同javascript</p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><p>基本用法同javascript<br>作用域函数参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[first, second]: [number, number]</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first);</span><br><span class="line">    <span class="built_in">console</span>.log(second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(input);</span><br></pre></td></tr></table></figure></p><p>你可以在数组里使用<code>...</code>语法创建剩余变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b&#125;: &#123;<span class="attr">a</span>: string, <span class="attr">b</span>: number&#125; = o;</span><br></pre></td></tr></table></figure><p>默认值可以让你在属性为 undefined 时使用缺省值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keepWholeObject</span>(<span class="params">wholeObject: &#123; a: string, b?: number &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; a, b = <span class="number">1001</span> &#125; = wholeObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h3><p>基本用法同javascript</p><p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  p = <span class="number">12</span>;</span><br><span class="line">  m() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">let</span> clone = &#123; ...c &#125;;</span><br><span class="line">clone.p; <span class="comment">// ok</span></span><br><span class="line">clone.m(); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>摘抄自 <a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener">typescrpit中文文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript学习笔记 - 基础类型、变量声明&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端知识" scheme="http://blog.chenkeyi.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>如何写好前端业务代码</title>
    <link href="http://blog.chenkeyi.com/2017/10/17/businessCode/"/>
    <id>http://blog.chenkeyi.com/2017/10/17/businessCode/</id>
    <published>2017-10-17T13:25:00.000Z</published>
    <updated>2017-10-17T17:27:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>想想从15年11月到现在，从zbj以前的交易取经团，到现在的顾问平台，大大小小做了不少业务需求，也是一边踩坑（一边挖坑）一边成长。以前维护10年累计下来的老代码，缝缝补补，主站所有项目全部在一个文件夹里，也是练就了一身从定位代码的本事。到后来新项目用了新框架，node作为controller层，后台不需要兼容ie的项目也引入了vue。刚开始的时候开心得不行，终于不用苦逼地搭php那一套老开发环境，前后端彻底分离，也不用维护那些“陈年佳酿”。后来才慢慢发现，其实并不是那么轻松。java写的服务化接口，基本是原子性的接口，一个接口只做一件事，所以前端除了完成以前的工作外，node端必须去处理之前几乎没有涉及到的业务逻辑，也承担了更重要的责任。经过了一年左右，几个项目的摸索，我也总结出了一些业务经验。</p><h2 id="二、排期"><a href="#二、排期" class="headerlink" title="二、排期"></a>二、排期</h2><p>这是很重要却最容易被忽略的一个环节。项目做到后面做得很累，感觉自己怎么也完不成，往往是因为排期没有做好。 </p><h3 id="需求分析-功能模块细分"><a href="#需求分析-功能模块细分" class="headerlink" title="需求分析,功能模块细分"></a>需求分析,功能模块细分</h3><p>一个需求我们拿到的时候，肯定是先做需求分析。排期也是在完成需求分析的基础上进行的，需求分析的时候需要注意以下几点。</p><h4 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h4><p>根据产品原型和产品的需求宣讲，梳理一遍需求，如果有自己不懂或者不理解的地方一定要在这个阶段产品明确。</p><h4 id="模块、功能划分"><a href="#模块、功能划分" class="headerlink" title="模块、功能划分"></a>模块、功能划分</h4><p>单页面排期一般就是从上到下按照功能不同分模块，比如顶部导航、信息展示、评价列表等等。</p><p>一般一个多页面的项目，产品们会在产品原型上根据他们的理解，分几个板块。但是我们分析需求的时候不能用他们的思路去分版块，而是要从开发和程序设计的角度去划分。比如在首页、某某搜索结果页、某某页有三个不同的地方，虽然样式不同、逻辑不完全相同，但是他们都在某步骤上涉及同一个业务逻辑。比如点击某个地方，判断用户在线，不在线调出登录框，在线的话创建订单，然后跳转支付页面。balabala，这个逻辑是不是最好让同一个人去完成，而且最好写成一个统一的接口或者组件呢。</p><h3 id="依赖关系整理，时间线整理"><a href="#依赖关系整理，时间线整理" class="headerlink" title="依赖关系整理，时间线整理"></a>依赖关系整理，时间线整理</h3><p>划分好模块后，就是进行工期预估了。这也是一项很重要的工作，不仅是让团队的开发、测试、上线计划能够顺利开展，而且也能帮我们进行前期工作优先级安排。</p><p>需要依赖的东西包括设计稿、后端接口、其他前端组件、人员到位时间等等，排期时间需要根据这些依赖项产出的时间进行时间线的整理。</p><h3 id="风险点预测"><a href="#风险点预测" class="headerlink" title="风险点预测"></a>风险点预测</h3><p>容易产生风险的点需要提出来，排期中留出适当的缓和时间。当然在开发中遇到阻碍也要及时抛出，让PMO或者项目负责人及时跟进解决。</p><h3 id="每天跟进或者总结"><a href="#每天跟进或者总结" class="headerlink" title="每天跟进或者总结"></a>每天跟进或者总结</h3><p>根据排期最好做一个任务清单，每天总结完成的项目，想好明天的开发计划。</p><h2 id="如何面对快速的业务需求迭代"><a href="#如何面对快速的业务需求迭代" class="headerlink" title="如何面对快速的业务需求迭代"></a>如何面对快速的业务需求迭代</h2><p>最近做的一个项目是一个从0开始的新项目，产品发展方向其实也不是非常明确，需要上线试错，经过用户反馈和数据收集后不断改进。一期产品为了快速上线往往很多需求做了简化，这时候如果在一期的开发上不注重项目的扩展性，后面的每一次迭代都是伤筋动骨。</p><h3 id="功能细分、代码模块化"><a href="#功能细分、代码模块化" class="headerlink" title="功能细分、代码模块化"></a>功能细分、代码模块化</h3><p>尽量让功能变成积木一样的，每个部分写成一个模块，方便后期维护和拓展。代码模块化，一个几千行的文件，几百行的方法真的难以维护，其实就是一句话，当你觉得这部分代码好长，那就是需要拆分模块了。</p><h3 id="通用接口多样化"><a href="#通用接口多样化" class="headerlink" title="通用接口多样化"></a>通用接口多样化</h3><p>这也算是我挖的一个坑。在一期的时候，有一个搜索接口，当时的需求只需要通过一个id进行查询，我设计的接口参数就是传一个id。当1.2.4的迭代版本的时候，产品说需要支持多个id查询，java把参数改成了数组类型。我准备改的时候，发现已经有几个其他业务方调用我这个接口，传的是单个id，我为了不去改更多地方，只能在接口层面做了单个和多个的兼容。</p><p>所以在接口设计的时候，就要尽可能考虑多种调用场景，可拓展地设计接口入参和出参。</p><h3 id="公用逻辑提取"><a href="#公用逻辑提取" class="headerlink" title="公用逻辑提取"></a>公用逻辑提取</h3><p>之前也提到了，在一期的时候可能我们并没有发现这个逻辑其他地方也可能会用，所以写到了自己的模块文件里。当后面业务发展，这个逻辑其他业务方也要接入，而且仅仅是来复制粘贴你的代码的时候，就应该要马上做出判断，这部分逻辑是否需要提成一个公用接口，如果是包含了前端各种逻辑比如弹窗、调用其他前端组件等，这个逻辑就要提成一个组件。<br>一是减少了后续的开发成本和维护成本，二是让这部分逻辑更加可控。保证后续修改逻辑的时候，没有遗漏到某个地方。除了保证组件的一致性，可拓展性也很重要，对于组件的设计，又是另外一个话题了。</p><h3 id="内容配置化，业务逻辑不要写死"><a href="#内容配置化，业务逻辑不要写死" class="headerlink" title="内容配置化，业务逻辑不要写死"></a>内容配置化，业务逻辑不要写死</h3><p>除了产品提出需求要开发配置功能外，我们自己也要主动去拆分可配置的内容。<br>一些业务上经常改动的部分，需要产品和运营去修改的部分，比如推荐位id列表，推荐位图片等，走cms配置。<br>一些静态数据，不经常改但是可能改动，比如网址等可以写到配置中心或者配置文件。<br>如果实在没必要走配置的，也要写成一个常量，这就让我想起了以前接的一个需求，把某某发布最低金额限制的判断从<code>3000</code>改到<code>1000</code>，我在老代码里<code>ctrl+f</code>了很多地方，才把那些<code>3000</code>全部改成一个统一的常量。</p><p>静态内容和代码分离是最好的，内容改动，仅仅改一下配置就行，不需要走上线流程，这样才能真正做到以不变应万变。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>还有其他需要注意的点，我也就不一一说明了。</p><ul><li>发现不对劲，一定要停下来和产品沟通。</li><li>任何显示给用户的字符串，都应该抽取成常量，方便国际化，这点也是我做了一个项目转国际化的需求得出的感想。但是在后续开发中其实还是没有实施，如果项目有国际化的需求，需要考虑这一点。</li></ul><h2 id="三、业务安全问题"><a href="#三、业务安全问题" class="headerlink" title="三、业务安全问题"></a>三、业务安全问题</h2><p>因为做了Node层，很多参数校验都是我们做了，也就积累了一些和业务安全相关的经验（安全测试环节被查水表）。这里提到的就不仅仅是xss和csrf了，更多的是业务层面的安全问题</p><ul><li>xss</li><li>csrf</li><li>表单提交的内容，如果网站有这个需求，需要做违规违法字过滤</li><li>推送红包、站内信、通知、发布订单、发送手机验证码等http接口，需要做防刷处理，限制次数</li><li>用户id用token加密解密获取，而不是直接用cookie里的userid</li><li>注意判断用户的身份和权限，防止越权</li></ul><h2 id="四、定位问题"><a href="#四、定位问题" class="headerlink" title="四、定位问题"></a>四、定位问题</h2><ol><li>尽量在所有可能出错的地方，捕获并抛出问题，报错内容清晰指明什么接口报错，方便定位。比如一大堆的报错都是<code>&#39;系统异常！&#39;</code>和<code>创建支付订单失败：xxxx</code>，哪个更容易定位错误呢？</li><li>方法文档清晰。</li><li>使用charles、findler等工具调试非本地环境代码</li></ol><p>暂时想到了这些，如果后续还有新的体会会来补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;想想从15年11月到现在，从zbj以前的交易取经团，到现在的顾问平台，大大小小做了不少业务需求，也是一边踩坑（一边挖坑）一边
      
    
    </summary>
    
    
      <category term="体会感悟" scheme="http://blog.chenkeyi.com/tags/%E4%BD%93%E4%BC%9A%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>webpack学习笔记</title>
    <link href="http://blog.chenkeyi.com/2017/09/05/webpack/"/>
    <id>http://blog.chenkeyi.com/2017/09/05/webpack/</id>
    <published>2017-09-05T08:31:00.000Z</published>
    <updated>2017-10-17T20:06:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>webpack学习笔记<br><a id="more"></a></p><blockquote><p><a href="https://doc.webpack-china.org/guides/getting-started/" target="_blank" rel="noopener">官方文档</a></p></blockquote><h2 id="webpack的特点"><a href="#webpack的特点" class="headerlink" title="webpack的特点"></a>webpack的特点</h2><h3 id="代码拆分"><a href="#代码拆分" class="headerlink" title="代码拆分"></a>代码拆分</h3><p><code>Webpack</code> 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。</p><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p><code>Webpack</code> 本身只能处理原生的 <code>JavaScript</code> 模块，但是 <code>loader</code> 转换器可以将各种类型的资源转换成 <code>JavaScript</code> 模块。这样，任何资源都可以成为 <code>Webpack</code> 可以处理的模块。</p><h3 id="智能解析"><a href="#智能解析" class="headerlink" title="智能解析"></a>智能解析</h3><p><code>Webpack</code> 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 <code>CommonJS</code>、 <code>AMD</code> 还是普通的 <code>JS</code> 文件。甚至在加载依赖的时候，允许使用动态表达式 <code>require(&quot;./templates/&quot; + name + &quot;.jade&quot;)</code>。</p><h3 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h3><p><code>Webpack</code> 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。</p><h3 id="快速运行"><a href="#快速运行" class="headerlink" title="快速运行"></a>快速运行</h3><p><code>Webpack</code> 使用异步 <code>I/O</code> 和多级缓存提高运行效率，这使得 <code>Webpack</code> 能够以令人难以置信的速度快速增量编译。</p><h2 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//入口文件</span></span><br><span class="line">    <span class="comment">// entry: './src/script/main.js',</span></span><br><span class="line">    <span class="comment">// entry:["./src/script/main.js","./src/script/a.js"],//把2个文件打包在一起</span></span><br><span class="line">    entry:&#123;</span><br><span class="line">        main:<span class="string">'./src/script/main.js'</span>,</span><br><span class="line">        a:<span class="string">"./src/script/a.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">        filename: <span class="string">'js/[name]-[chunkhash].js'</span>,</span><br><span class="line">        publicPath: <span class="string">'http://cdn.com'</span> <span class="comment">//编译的文件域名</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                <span class="string">'style-loader'</span>,</span><br><span class="line">                <span class="string">'css-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//source-map 仅开发环境使用</span></span><br><span class="line">    devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="comment">//https://www.npmjs.com/package/html-webpack-plugin</span></span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            filename:<span class="string">'index.html'</span>,</span><br><span class="line">            template: <span class="string">'index.html'</span>,</span><br><span class="line">            inject:<span class="string">'body'</span>, <span class="comment">//script标签放的位置</span></span><br><span class="line">            title:<span class="string">'webpack is index'</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeComments:<span class="literal">true</span>,<span class="comment">//删除注释</span></span><br><span class="line">                collapseWhitespace:<span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// chunks: ['main','a'] //指定当前html包含的chunk</span></span><br><span class="line">            excludeChunks:[<span class="string">'a'</span>]<span class="comment">//指定排除的chunk</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            filename:<span class="string">'a.html'</span>,</span><br><span class="line">            template: <span class="string">'index.html'</span>,</span><br><span class="line">            inject:<span class="string">'body'</span>, <span class="comment">//script标签放的位置</span></span><br><span class="line">            title:<span class="string">'webpack is a'</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeComments:<span class="literal">true</span>,<span class="comment">//删除注释</span></span><br><span class="line">                collapseWhitespace:<span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// chunks: ['a'] //指定当前html包含的chunk</span></span><br><span class="line">            excludeChunks:[<span class="string">'main'</span>]<span class="comment">//指定排除的chunk</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack学习笔记&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端知识" scheme="http://blog.chenkeyi.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>postMessage解决跨域、跨窗口消息传递</title>
    <link href="http://blog.chenkeyi.com/2017/08/27/postMessage-api/"/>
    <id>http://blog.chenkeyi.com/2017/08/27/postMessage-api/</id>
    <published>2017-08-27T06:06:50.000Z</published>
    <updated>2017-10-17T20:07:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个需求，页面嵌入了iframe框，iframe框里是一个Im在线聊天对话框。在用户切换聊天对象时，外层页面也需要获取当前用户正在聊天的对方的userid。但是由于im页面是嵌入的iframe，外层父页面既无法监听切换聊天对象的事件，也无法获取里面的dom元素，会报跨域的错误。为了解决这一问题，可以使用html5的API<code>postMessage</code>.</p><a id="more"></a><h2 id="postMessage简单介绍"><a href="#postMessage简单介绍" class="headerlink" title="postMessage简单介绍"></a>postMessage简单介绍</h2><p><code>postMessage()</code>方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p><p><code>postMessage(data,origin)</code>方法接受两个参数</p><p> 1.data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。</p><p>2.origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p><h2 id="子页面和父页面互相发送消息"><a href="#子页面和父页面互相发送消息" class="headerlink" title="子页面和父页面互相发送消息"></a>子页面和父页面互相发送消息</h2><p>为了兼容IE和非IE的事件绑定，下面的例子直接用了jQuery监听事件，如果用原生js，注意<code>function(e)</code>中的<code>e</code>没有包装在<code>e.originalEvent</code>，需要根据实际情况获取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在im页面，监听切换用户事件，然后给别人发送对方的用户id。</span></span><br><span class="line">$(<span class="string">'#im'</span>).on(<span class="string">'click'</span>,<span class="string">'.person-item'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = &#123;<span class="attr">key</span>:<span class="string">'getUserId'</span>,<span class="attr">val</span>:<span class="string">'18'</span>&#125;;</span><br><span class="line">    <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data),<span class="string">'https://coolmogu.com'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//监听来自父页面的回执</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> original = e.originalEvent;</span><br><span class="line">    <span class="keyword">if</span>(original.source != <span class="built_in">window</span>.parent) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父窗口说他收到了'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在父页面，监听事件，</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> original = e.originalEvent;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(original.data);</span><br><span class="line">    <span class="keyword">if</span>(original.origin != <span class="string">'https://im.com'</span> ||  data.key != <span class="string">'getUserId'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'当前im对话的对象是'</span> + data.val);</span><br><span class="line">    <span class="comment">//父页面给iframe页面发送消息</span></span><br><span class="line">    <span class="built_in">window</span>.frames[<span class="number">0</span>].postMessage(<span class="string">'我收到了'</span>,<span class="string">'http://im.com'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到一个需求，页面嵌入了iframe框，iframe框里是一个Im在线聊天对话框。在用户切换聊天对象时，外层页面也需要获取当前用户正在聊天的对方的userid。但是由于im页面是嵌入的iframe，外层父页面既无法监听切换聊天对象的事件，也无法获取里面的dom元素，会报跨域的错误。为了解决这一问题，可以使用html5的API&lt;code&gt;postMessage&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript学习笔记" scheme="http://blog.chenkeyi.com/tags/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号爬虫</title>
    <link href="http://blog.chenkeyi.com/2017/06/27/wxPachong/"/>
    <id>http://blog.chenkeyi.com/2017/06/27/wxPachong/</id>
    <published>2017-06-27T06:06:50.000Z</published>
    <updated>2017-10-17T20:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近搞了一个基于nodejs+vue的微信公众号文章爬虫，交互什么的也基本没有优化，先占个坑，之后搞好了来写写教程。<br>地址：<a href="http://read.chenkeyi.com" target="_blank" rel="noopener">http://read.chenkeyi.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近搞了一个基于nodejs+vue的微信公众号文章爬虫，交互什么的也基本没有优化，先占个坑，之后搞好了来写写教程。&lt;br&gt;地址：&lt;a href=&quot;http://read.chenkeyi.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http:/
      
    
    </summary>
    
    
      <category term="node.js学习笔记" scheme="http://blog.chenkeyi.com/tags/node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>函数防抖和节流</title>
    <link href="http://blog.chenkeyi.com/2017/04/27/debounce-and-throttle/"/>
    <id>http://blog.chenkeyi.com/2017/04/27/debounce-and-throttle/</id>
    <published>2017-04-27T06:06:50.000Z</published>
    <updated>2017-10-17T20:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><p>我们经常会遇到这样的需求：需要我们监听用户的输入向后端发送请求，比如搜索推荐，我们会监听input框的change事件，但是如果用户每次按下键盘都发送请求，会发送很多请求、卡顿等。为了优化这种情况，我们就需要用到函数防抖。</p><blockquote><p>函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。</p></blockquote><p>使用函数防抖后，假设我们input框的change事件，当输入完成后300ms我们才向服务端发送请求，如果在300ms内，用户又开始输入了，那我们就重新计时等待300ms。直到用户停止输入，300ms内都没有再次输入，我们就发出请求。这样就可以让用户真的输入完毕后才开始使用用户输入的信息，而不是在打每一个字母的时候。</p><p>我们先看下underscore.js里相关函数的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, as long as it continues to be invoked, will not</span></span><br><span class="line"><span class="comment">// be triggered. The function will be called after it stops being called for</span></span><br><span class="line"><span class="comment">// N milliseconds. If `immediate` is passed, trigger the function on the</span></span><br><span class="line"><span class="comment">// leading edge, instead of the trailing.</span></span><br><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, args, context, timestamp, result;</span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> last = _.now() - timestamp;</span><br><span class="line">    <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait - last);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    timestamp = _.now();</span><br><span class="line">    <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">    <span class="keyword">if</span> (!timeout) timeout = setTimeout(later, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参数function是需要进行函数防抖的函数；参数wait则是需要等待的时间，单位为毫秒；immediate参数如果为true，则debounce函数会在调用时立刻执行一次function，而不需要等到wait这个时间后，例如防止点击提交按钮时的多次点击就可以使用这个参数。</p><p>可以从下面我写的例子里看到2者的区别，明显看出使用了防抖的明显避免了没必要的多次请求。<br><a class="jsbin-embed" href="http://jsbin.com/fuxowejolo/1/embed?js,output" target="_blank" rel="noopener">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.41.6"></script></p><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>还有一些需求，在滚动页面的时候监听滚动的位置做出相应的交互，比如本站文章页右侧的目录导航滚动。所以我们需要监听页面的滚动事件，在滚动事件监听的回调里执行你的方法。如果用户滚动很快，一秒内可能执行上百次，导致页面性能变得很慢。<br>但是这次的情况跟上面的有所不同，我们不是要在每完成等待某个时间后去执行某函数，而是要每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。</p><p>我们还是来看一下underscore.js里相关函数的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a function, that, when invoked, will only be triggered at most once</span></span><br><span class="line"><span class="comment">// during a given window of time. Normally, the throttled function will run</span></span><br><span class="line"><span class="comment">// as much as it can, without ever going more than once per `wait` duration;</span></span><br><span class="line"><span class="comment">// but if you'd like to disable the execution on the leading edge, pass</span></span><br><span class="line"><span class="comment">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></span><br><span class="line"></span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context, args, result;</span><br><span class="line">  <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    result = func.apply(context, args);</span><br><span class="line">    <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = _.now();</span><br><span class="line">    <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">    <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参数function是需要进行函数节流的函数；参数wait则是函数执行的时间间隔，单位是毫秒。option有两个选项，throttle第一次调用时默认会立刻执行一次function，如果传入{leading: false}，则第一次调用时不执行function。{trailing: false}参数则表示禁止最后那一次延迟的调用。<br>进行滚动2个DIV内部，可以看到函数节流的效果，明显看出，快速滚动，函数节流的情况下减少了多次回调的调用。<br><a class="jsbin-embed" href="http://jsbin.com/havuximowu/1/embed?js,output" target="_blank" rel="noopener">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.41.6"></script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数防抖&quot;&gt;&lt;a href=&quot;#函数防抖&quot; class=&quot;headerlink&quot; title=&quot;函数防抖&quot;&gt;&lt;/a&gt;函数防抖&lt;/h3&gt;&lt;p&gt;我们经常会遇到这样的需求：需要我们监听用户的输入向后端发送请求，比如搜索推荐，我们会监听input框的change事件，但是
      
    
    </summary>
    
    
      <category term="web前端知识" scheme="http://blog.chenkeyi.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript 6 入门》读书笔记</title>
    <link href="http://blog.chenkeyi.com/2017/03/27/reading-notes-Of-ECMAScript6/"/>
    <id>http://blog.chenkeyi.com/2017/03/27/reading-notes-Of-ECMAScript6/</id>
    <published>2017-03-27T06:06:50.000Z</published>
    <updated>2017-10-17T20:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let与const"><a href="#let与const" class="headerlink" title="let与const"></a>let与const</h3><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><ul><li>块级作用域</li><li>不存在变量提升</li><li>暂时性死区</li><li>不允许重复声明</li></ul><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ul><li>const声明一个只读的常量。一旦声明，常量的值就不能改变。</li><li>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li><li>暂时性死区</li><li>不允许重复声明</li><li>将一个对象声明为常量必须非常小心，只是保持了指向的地址不变，不保证指向的数据不变。</li></ul><h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><p><strong>用处</strong>:</p><ol><li>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。<br><code>let { log, sin, cos } = Math;</code></li><li>交换变量的值。<code>[x,y] = [y,x]</code></li><li>从函数返回多个值。函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</li><li><p>函数参数的定义，解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>提取JSON数据。解构赋值对提取JSON对象中的数据，尤其有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonData = &#123;</span><br><span class="line">    id: <span class="number">42</span>,</span><br><span class="line">    status: <span class="string">"OK"</span>,</span><br><span class="line">    data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure></li><li><p>输入模块的指定方法,加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><p>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p><ul><li>includes()：返回布尔值，表示是否找到了参数字符串。</li><li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li><li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li></ul><p>这三个方法都支持第二个参数，表示开始搜索的位置。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'Hello world!'</span>;</span><br><span class="line">s.<span class="keyword">startsWith</span>(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="keyword">endsWith</span>(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p><h3 id="数值的拓展"><a href="#数值的拓展" class="headerlink" title="数值的拓展"></a>数值的拓展</h3><p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite）。<br><code>Number.isNaN()</code>用来检查一个值是否为NaN。<br>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">"25"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">"25"</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"NaN"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"NaN"</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h3 id="数组的拓展"><a href="#数组的拓展" class="headerlink" title="数组的拓展"></a>数组的拓展</h3><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">'hello'</span>);<span class="comment">// ['h', 'e', 'l', 'l', 'o'];</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);<span class="comment">// [ undefined, undefined, undefined ]</span></span><br></pre></td></tr></table></figure></p><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x)<span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure></p><p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。<code>Array.of</code>基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>) <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure></p><h3 id="对象的拓展"><a href="#对象的拓展" class="headerlink" title="对象的拓展"></a>对象的拓展</h3><p><strong>属性的简洁表示法</strong><br>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: "bar"&#125;</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure></p><p><strong>Object.keys()</strong><br>ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj);<span class="comment">// ["foo", "baz"]</span></span><br></pre></td></tr></table></figure></p><p><strong>Object.values()</strong><br>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)<span class="comment">// ["bar", 42]</span></span><br></pre></td></tr></table></figure></p><p><strong>Object.entries</strong><br><code>Object.entries</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj)<span class="comment">// [ ["foo", "bar"], ["baz", 42] ]</span></span><br></pre></td></tr></table></figure></p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>ES6引入了一种新的原始数据类型Symbol，<strong>表示独一无二的值</strong>。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。<br><a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener">详见文档</a></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set本身是一个构造函数，用来生成Set数据结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);<span class="comment">// 2 3 5 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以set可用来去除数组重复成员<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br><span class="line">[...new <span class="built_in">Set</span>([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>])] <span class="comment">//2,3</span></span><br></pre></td></tr></table></figure></p><p>Set结构的实例有以下属性。</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。</li><li><code>Set.prototype.size</code>：返回Set实例的成员总数。</li></ul><p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li><code>add(value)</code>：添加某个值，返回Set结构本身。</li><li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li><li><code>clear()</code>：清除所有成员，没有返回值。</li></ul><p>遍历方法：</p><ul><li><code>keys()</code>：返回键名的遍历器</li><li><code>values()</code>：返回键值的遍历器</li><li><code>entries()</code>：返回键值对的遍历器</li><li><code>forEach()</code>：使用回调函数遍历每个成员</li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]);</span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'name'</span>) <span class="comment">// "张三"</span></span><br><span class="line">map.has(<span class="string">'title'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'title'</span>) <span class="comment">// "Author"</span></span><br></pre></td></tr></table></figure><p>实例的属性和操作方法:</p><ul><li><code>size</code>属性返回Map结构的成员总数。</li><li><code>set(key, value)</code>方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是Map本身，因此可以采用链式写法。</li><li><code>get(key)</code>方法读取key对应的键值，如果找不到key，返回undefined。</li><li><code>has(key)</code>方法返回一个布尔值，表示某个键是否在Map数据结构中。</li><li><code>delete(key)</code>方法删除某个键，返回true。如果删除失败，返回false。</li><li><code>clear()</code>方法清除所有成员，没有返回值。</li></ul><p>遍历方法</p><ul><li><code>keys()</code>：返回键名的遍历器。</li><li><code>values()</code>：返回键值的遍历器。</li><li><code>entries()</code>：返回所有成员的遍历器。</li><li><code>forEach()</code>：遍历Map的所有成员。</li></ul><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">proxy</a>，文档再此，后续总结</p><h3 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h3><p><a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="noopener">reflect</a>，文档再此，后续总结</p><h3 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h3><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。<br>Iterator的遍历过程是这样的。</p><ol><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</li></ol><p>下面是一个模拟next方法返回值的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line">it.next() <span class="comment">// &#123; value: "a", done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: "b", done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p><p>凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。<br>当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。<br>在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。<br>有一些场合会默认调用Iterator接口（即Symbol.iterator方法）：</p><ol><li><p>解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">'a'</span>).add(<span class="string">'b'</span>).add(<span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">let</span> [x,y] = set;<span class="comment">// x='a'; y='b'</span></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = set;<span class="comment">// first='a'; rest=['b','c'];</span></span><br></pre></td></tr></table></figure></li><li><p>扩展运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line">[...str] <span class="comment">//  ['h','e','l','l','o']</span></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure></li><li><p>yield*<br>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>其他场合<br>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p></li></ol><ul><li><code>for...of</code></li><li><code>Array.from()</code></li><li><code>Map()</code>, <code>Set()</code>, <code>WeakMap()</code>, <code>WeakSet()</code>（比如new Map([[‘a’,1],[‘b’,2]])）</li><li><code>Promise.all()</code></li><li><code>Promise.race()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的entries方法和keys方法，参见《数组的扩展》章节。<br><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p><h3 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍Generator函数的语法和API，它的异步编程应用请看《异步操作》一章。语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。形式上，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。</p><p>Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。<br>下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。</p><h4 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h4><p>由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。<br><code>yield</code>语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br>yield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。</p><p><code>for...of</code>循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure></p><p>…待补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;let与const&quot;&gt;&lt;a href=&quot;#let与const&quot; class=&quot;headerlink&quot; title=&quot;let与const&quot;&gt;&lt;/a&gt;let与const&lt;/h3&gt;&lt;h4 id=&quot;let&quot;&gt;&lt;a href=&quot;#let&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://blog.chenkeyi.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>单元测试 &amp; mocha框架</title>
    <link href="http://blog.chenkeyi.com/2017/01/06/mocha/"/>
    <id>http://blog.chenkeyi.com/2017/01/06/mocha/</id>
    <published>2017-01-06T04:08:00.000Z</published>
    <updated>2017-10-17T20:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是单元测试"><a href="#一、什么是单元测试" class="headerlink" title="一、什么是单元测试"></a>一、什么是单元测试</h2><blockquote><p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p></blockquote><p>单元测试在前端领域并不被重视，前端程序员也没有写单元测试的习惯。但是，随着前端技术的发展，随着node的发展，越来越多“非UI”的前端代码出现，前端开发们也需要了解掌握单元测试知识。<br>单元测试是保证代码质量的重要环节之一，特别是这些代码是会提供给其他人使用的时候，比如node插件，grunt插件等等<br>单元测试的作用有许多，下面列举一些：</p><ul><li>保证代码可用</li><li>另一种纬度的文档</li><li>方便迭代回归</li><li>驱动开发</li></ul><h3 id="TDD与BDD"><a href="#TDD与BDD" class="headerlink" title="TDD与BDD"></a>TDD与BDD</h3><p><strong>TDD</strong>,全称是Test Driver Development，测试驱动开发。先编写测试用例（没有代码之前这些测试用例一个也通不过），然后再写代码让这些测试用例通过。更进一层的讲就是：编写足够的测试用例使测试失败，编写足够的代码是测试成功。我们编码的目的更加明确的。<br><strong>TDD的优点</strong>：</p><ol><li>站在用户的角度思考，从用户的角度尽可能地想会进行的操作，而不是从一个开发的角度。</li><li>先编写测试用例，再进行开发，为开发进行指导性的参考，防止遗漏某些功能。</li><li>首先由了一套完整的测试用例，便可以让代码重构更安全，因为重构只是改变内部结构，不应改变外部功能，而TDD是关注外部接口，所以在重构时，只要保证测试用例通过即可放心更改内部代码。</li><li>如果更改了某部分代码使测试用例不通过了，我们可以马上定位到刚才写的代码，修改错误。</li></ol><p>TDD把工作量前置，前期的准备工作量较大，不过后期就会很轻松。<br>关于TDD的介绍，可以看看这篇文章：<a href="http://blog.csdn.net/m13666368773/article/details/7006912" target="_blank" rel="noopener">学习TDD：TDD的好处</a></p><p><strong>BDD</strong>,全称是Behavior Driven Development，行为驱动开发。相比于TDD，BDD更加侧重设计，其要求在设计测试用例的时候对系统进行定义，倡导使用通用的语言将系统的行为描述出来，将系统设计和测试用例结合起来，从而以此为驱动进行开发工作。<br>BDD的通用语言是一种近乎自然语言的描述软件的形式。传统的开发模式中，开发人员很难从业务需求考虑问题，基于这种通用语言形式可以尽可能避免了因为理解需求不充分而带来的不必要的工作量。<br>BDD描述的行为就像一个个的故事(Story)，需求方、开发者、测试人员一起合作，分析软件的需求，然后将这些需求写成一个个的故事。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。</p><h2 id="二、mocha"><a href="#二、mocha" class="headerlink" title="二、mocha"></a>二、mocha</h2><p><a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>是具有丰富特性的 JavaScript 测试框架，可以运行在 Node.js 和浏览器中，使得异步测试更简单更有趣。Mocha 可以持续运行测试，支持灵活又准确的报告，当映射到未捕获异常时转到正确的测试示例。<br>它支持TDD/BDD等多种流行的接口，也接受多种Assertions（断言），如should.js/expect/chai/better-assert（断言框架）等，通过这些即可构建各种风格的测试用例。</p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>要开始我们的单元测试之路，首先要安装mocha。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mocha --save</span><br></pre></td></tr></table></figure></p><p>为了方便，我们选择了断言库，这里选择的是<a href="http://chaijs.com/" target="_blank" rel="noopener">chai</a>。chai是一个断言库，node本身也有个断言模块，但是功能比较弱，语法也比较贫乏。<br>chai提供了三种断言风格来分别适用于BDD和TDD。<strong>expect/should</strong> API 对应BDD风格<strong>，</strong>Assert__ API 对应TDD风格。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install chai --save</span><br></pre></td></tr></table></figure></p><h3 id="2-起步"><a href="#2-起步" class="headerlink" title="2. 起步"></a>2. 起步</h3><p>修改package.json 配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> .....</span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"mocha"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure></p><p>mocha默认执行test文件夹下的文件，所以一般测试文件都放在/test文件夹下面。并且命名为xxx.test.js<br>/api/add.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = add;</span><br></pre></td></tr></table></figure></p><p>/api/checkUser.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkUser</span>(<span class="params">userName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(userName == <span class="string">'cky'</span>)&#123;</span><br><span class="line">                resolve(&#123;<span class="attr">data</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resolve(&#123;<span class="attr">data</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">300</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = checkUser;</span><br></pre></td></tr></table></figure></p><p>/test/add.test.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mocha  = <span class="built_in">require</span>(<span class="string">'mocha'</span>);</span><br><span class="line"><span class="keyword">var</span> chai   = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">var</span> expect = chai.expect;</span><br><span class="line"><span class="keyword">var</span> add    = <span class="built_in">require</span>(<span class="string">'../api/add'</span>);</span><br><span class="line">describe(<span class="string">'api文件测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  describe(<span class="string">'add()函数测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'1+2应该等于3'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      expect(add(<span class="number">1</span>,<span class="number">2</span>)).to.be.equal(<span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>/test/userCheck.test.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mocha     = <span class="built_in">require</span>(<span class="string">'mocha'</span>);</span><br><span class="line"><span class="keyword">var</span> chai      = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">var</span> expect    = chai.expect;</span><br><span class="line"><span class="keyword">var</span> checkUser = <span class="built_in">require</span>(<span class="string">'../api/checkUser'</span>);</span><br><span class="line">describe(<span class="string">'api文件测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  describe(<span class="string">'checkUser()异步函数测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'cky返回true'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> checkUser(<span class="string">'cky'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">rs</span>)</span>&#123;</span><br><span class="line">        expect(rs.data).to.be.ok;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    it(<span class="string">'xxx返回false'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> checkUser(<span class="string">'xxx'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">rs</span>)</span>&#123;</span><br><span class="line">        expect(rs.data).to.be.not.ok;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行结果：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">▶ npm test</span><br><span class="line">&gt; mochatest@<span class="number">0.0</span>.<span class="number">1</span> test /Users/chenkeyi/cky/myDemo/test</span><br><span class="line">&gt; mocha</span><br><span class="line">  api文件测试</span><br><span class="line">    add()函数测试</span><br><span class="line">      ✓ <span class="number">1</span>+<span class="number">1</span>应该等于<span class="number">2</span></span><br><span class="line">    checkUser()异步函数测试</span><br><span class="line">      ✓ cky返回true (<span class="number">304</span>ms)</span><br><span class="line">      ✓ xxx返回false (<span class="number">303</span>ms)</span><br><span class="line">  <span class="number">3</span> passing (<span class="number">627</span>ms)</span><br></pre></td></tr></table></figure></p><p>上面这段代码，就是测试脚本，它可以独立执行。测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。<br>describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”api文件测试”），第二个参数是一个实际执行的函数。<br>it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（”1+2应该等于3”），第二个参数是一个实际执行的函数。</p><p>从<code>checkUser</code>方法测试也可以看出，是支持promise风格写法的。</p><h3 id="3-断言"><a href="#3-断言" class="headerlink" title="3. 断言"></a>3. 断言</h3><p>所谓”断言”，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。所有的测试用例（it块）都应该含有一句或多句的断言。它是编写测试用例的关键。断言功能由断言库来实现，Mocha本身不带断言库，所以必须先引入断言库。</p><p>上面也提到了断言库chai，其中有三个API expect/should/assert，<br>详细的文档可以查看<a href="http://chaijs.com/api/" target="_blank" rel="noopener">chai</a>。</p><p><code>expect(rs.data).to.be.ok;</code>这句话，就是一个断言。</p><p>要使用断言，首先要<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chai      = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">var</span> expect    = chai.expect;</span><br></pre></td></tr></table></figure></p><p>确认引入断言库，这里介绍比较常用的expect风格api。<br>我们可以这样写：<code>expect(4+5).equal(9);</code><br>Chai添加了下面的链式getter，它们不会做任何事，但是你可以将它们添加进入断言中是的句子变得啰嗦但是增加了易读性。</p><ul><li>to</li><li>be</li><li>been</li><li>is</li><li>that</li><li>and</li><li>have</li><li>with</li><li>at</li><li>of</li><li>same</li><li>a</li><li>an</li></ul><p>重写上面的方法：<br><code>expect(4+5).to.equal(5)</code><br>下面是一些使用断言例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相等或不相等</span></span><br><span class="line">expect(<span class="number">4</span> + <span class="number">5</span>).to.be.equal(<span class="number">9</span>);</span><br><span class="line">expect(<span class="number">4</span> + <span class="number">5</span>).to.be.not.equal(<span class="number">10</span>);</span><br><span class="line">expect(foo).to.be.deep.equal(&#123; <span class="attr">bar</span>: <span class="string">'baz'</span> &#125;);</span><br><span class="line"><span class="comment">// 布尔值为true</span></span><br><span class="line">expect(<span class="string">'everthing'</span>).to.be.ok;</span><br><span class="line">expect(<span class="literal">false</span>).to.not.be.ok;</span><br><span class="line"><span class="comment">// typeof</span></span><br><span class="line">expect(<span class="string">'test'</span>).to.be.a(<span class="string">'string'</span>);</span><br><span class="line">expect(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;).to.be.an(<span class="string">'object'</span>);</span><br><span class="line">expect(foo).to.be.an.instanceof(Foo);</span><br><span class="line"><span class="comment">// include</span></span><br><span class="line">expect([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).to.include(<span class="number">2</span>);</span><br><span class="line">expect(<span class="string">'foobar'</span>).to.contain(<span class="string">'foo'</span>);</span><br><span class="line">expect(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">hello</span>: <span class="string">'universe'</span> &#125;).to.include.keys(<span class="string">'foo'</span>);</span><br><span class="line"><span class="comment">// empty</span></span><br><span class="line">expect([]).to.be.empty;</span><br><span class="line">expect(<span class="string">''</span>).to.be.empty;</span><br><span class="line">expect(&#123;&#125;).to.be.empty;</span><br><span class="line"><span class="comment">// match</span></span><br><span class="line">expect(<span class="string">'foobar'</span>).to.match(<span class="regexp">/^foo/</span>);</span><br></pre></td></tr></table></figure><h3 id="4-命令行参数"><a href="#4-命令行参数" class="headerlink" title="4. 命令行参数"></a>4. 命令行参数</h3><p><code>--recursive</code> 执行/test文件夹下的所有测试文件<br><code>--reporter,-R</code> 参数用来指定测试报告的格式，默认是spec格式<br><code>--watch,-w</code> 参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。<br><code>--bail,-b</code> 参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例。这对持续集成很有用。<br><code>--grep,-g</code> 参数用于搜索测试用例的名称（即it块的第一个参数），然后只执行匹配的测试用例。<br><code>--invert,-i</code> 参数表示只运行不符合条件的测试脚本，必须与–grep参数配合使用。</p><p>这些命令行参数可以写在mocha.opts文件中配置，这样命令行输入<code>mocha</code>一个命令就可以了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mocha.opts</span></span><br><span class="line">--reporter tap</span><br><span class="line">--recursive</span><br><span class="line">--growl</span><br></pre></td></tr></table></figure></p><p>如果不是在test文件夹下存放测试文件，可以在mocha.opts配置文件中配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定运行server-tests文件夹下的文件</span></span><br><span class="line">server-tests</span><br><span class="line">--recursive</span><br></pre></td></tr></table></figure></p><h3 id="5-异步测试"><a href="#5-异步测试" class="headerlink" title="5. 异步测试"></a>5. 异步测试</h3><p>Mocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错。对于涉及异步操作的测试用例，这个时间往往是不够的，需要用-t或–timeout参数指定超时门槛。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//timeout.js</span></span><br><span class="line"><span class="keyword">var</span> mocha     = <span class="built_in">require</span>(<span class="string">'mocha'</span>);</span><br><span class="line"><span class="keyword">var</span> chai      = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">var</span> expect    = chai.expect;</span><br><span class="line"><span class="keyword">var</span> checkUser = <span class="built_in">require</span>(<span class="string">'../api/checkUser'</span>);</span><br><span class="line">describe(<span class="string">'api文件测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  describe(<span class="string">'timeout超时测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'测试应该4000毫秒后结束'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> x = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        x = <span class="literal">false</span>;</span><br><span class="line">        expect(x).to.be.not.ok;</span><br><span class="line">        done(); <span class="comment">// 通知Mocha测试结束</span></span><br><span class="line">      &#125;;</span><br><span class="line">      setTimeout(f, <span class="number">4000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在不设置 -t时，执行报错<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) api文件测试 timeout超时测试 测试应该<span class="number">4000</span>毫秒后结束:</span><br><span class="line">     <span class="built_in">Error</span>: Timeout <span class="keyword">of</span> <span class="number">2000</span>ms exceeded. For <span class="keyword">async</span> tests and hooks, ensure <span class="string">"done()"</span> is called; <span class="keyword">if</span> returning a <span class="built_in">Promise</span>, ensure it resolves.</span><br></pre></td></tr></table></figure></p><p>设置超时5000m<code>mocha -t 5000</code>后正常执行</p><p>另外，上面的测试用例里面，有一个done函数。it块执行的时候，传入一个done参数，当测试结束的时候，必须显式调用这个函数，告诉Mocha测试结束了。否则，Mocha就无法知道，测试是否结束，会一直等到超时报错。</p><p>另外，Mocha内置对Promise的支持，允许直接返回Promise，等到它的状态改变，再执行断言，而不用显式调用done，见/test/userCheck.test.js。</p><h3 id="6-测试用例的钩子"><a href="#6-测试用例的钩子" class="headerlink" title="6. 测试用例的钩子"></a>6. 测试用例的钩子</h3><p>Mocha在describe块之中，提供测试用例的四个钩子：<code>before()</code>、<code>after()</code>、<code>beforeEach()</code>和<code>afterEach()</code>。它们会在指定时间执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'hooks'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的所有测试用例之前执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">  after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的所有测试用例之后执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的每个测试用例之前执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">  afterEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的每个测试用例之后执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// test cases</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="三、参考文档"><a href="#三、参考文档" class="headerlink" title="三、参考文档"></a>三、参考文档</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">测试框架 Mocha 实例教程</a></li><li><a href="http://imweb.io/topic/5634c91109e01a534b461eaa?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">单元测试 &amp; mocha 简述</a></li><li><a href="http://blog.csdn.net/m13666368773/article/details/7006912" target="_blank" rel="noopener">学习TDD：TDD的好处</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是单元测试&quot;&gt;&lt;a href=&quot;#一、什么是单元测试&quot; class=&quot;headerlink&quot; title=&quot;一、什么是单元测试&quot;&gt;&lt;/a&gt;一、什么是单元测试&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;单元测试（unit testing），是指对软件中的最小可
      
    
    </summary>
    
    
      <category term="web前端知识" scheme="http://blog.chenkeyi.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
      <category term="node.js学习笔记" scheme="http://blog.chenkeyi.com/tags/node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2016年总结和2017年目标</title>
    <link href="http://blog.chenkeyi.com/2017/01/05/my2016and2017/"/>
    <id>http://blog.chenkeyi.com/2017/01/05/my2016and2017/</id>
    <published>2017-01-05T08:31:00.000Z</published>
    <updated>2017-10-17T20:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更新博客了，上一次的博客都要追溯到4月份了，真是惭愧。<br>今天工作需求测试阶段基本快告一段落，而且今天正好部门前端开了个总结会，想想2016年过去了，趁着现在有时间，也该来写一下2016年的总结和规划规划2017年的目标了。<br><a id="more"></a></p><h2 id="2016回顾"><a href="#2016回顾" class="headerlink" title="2016回顾"></a>2016回顾</h2><p>在2016年开年的时候，我也写过一篇2016年的目标，现在来回顾一下吧。</p><blockquote><p>1.无特殊情况，每天晚上睡前做半个小时以上运动。<br>2.无特殊情况，每天晚上睡前看半个小时以上书，看完书单上的书。</p></blockquote><p>这两条目标，果然对我来说还是太难了- - 睡前运动间歇性坚持了2个月，7月正式工作后也坚持了一段时间，但是自从开始养猫之后，每天晚上回家的大部分时间花在了撸猫上。运动什么的也荒废了。看书也是，虽然2016年看了几本书，但是每天睡前看书还是没有坚持。</p><blockquote><p>拿驾照 (已完成)<br>完成毕业设计期间学习，达成学习目标（部分完成）<br>存钱毕业旅行 (已完成)<br>存钱买mac pro (已完成)</p></blockquote><p>驾照拿的很轻松啊，不过没车也没啥用- -。<br>毕业设计期间用node+express+leancloud写了一个社团管理系统，对于node写web系统算是有了一个经验，对于之后工作也有了帮助。<br>毕业旅行去了三亚，也算是达成了我一个内陆人士的看海成就。<br>mac pro已买，在9月份生日的时候买给自己当生日礼物，对于写代码的幸福感还是有所提高的 2333。</p><p>综上，除了1.2条以外，基本还是完成了（懒癌没救-。-）。</p><p>另外，2016年还有一些其他收获。<br>运气很好，抱养了一只喵，每天回家开门的时候，就能听见它喵喵的叫，跑到门口来迎接我（我认为的），有时候手一伸过去，它就歪着倒下去，肚子朝上卖萌了等抚摸了。现在天冷了，它会趴在你枕头旁边望着你，一直望到你把被子拉开让它进来和你一起睡。真是每天都会被它萌到。</p><p>7月份正式开始猪八戒工作了，参与了好几个比较大的公司级项目，虽然有时候加班比较多，但是完成了项目的时候还是很有成就感的。<br>也用node.js作为controller层调soa服务的形式，开发了2个公司比较重要的功能，虽然是新人，但是能够独立开发这么大的模块，感觉责任和成就感并存。</p><p>喜欢上了狼人杀，结识了一群杀友，有时候下班就会组织杀一把。作为公司狼人杀小分队老司机的一员，感觉这个组织非常有爱。</p><h2 id="2017年目标"><a href="#2017年目标" class="headerlink" title="2017年目标"></a>2017年目标</h2><p>定一下2017年的目标吧，毕竟2017年的鸡血还是要打一打的。</p><ol><li>深入学习，积累15篇以上博客，n篇笔记。</li><li>今年有年假了，也办了护照，是该达成一波出国成就了。</li><li>每周抽个3.5个小时看书吧，写读书笔记。吸取去年的经验，不平均到每天了。</li><li>存钱，4w以上，不能再月光了。</li><li>每个月买一个自己购物愿望清单上的东西。（啊，这条其实和4有点冲突，但是为了提升自己的幸福感，存钱好难，嘤嘤嘤。）</li><li>待定</li></ol><p>最后放萌猫一只。<br><img src="http://ww2.sinaimg.cn/mw690/680ee472gw1fawjr222kbj20qo0zk114.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没更新博客了，上一次的博客都要追溯到4月份了，真是惭愧。&lt;br&gt;今天工作需求测试阶段基本快告一段落，而且今天正好部门前端开了个总结会，想想2016年过去了，趁着现在有时间，也该来写一下2016年的总结和规划规划2017年的目标了。&lt;br&gt;
    
    </summary>
    
    
      <category term="生活琐事" scheme="http://blog.chenkeyi.com/tags/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用pm2+github将node项目一键部署到远程服务器</title>
    <link href="http://blog.chenkeyi.com/2016/07/25/pm2-node-service/"/>
    <id>http://blog.chenkeyi.com/2016/07/25/pm2-node-service/</id>
    <published>2016-07-25T06:06:50.000Z</published>
    <updated>2017-10-17T20:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>每次在本地跑Node项目自娱自乐总不是很爽，一直想把自己的node项目部署到服务器上。但是我对于后端和运维知识我还是处于小白阶段，今天研究了一下午，总算是成功把自己的node项目搞了上去，又学到了新姿势。本文将介绍怎么从零开始，获得服务器，并将node项目通过github+pm2部署到远程服务器。<br><a id="more"></a></p><h3 id="服务器环境搭建"><a href="#服务器环境搭建" class="headerlink" title="服务器环境搭建"></a>服务器环境搭建</h3><h4 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h4><p>(已有服务器的可以跳过此步骤)。<br>我是用的腾讯的云服务器，因为腾讯云还是比较良心，云服务器开放了免费体验功能（不知道之后会不会关闭），很适合我们这种新手先试用再购买。通过这个【<a href="https://www.qcloud.com/act/try?t=cvm" target="_blank" rel="noopener">链接</a>】申请了免费试用。申请成功后，就会收到该改主机的信息。我选择的1核CPU、1GB内存,系统为CentOS 7.2 64位。也许在你看到这篇文章的时候，服务器也过期了- -</p><hr><p>现在我换成了国外的vps 便宜好用还能翻墙 嚯嚯嚯。</p><h4 id="登录云服务器"><a href="#登录云服务器" class="headerlink" title="登录云服务器"></a>登录云服务器</h4><p>在本机终端输入以下命令即可连接上云服务器，然后需要输入给你的初始密码。<br><code>ssh root@服务器公网ip</code></p><h4 id="安装相关文件"><a href="#安装相关文件" class="headerlink" title="安装相关文件"></a>安装相关文件</h4><p>更新yum（云服务器自带的包管理工具）：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">update</span> -<span class="built_in">y</span></span><br></pre></td></tr></table></figure></p><p>更新完毕后，安装Node.js：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> nodejs -y</span><br></pre></td></tr></table></figure></p><p>安装Npm：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> npm -y</span><br></pre></td></tr></table></figure></p><p>安装pm2：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> pm2 -g</span><br></pre></td></tr></table></figure></p><p>分别执行<code>node -v</code>、<code>npm -v</code>、<code>pm2 -v</code>查看是否安装成功，如果没有安装成功，前面加上<code>sudo</code>命令重试</p><h4 id="服务器端创建新用户（可选）"><a href="#服务器端创建新用户（可选）" class="headerlink" title="服务器端创建新用户（可选）"></a>服务器端创建新用户（可选）</h4><p>为服务器安全起见，创建用户(用户名：yourName)：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">useradd yourName</span></span><br></pre></td></tr></table></figure></p><p>设置密码：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">passwd yourName</span></span><br></pre></td></tr></table></figure></p><p>添加sudo权限：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">usermod -aG wheel yourName</span></span><br></pre></td></tr></table></figure></p><h4 id="服务器端关闭root用户的ssh访问-可选-："><a href="#服务器端关闭root用户的ssh访问-可选-：" class="headerlink" title="服务器端关闭root用户的ssh访问(可选)："></a>服务器端关闭root用户的ssh访问(可选)：</h4><p>为服务器安全起见，关闭root账户的远程访问。<br>打开配置文件：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>ssh<span class="regexp">/sshd_config</span></span><br></pre></td></tr></table></figure></p><p>按下<code>i</code>,切换vi为输入状态<br>找到如下设置，删除前面的<code>#</code>，并修改yes为no：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">PermitRootLogin</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure></p><p>按下<code>esc</code>，切换vi为命令状态，然后输入<code>:wq</code>回车保存退出<br>保存文件后，重启sshd服务：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">service sshd restart</span></span><br></pre></td></tr></table></figure></p><p>退出root账户，并使用新创建用户访问。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">yourName</span>@服务器公网<span class="keyword">ip</span></span><br></pre></td></tr></table></figure></p><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><p>本文的操作环境是<br>本地：Mac OSX<br>远端服务器：腾讯云ECS（1核CPU、1GB内存），IP：119.29.101.229，系统为CentOS 7.2 64位<br>采用的技术：Node.js + Express.js<br>Github：账户名：cky917<br>以下命令全部带入我的账号，<strong>自己使用时记得替换为自己的账号</strong>。<br>本文对于Git基本操作和node也不做详细讲解。</p><h3 id="本地创建node项目"><a href="#本地创建node项目" class="headerlink" title="本地创建node项目"></a>本地创建node项目</h3><p>具体如何创建，本文不详细讨论。假设已经建立好一个名为pm2Demo的项目。</p><h3 id="github建立链接"><a href="#github建立链接" class="headerlink" title="github建立链接"></a>github建立链接</h3><p>登录云服务器，安装git，生成ssh-key。然后将云服务器的ssh-key加到自己的github中。<br>在本地执行同样的操作。</p><p>进入本地项目目录./pm2Demo，将本地项目与github远程仓库建立连接。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin https://github.com/cky917/pm2Demo.git</span></span><br><span class="line"><span class="bash">git push -u origin master</span></span><br></pre></td></tr></table></figure></p><h3 id="pm2部署"><a href="#pm2部署" class="headerlink" title="pm2部署"></a>pm2部署</h3><p>pm2的介绍可以看看这篇<a href="https://segmentfault.com/a/1190000002539204" target="_blank" rel="noopener">文章</a><br>详细的部署步骤也可以看<a href="http://pm2.keymetrics.io/docs/usage/deployment/#considerations" target="_blank" rel="noopener">官方配置文档</a></p><p>本地安装pm2之后执行<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p<span class="name">m2</span> ecosystem</span><br></pre></td></tr></table></figure></p><p>会生成一个ecosystem.config.js(版本原因，也可能是ecosystem.json)文件，打开该文件进行配置。修改<code>script</code>配置为node项目启动文件。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">apps :</span> [</span><br><span class="line">    <span class="comment">//由于我们此次只有一个项目,我们只配置一个app</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">name      :</span> <span class="string">"pm2Demo"</span>,</span><br><span class="line">      <span class="string">script    :</span> <span class="string">"./bin/www"</span>,</span><br></pre></td></tr></table></figure></p><p>其余关于app部分的配置，可见<a href="http://pm2.keymetrics.io/docs/usage/application-declaration/" target="_blank" rel="noopener">官方文档</a>;</p><p>再配置部署部分：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy </span>: &#123;</span><br><span class="line">    <span class="attribute">production </span>: &#123;<span class="comment">//生产环境部署配置</span></span><br><span class="line">      <span class="attribute">user </span>: <span class="string">"cky"</span>,<span class="comment">//登录远程服务器的用户名</span></span><br><span class="line">      <span class="attribute">host </span>: <span class="string">"119.29.101.229"</span>,<span class="comment">//远程服务器的IP或hostname，此处可以是数组同步部署多个服务器</span></span><br><span class="line">      <span class="attribute">ref  </span>: <span class="string">"origin/master"</span>,<span class="comment">//远端名称及分支名</span></span><br><span class="line">      <span class="attribute">repo </span>: <span class="string">"git@github.com:cky917/pm2Demo.git"</span>,<span class="comment">//git仓库地址</span></span><br><span class="line">      <span class="attribute">path </span>: <span class="string">"/home/cky/www/production/pm2Demo"</span>,<span class="comment">//远程服务器部署目录，需要填写user具备写入权限的目录</span></span><br><span class="line">      <span class="string">"post-deploy"</span> : <span class="string">"npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production"</span>,<span class="comment">//部署后需要执行的命令</span></span><br><span class="line">      <span class="string">"env"</span>  : &#123;</span><br><span class="line">        <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attribute">dev </span>: &#123;<span class="comment">//开发环境部署配置</span></span><br><span class="line">      <span class="attribute">user </span>: <span class="string">"cky"</span>,</span><br><span class="line">      <span class="attribute">host </span>: <span class="string">"119.29.101.229"</span>,</span><br><span class="line">      <span class="attribute">ref  </span>: <span class="string">"origin/dev"</span>,</span><br><span class="line">      <span class="attribute">repo </span>: <span class="string">"git@github.com:cky917/pm2Demo.git"</span>,</span><br><span class="line">      <span class="attribute">path </span>: <span class="string">"/home/cky/www/dev/pm2Demo"</span>,</span><br><span class="line">      <span class="string">"post-deploy"</span> : <span class="string">"npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env dev"</span>,</span><br><span class="line">      <span class="attribute">env  </span>: &#123;</span><br><span class="line">        <span class="attribute">NODE_ENV</span>: <span class="string">"dev"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码我们部署了2个环境，当然你得有对应的分支。<br>改好后，我们将ecosystem.config.js代码提交到远程github仓库去，<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line"><span class="bash">git commit -m <span class="string">"update ecosystem"</span></span></span><br><span class="line"><span class="bash">git push</span></span><br></pre></td></tr></table></figure></p><p>在云服务器端执行以下命令，将<code>http://github.com</code>加入known_hosts：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keyscan -t rsa github.com <span class="meta">&gt;&gt; </span>~<span class="regexp">/.ssh/known</span>_hosts</span><br></pre></td></tr></table></figure></p><p>因为pm2的部署是通过ssh进行的，因此需要开通本地到远程服务器的无密码登录，同样，在Mac下，通过ssh-keygen生成RSA公钥，并拷贝到远程服务器：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~<span class="regexp">/.ssh/id</span>_rsa.pub cky<span class="variable">@119</span>.<span class="number">29.101</span>.<span class="number">229</span><span class="symbol">:/home/cky/</span>.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p><p>在本地执行命令把文件目录初始化到服务器端：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy &lt;configuration_file&gt; &lt;environment&gt; <span class="built_in">setup</span></span><br><span class="line"><span class="comment">//比如：</span></span><br><span class="line">pm2 deploy ecosystem.<span class="built_in">config</span>.js production <span class="built_in">setup</span></span><br></pre></td></tr></table></figure></p><p>如果没有问题，会输出<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line">  ○ setup complete</span><br><span class="line">--&gt; Success</span><br></pre></td></tr></table></figure></p><h3 id="一键部署代码到服务器"><a href="#一键部署代码到服务器" class="headerlink" title="一键部署代码到服务器"></a>一键部署代码到服务器</h3><p>在本地./pm2Demo项目下，输入以下命令部署代码到服务器<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem<span class="selector-class">.config</span><span class="selector-class">.js</span> production</span><br></pre></td></tr></table></figure></p><p>会看到输出以下信息，表示部署成功：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">Use</span> <span class="string">`pm2 show &lt;id|name&gt;`</span> <span class="keyword">to</span> <span class="keyword">get</span> more details about an app</span><br><span class="line">  ○ hook <span class="keyword">test</span></span><br><span class="line">  ○ successfully deployed origin/<span class="keyword">master</span></span><br><span class="line"><span class="comment">--&gt; Success</span></span><br></pre></td></tr></table></figure></p><p>现在，你的代码已经被部署，而且项目也启动了。<br>pm2部署命令列表如下：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy <span class="symbol">&lt;configuration_file&gt;</span> <span class="symbol">&lt;environment&gt;</span> <span class="symbol">&lt;command&gt;</span></span><br><span class="line">  Command<span class="variable">s:</span></span><br><span class="line">    setup                run remote setup commands</span><br><span class="line">    <span class="keyword">update</span>               <span class="keyword">update</span> deploy <span class="keyword">to</span> the latest release</span><br><span class="line">    revert [n]           revert <span class="keyword">to</span> [n]<span class="keyword">th</span> <span class="keyword">last</span> deployment <span class="built_in">or</span> <span class="number">1</span></span><br><span class="line">    curr[ent]            output current release commit</span><br><span class="line">    <span class="keyword">prev</span>[ious]           output <span class="keyword">previous</span> release commit</span><br><span class="line">    exec|run <span class="symbol">&lt;cmd&gt;</span>       <span class="keyword">execute</span> the given <span class="symbol">&lt;cmd&gt;</span></span><br><span class="line">    <span class="keyword">list</span>                 <span class="keyword">list</span> <span class="keyword">previous</span> deploy commits</span><br><span class="line">    [ref]                deploy <span class="keyword">to</span> [ref], the <span class="string">"ref"</span> setting, <span class="built_in">or</span> latest <span class="keyword">tag</span></span><br></pre></td></tr></table></figure></p><p>在这里我发现了一个问题，就是如果我的分支代码更新了，我执行部署更新命令拉取的提交记录还是初始化时的提交记录，我必须删掉服务器上的文件夹，重新执行初始化和部署的操作，不知道是本来就这样还是哪里出了问题，暂时没找到原因- -。</p><p>部署成功后，在远程服务器端输入<code>netstat -antp</code>查看端口情况。可以看到3000端口已经可以访问。<br>输入<a href="http://119.29.101.229:3000/" target="_blank" rel="noopener">http://119.29.101.229:3000/</a> 就能访问到项目了（我把我简陋的毕设项目搞了上去 - -,管理员账户root,密码123 有兴趣可以登录试一下）</p><h3 id="设置开机自动启动"><a href="#设置开机自动启动" class="headerlink" title="设置开机自动启动"></a>设置开机自动启动</h3><p>可以通过pm2 startup来实现开机自启动。细节可<a href="http://pm2.keymetrics.io/docs/usage/startup/" target="_blank" rel="noopener">参考</a>。大致流程如下</p><ol><li>通过<code>pm2 save</code>保存当前进程状态。</li><li>通过<code>pm2 startup [platform]</code>生成开机自启动的命令。（记得查看控制台输出）</li><li>将步骤2生成的命令，粘贴到控制台进行，搞定。</li></ol><h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><p>通过nginx反向代理，可以让服务器上某端口，指向指定域名的80端口，这样访问时就不需要加端口号了。<br>详细见<a href="http://pm2.keymetrics.io/docs/tutorials/pm2-nginx-production-setup" target="_blank" rel="noopener">官方文档</a><br>首先我们要在云服务器上安装nginx:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> nginx</span><br></pre></td></tr></table></figure></p><p>安装成功后，启动nginx服务：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx <span class="literal">start</span></span><br></pre></td></tr></table></figure></p><p>使用命令<code>nginx -t</code>查找nginx配置文件，并使用vi命令修改该配置文件。<br>我的配置如下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log <span class="string">/var/log/nginx/error.log</span>;</span><br><span class="line">pid <span class="string">/run/nginx.pid</span>;</span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span></span><br><span class="line">include <span class="string">/usr/share/nginx/modules/</span>*<span class="string">.conf</span>;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">  upstream my_nodejs_upstream &#123;</span><br><span class="line">    server 127.0.0.1<span class="function">:3000</span>;</span><br><span class="line">    keepalive 64;</span><br><span class="line">  &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name   www.chenkeyi.com;<span class="string">//</span>你的域名</span><br><span class="line">    access_log  <span class="string">/var/log/nginx/bysj.log</span>;</span><br><span class="line">    error_log <span class="string">/var/log/nginx/bysj.error.log</span>;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_<span class="keyword">set</span>_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_<span class="keyword">set</span>_header Host $http_host;</span><br><span class="line">        proxy_<span class="keyword">set</span>_header X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line">        proxy_http_<span class="keyword">version</span> 1.1;</span><br><span class="line">        proxy_pass http:<span class="string">//my_nodejs_upstream/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改完后<code>service nginx restart</code>重启nginx</p><h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><p>这个在腾讯云和阿里云等都提供解析域名服务。</p><p>配置成功：<a href="http://bysj.chenkeyi.com" target="_blank" rel="noopener">bysj.chenkeyi.com</a>可以访问。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次在本地跑Node项目自娱自乐总不是很爽，一直想把自己的node项目部署到服务器上。但是我对于后端和运维知识我还是处于小白阶段，今天研究了一下午，总算是成功把自己的node项目搞了上去，又学到了新姿势。本文将介绍怎么从零开始，获得服务器，并将node项目通过github+pm2部署到远程服务器。&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端知识" scheme="http://blog.chenkeyi.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
      <category term="node.js学习笔记" scheme="http://blog.chenkeyi.com/tags/node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于jQuery的Deferred对象介绍（译）</title>
    <link href="http://blog.chenkeyi.com/2016/03/25/introduction-jquery-deferred-objects/"/>
    <id>http://blog.chenkeyi.com/2016/03/25/introduction-jquery-deferred-objects/</id>
    <published>2016-03-25T09:28:50.000Z</published>
    <updated>2017-10-17T17:27:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>(趁着毕设要求，翻译了一篇文章，顺便放上来。英文不好翻了2天才翻完，/(ㄒoㄒ)/~~如有错误欢迎指正。)<br>原文链接:<a href="http://www.sitepoint.com/introduction-jquery-deferred-objects/" target="_blank" rel="noopener">An Introduction to jQuery’s Deferred Objects</a></p><p>长久以来，javascript的开发者习惯于使用回调函数去执行某些任务。一个常见的例子就是当某些事件比如<code>click</code>或者<code>keypress</code>执行的时候，通过<code>addEventListener()</code>添加回调函数。这样做的好处是，回调函数很简单，让工作能够很方便地完成，不幸的是，当你的网页变得越来越复杂而且你需要执行许多异步请求时，它们变得越来越难以处理。</p><p>ECMAScript2015引进了一个原生的方法去处理这种情况：promise。如果你不知道什么是promise，你可以读一读这篇文章<a href="http://www.sitepoint.com/overview-javascript-promises/" target="_blank" rel="noopener">An Overview of JavaScript Promises</a>。jQuery推出了它自己风格的promise，就是 <strong>Deferred对象</strong> 。它在promise被引入ECMAScript之前几年就被引入了jqurey，在这篇文章里，我会讨论一下什么是<code>Deferred</code>对象，还有它解决了什么问题。</p><h2 id="一个简单的历史介绍"><a href="#一个简单的历史介绍" class="headerlink" title="一个简单的历史介绍"></a>一个简单的历史介绍</h2><p><code>Deferred</code>对象在jQuery1.5版本被引入，它能让回调函数成为一个回调队列，继而被链式调用，它还能处理同步或者异步函数的成功或者失败状态。从此以后，它成为了一个课题被讨论和研究，也有一些批评的声音，伴随着批评和它也发生了许多改变。这里有两篇对它的批判性的文章：<a href="https://blog.domenic.me/youre-missing-the-point-of-promises/" target="_blank" rel="noopener">You’re Missing the Point of Promises</a>和<a href="https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/" target="_blank" rel="noopener">JavaScript Promises and why jQuery implementation is broken</a>。</p><p>连同<a href="http://api.jquery.com/Types/#Promise" target="_blank" rel="noopener">Promise对象</a>,Deferred代表了jQuery对于Promises的实现。在jQuery1.X版本和2.x版本里，deferred对象依附于<a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">the CommonJS Promises/A proposal</a>，这个提案被作为<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+ proposal</a>的基础，而原生的promises就是在此基础上建立的。正如前面所提到的，jQuery没有依附于 Promises/A+的原因是它在这之前就已经产生了。</p><p>因为jQuery是一个先驱者，还由于向后兼容问题，在原生javascript里使用promise与在jQuery1.x、2.x版本里使用都有一些区别。而且，由于jQuery遵循了一个不同的提案，这个框架和其他实现了promises的框架比如<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">the Q library</a>是互不兼容的。</p><p>在即将到来的 <strong>jQuery 3</strong> 版本里，改进了与原生的Promises(在ECMAScript 2015被实现的)的兼容性。虽然有些主要的方法（then())还是由于向后兼容的原因和原生的Promises有些差别，但是其使用习惯已经越来越接近规范标准了。</p><p></p><h2 id="callbackJquery">jQuery中的回调</h2><br>为了理解为什么你需要使用<code>Deferred</code>对象，让我们先讨论一个例子。当你使用jQuery的时候，一定经常使用它的ajax方法去处理异步请求。为了理解这个例子，让我们假设你正在开发一个网页并且正在向Github的API发送Ajax请求。你的目标是收到用户的仓库列表，找到最近更新过的仓库，找到第一个名为’README.md’的文件，最终接收到这个文件的内容。基于以上的描述，你每一个Ajax请求可能都会是在上一个步骤完成的时候发送，换句话说，这些请求必须在一个队列中执行。<p></p><p>让我们把这些描述转换为代码（请注意我没有使用真的Github的API），我们得到以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> username = <span class="string">'testuser'</span>;</span><br><span class="line"><span class="keyword">var</span> fileToSearch = <span class="string">'README.md'</span>;</span><br><span class="line"></span><br><span class="line">$.getJSON(<span class="string">'https://api.github.com/user/'</span> + username + <span class="string">'/repositories'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">repositories</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> lastUpdatedRepository = repositories[<span class="number">0</span>].name;</span><br><span class="line"></span><br><span class="line">  $.getJSON(<span class="string">'https://api.github.com/user/'</span> + username + <span class="string">'/repository/'</span> + lastUpdatedRepository + <span class="string">'/files'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> README = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (files[i].name.indexOf(fileToSearch) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        README = files[i].path;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $.getJSON(<span class="string">'https://api.github.com/user/'</span> + username + <span class="string">'/repository/'</span> + lastUpdatedRepository + <span class="string">'/file/'</span> + README + <span class="string">'/content'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'The content of the file is: '</span> + content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>正如你在这个例子里看到的，为了达到目的，我们必须嵌套执行Ajax请求。这让我们的代码变得可读性比较差。在我们必须嵌套使用大量的回调，或者需要一个独立的回调函数需要和另一个函数以同步的方式执行时，我们通常称这种情况为“回调地狱”。</p><p>为了让这种情况变好一点，你可以将我上面写的匿名函数提取出来命名。然而，这样改变也没啥帮助，我们仍然发现我们身处于回调地狱中。下面，我们就走进<code>Deferred</code>对象和<code>Promise</code>对象吧。</p><h2 id="Deferred对象和Promise对象"><a href="#Deferred对象和Promise对象" class="headerlink" title="Deferred对象和Promise对象"></a>Deferred对象和Promise对象</h2><p>Deferred对象可以在执行异步操作的时候使用，比如Ajax请求和动画。在jQuery里，<code>Promise</code>对象创建于<code>Deferred</code>对象或者<code>jQuery</code>对象。它拥有<code>Deferred</code>对象下的方法，如：<code>always()</code>,<code>done()</code>,<code>fail()</code>,<code>state()</code>,和<code>then()</code>。我会在下面介绍这些方法。</p><p>如果你是来自原生javascript世界的，你可能会对这两个对象的存在感到很困惑。为什么我们要有两个对象（<code>Deferred</code>和<code>Promise</code>），而原生Javascript只有一个（<code>Promise</code>)？为了解释他们的不同和他们的用例，我在我的书中对他们进行了类比<a href="https://www.manning.com/books/jquery-in-action-third-edition" target="_blank" rel="noopener">jQuery in Action, Third Edition</a>。</p><p>一个使用<code>Deferred</code>对象的典型情况是，如果你正在编写一个函数去处理异步操作，并且可能会返回一个值（返回一个错误或者不返回值也行）。在这种情况下，你的函数是值的“生产者”，而且你希望阻止用户去改变<code>Deferred</code>的状态。当你是这个函数的消费者时，你就要使用<code>promise</code>。</p><p>为了阐明这个观点，让我们假设你希望实现一个基于promise的 <code>timeout()</code>方法(下面是这个<a href="#creatingapromisebasedsettimeoutfunction">例子的代码</a>。你负责写这个函数，但是必须等到获得一个时间的数字（在这个等待的情况下没有值返回），这让你成为一个“生产者”。你这个函数的“消费者”不需要关心去resolve它或者reject它，“消费者”只需要能够在Deferred执行完成后、失败后、或者进程中添加函数。另外，你想要确保你的“消费者”不能resolve或reject这个Deferred对象。为了达到这个目标，你需要在你创建的<code>timeoout()</code>函数中返回<code>Deferred</code>的<code>promise</code>对象，而不是<code>Deferred</code>对象本身。这样做之后，你能确保除了你的<code>timeout()</code>函数以外，没有人能够调用<code>resolve()</code>和<code>reject()</code>方法。</p><p>你可以在<a href="http://stackoverflow.com/questions/17308172/deferred-versus-promise" target="_blank" rel="noopener">StackOverflow question</a>了解更多关于jQuery的Deferred对象和Promise对象的区别。</p><p>现在你知道这些对象是什么了，让我们来了解一下这些方法的作用。</p><h2 id="Deferred对象的方法"><a href="#Deferred对象的方法" class="headerlink" title="Deferred对象的方法"></a>Deferred对象的方法</h2><p><code>Deferred</code>对象非常灵活，提供了很多方法满足你的需求。它可以被创建为<code>jQuery.Deferred()</code>，方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deferred = jQuery.Deferred();</span><br></pre></td></tr></table></figure></p><p>或者，你也可以用<code>$</code>创建：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deferred = $.Deferred();</span><br></pre></td></tr></table></figure></p><p>一旦创建，这个<code>Deferred</code>对象就暴露了一些方法，除了那些不赞成使用的和被移除的方法，它暴露的方法有：</p><ul><li><code>always(callbacks[, callbacks, ..., callbacks]):</code> 在无论Deferred对象resolved还是rejected的时候都会执行。</li><li><code>done(callbacks[, callbacks, ..., callbacks]):</code> 当Deferred对象resolved的时候执行。</li><li><code>fail(callbacks[, callbacks, ..., callbacks]):</code> 当Deferred对象rejected的时候执行。</li><li><code>notify([argument, ..., argument]):</code> 根据给定的 args参数 调用Deferred对象上进行中的回调 （progressCallbacks）。</li><li><code>notifyWith(context[, argument, ..., argument]):</code> 根据给定的上下文（context）和args递延调用Deferred对象上进行中的回调（progressCallbacks ）。</li><li><code>progress(callbacks[, callbacks, ..., callbacks])</code>:当Deferred（延迟）对象生成进度通知时，调用添加处理程序。</li><li><code>promise([target]):</code> Return a Deferred‘s Promise object.</li><li><code>reject([argument, ..., argument]):</code> 拒绝Deferred（延迟）对象，并根据给定的args参数调用任何失败回调函数（failCallbacks）。</li><li><code>rejectWith(context[, argument, ..., argument]):</code>拒绝Deferred（延迟）对象，并根据给定的 context和args参数调用任何失败回调函数（failCallbacks）。</li><li><code>resolve([argument, ..., argument]):</code> 解决Deferred（延迟）对象，并根据给定的args参数调用任何完成回调函数（doneCallbacks）。</li><li><code>resolveWith(context[, argument, ..., argument]):</code> 解决Deferred（延迟）对象，并根据给定的 context和args参数调用任何完成回调函数（doneCallbacks）。</li><li><code>state():</code>确定一个Deferred（延迟）对象的当前状态。</li><li><code>then(resolvedCallback[, rejectedCallback[, progressCallback]]):</code> 当Deferred（延迟）对象解决，拒绝或仍在进行中时，调用添加处理程序。</li></ul><p>通过这些方法的描述，让我们能够更明显地了解到jQuery文档中的术语和ECMAScript标准里的区别。在ECMAScript标准里，一个promise对象被称作resolved是在他完成或者被拒绝的时候。然而，在jQuery文档里，resolved描述的只是在ECMAScript中的完成状态。</p><p>Deferred提供了大量的方法，在本篇文章中不能全部介绍到。不过，在下面的内容中，我会展示一些<code>Deferred</code>对象和<code>Promise</code>对象的使用的例子。首先，我来会用Deferred对象重写一下在<a href="#callbackJquery">jQuery中的回调</a>中的那段代码，然后我会把“生产者和消费者”的比喻再解释一下。</p><h2 id="用Deferred对象完成Ajax请求队列"><a href="#用Deferred对象完成Ajax请求队列" class="headerlink" title="用Deferred对象完成Ajax请求队列"></a>用Deferred对象完成Ajax请求队列</h2><p>在这个章节我会展示怎么用Deferred对象和它的一些方法去提高<a href="#callbackJquery">jQuery中的回调</a>里的那段代码的可读性，在开始探索之前，我们必须要明白我们需要用到哪些方法。</p><p>根据我们的需求和上面列出的方法列表，很明显我们可以用<code>done()</code>或者<code>then()</code>方法去管理成功的状态。由于你们大多数可能已经习惯于使用Javascript的<code>Promise</code>对象，在这个例子中，我会选择使用<code>then()</code>方法。在这两个方法最重要的一个区别是<code>then()</code>方法能够<br>将接收到的值作为参数传递给其他在后面调用的<code>then()</code>、<code>done()</code>、<code>fail()</code>或<code>progress()</code>方法。</p><p>最后的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> username = <span class="string">'testuser'</span>;</span><br><span class="line"><span class="keyword">var</span> fileToSearch = <span class="string">'README.md'</span>;</span><br><span class="line"></span><br><span class="line">$.getJSON(<span class="string">'https://api.github.com/user/'</span> + username + <span class="string">'/repositories'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">repositories</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repositories[<span class="number">0</span>].name;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">lastUpdatedRepository</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $.getJSON(<span class="string">'https://api.github.com/user/'</span> + username + <span class="string">'/repository/'</span> + lastUpdatedRepository + <span class="string">'/files'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">files</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> README = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (files[i].name.indexOf(fileToSearch) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                README = files[i].path;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> README;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">README</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $.getJSON(<span class="string">'https://api.github.com/user/'</span> + username + <span class="string">'/repository/'</span> + lastUpdatedRepository + <span class="string">'/file/'</span> + README + <span class="string">'/content'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(content);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>正如你看到的，这段代码比之前的可读性好了很多，因为我们能把每一个步骤拆开看，它们都同一级，没有嵌套。</p><p></p><h2 id="creatingapromisebasedsettimeoutfunction">创造一个基于Promise的setTimeout函数</h2><br>你也许知道，<code>setTimeout()</code>能在指定的时间后执行回调函数。它的两个元素（回调函数和时间）都应该作为参数被提供。让我们假设你想要1秒后在控制台打印一段信息。使用<code>setTimeout()</code>，你可以达到这个目的：<p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I waited for 1 second!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>正如你所见，第一个参数是一个想要被执行的函数，第二个是多少需要等待的毫秒数。这个函数一向很有用，但是如果你想用通过<code>Deferred</code>队列实现呢？</p><p>在下面我会告诉你怎么用jQuery提供的<code>Promise</code>对象完成一个基于promise的<code>setTimeout()</code>函数。</p><p>最后的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new Deferred object</span></span><br><span class="line">    <span class="keyword">var</span> deferred = $.Deferred();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resolve the Deferred after the amount of time specified by milliseconds</span></span><br><span class="line">    setTimeout(deferred.resolve, milliseconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the Deferred's Promise object</span></span><br><span class="line">    <span class="keyword">return</span> deferred.promise();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">1000</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I waited for 1 second!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>我定义了一个<code>timeout()</code>函数，包裹了javaScript的原生<code>setTimeout()</code>方法。在<code>timeout()</code>方法里我创建了一个新的<code>Deferred</code>对象去管理异步任务，在<code>milliseconds</code>时间后<code>deferred</code>对象被设置为resolve状态。在这种情况下，<code>timeout()</code>函数是这个值的生产者，所以它创建了<code>Deferred</code>对象还返回了<code>Promise</code>对象。通过这样，我能确保这个函数的调用者（消费者）不能够resolve或者reject这个<code>Deferred</code>对象。事实上，这个调用者只能添加函数去执行，和使用<code>done()</code>,<code>faile()</code>等方法。</p><h2 id="jQuery-1-x-2-x-与-jQuery-3的区别"><a href="#jQuery-1-x-2-x-与-jQuery-3的区别" class="headerlink" title="jQuery 1.x/2.x 与 jQuery 3的区别"></a>jQuery 1.x/2.x 与 jQuery 3的区别</h2><p>在第一个例子里，我们创建了一段代码去查找一个名为”README.md”的文件，但是我们没有处理这个文件没有被找到的情况。这种情况应该被称作失败的情况，当失败发送时，我们可能需要去打断这个队列直接结束。如果这样做的话它会很自然的抛出一个异常，取到这个异常后被fail()这个方法执行，就像你在js里面用的catch()方法一样。</p><p>遵循Promises/A和Promises/A+的库（比如jQuery3.x），抛出的异常是被转换为rejection然后调用错误回调函数，比如<code>fail()</code>，被捕获的异常会作为参数传递进去。</p><p>在jQuery1.x和2.x版本中，未被捕获的异常会终止程序的执行，这些版本下允许抛出的异常冒泡，通常是达到<code>window.onerror</code>。如果没有定义函数去处理这个异常，这个异常信息会在控制台显示，而且会中断代码执行。</p><p>为了更好的理解他们不同的地方，让我们看看这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deferred = $.Deferred();</span><br><span class="line">deferred</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'An error message'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'First success function'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'First failure function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Second success function'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Second failure function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">deferred.resolve();</span><br></pre></td></tr></table></figure></p><p>在jQuery3.x版本中，会打印信息”First failure function”和”Second success function”到控制台。原因就和我上面说的一样，一个抛出的异常会被转变为<code>rejection</code>，然后错误处理函数会在这时候被调用。而且，一旦异常被管理到（在这个例子中传递给了第二个<code>then()</code>），接下来的成功回调函数会被调用（本例中的第三个<code>then()</code>）。</p><p>在jQuery1.x和2.x版本中，只有第一个函数（抛出异常的函数）会执行，然后你会看到在控制台输出了”Uncaught Error: An error message”。</p><p><strong>jQuery 1.x/2.x</strong></p><iframe class="" id="" data-url="http://jsbin.com/nozege/embed?js,console" src="http://jsbin.com/nozege/embed?js,console" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;"></iframe><br><strong>jQuery3</strong><br><iframe class="" id="" data-url="http://jsbin.com/kifazi/embed?js,console" src="http://jsbin.com/kifazi/embed?js,console" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;"></iframe><p>为了进一步提高它与ECMAScript 2015的兼容性，jQuery3也给<code>Deferred</code>和<code>Promise</code>对象添加了一个<code>catch()</code>方法。它是被定义来处理<code>Deferred</code>对象<code>rejected</code>或者 它的<code>Promise</code>对象处于rejected的情况：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deferred.catch(rejectedCallback)</span><br></pre></td></tr></table></figure></p><p>这个方法只是<code>then(null,rejectedCallback)</code>的简写形式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章里，我向你介绍了jQuery对于promises的实现方式。Promises让你不用很麻烦地让异步函数并行起来，也不用在回调函数里嵌套回调函数再嵌套回调函数……</p><p>除此之外，我也介绍了jQuery3怎么提升它和原生promise的兼容性。尽管老版本的jQuery和ECMAScript 2015的还有比较明显的不同，<code>Deferred</code>对象仍然是一个令人难以置信的强大的工具。作为一个专业的开发者，随着项目难度的增加，你会发现你会经常用到它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(趁着毕设要求，翻译了一篇文章，顺便放上来。英文不好翻了2天才翻完，/(ㄒoㄒ)/~~如有错误欢迎指正。)&lt;br&gt;原文链接:&lt;a href=&quot;http://www.sitepoint.com/introduction-jquery-deferred-objects/&quot; ta
      
    
    </summary>
    
    
      <category term="web前端知识" scheme="http://blog.chenkeyi.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>利用Fiddler进行前端调试</title>
    <link href="http://blog.chenkeyi.com/2016/02/24/%E5%88%A9%E7%94%A8fiddler%E8%BF%9B%E8%A1%8C%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    <id>http://blog.chenkeyi.com/2016/02/24/利用fiddler进行前端调试/</id>
    <published>2016-02-24T01:34:50.000Z</published>
    <updated>2017-10-17T17:27:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚get了一个很方便前端调试的新技能，特别在已上线网页上修复bug的时候调试很实用，比如我在本地改了一个test1.js文件想要测试效果，但是又不想很麻烦地推到测试环境，就可以用这个工具把线上的test1.js文件请求到自己的本地test1.js文件，这样你的代码可以直接进行调试了。</p><p>首先我们要用的工具是<a href="http://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a>，这是一个强大的工具，在这里我就不详细介绍了，有兴趣的可以去了解一下<a href="http://www.imooc.com/learn/37" target="_blank" rel="noopener">慕课网：Fiddler工具的使用</a>。</p><p>我们直接进入正题：利用Fiddler进行前端调试。</p><p>打开软件，我们看到的是这样的界面：<br><img src="https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/1.png" alt="软件界面"><br>左边那些就是你的网络请求列表，右边是一些工具面板。</p><p>我们以coolmogu.com为例，打开本网站，出现以下请求：<br><img src="https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/2.png" alt=""></p><p>假如我们要修改index.js，在本地我们有一个index.js，具体步骤如下图</p><p><img src="https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/4.png" alt=""></p><p>这样再刷新页面，实际coolmogu.com以后请求的index.js就是请求的你本地的Index.js了。假如我index.js里加了一行<code>alert(&quot;cky&quot;)</code>, <img src="https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/3.png" alt=""> 看看效果：<br><img src="https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/5.png" alt=""></p><p>很简单吧，还可以用同样的方法进行css文件调试等~</p><p><img src="https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/6.jpg" alt=""></p><p>（本来之前用的图床，结果图床挂了- -，今天来修复图片。以后图片还是放在自己的github上吧）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近刚get了一个很方便前端调试的新技能，特别在已上线网页上修复bug的时候调试很实用，比如我在本地改了一个test1.js文件想要测试效果，但是又不想很麻烦地推到测试环境，就可以用这个工具把线上的test1.js文件请求到自己的本地test1.js文件，这样你的代码可以直
      
    
    </summary>
    
    
      <category term="web前端知识" scheme="http://blog.chenkeyi.com/tags/web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
