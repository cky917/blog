{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0},{"_id":"themes/mabao-theme/source/js/menu.js","path":"js/menu.js","modified":0},{"_id":"themes/mabao-theme/source/js/jquery.fitvids.js","path":"js/jquery.fitvids.js","modified":0},{"_id":"themes/mabao-theme/source/js/index.js","path":"js/index.js","modified":0},{"_id":"themes/mabao-theme/source/img/mogu.png","path":"img/mogu.png","modified":0},{"_id":"themes/mabao-theme/source/img/logo.svg","path":"img/logo.svg","modified":0},{"_id":"themes/mabao-theme/source/img/logo.png","path":"img/logo.png","modified":0},{"_id":"themes/mabao-theme/source/img/img-bg.jpg","path":"img/img-bg.jpg","modified":0},{"_id":"themes/mabao-theme/source/img/icons-demo-nav.svg","path":"img/icons-demo-nav.svg","modified":0},{"_id":"themes/mabao-theme/source/img/icons-demo-nav.png","path":"img/icons-demo-nav.png","modified":0},{"_id":"themes/mabao-theme/source/img/6.jpg","path":"img/6.jpg","modified":0},{"_id":"themes/mabao-theme/source/img/5.png","path":"img/5.png","modified":0},{"_id":"themes/mabao-theme/source/img/4.png","path":"img/4.png","modified":0},{"_id":"themes/mabao-theme/source/img/3.png","path":"img/3.png","modified":0},{"_id":"themes/mabao-theme/source/img/2.png","path":"img/2.png","modified":0},{"_id":"themes/mabao-theme/source/img/1.png","path":"img/1.png","modified":0},{"_id":"themes/mabao-theme/source/fonts/icons.woff","path":"fonts/icons.woff","modified":0},{"_id":"themes/mabao-theme/source/fonts/icons.ttf","path":"fonts/icons.ttf","modified":0},{"_id":"themes/mabao-theme/source/fonts/icons.svg","path":"fonts/icons.svg","modified":0},{"_id":"themes/mabao-theme/source/fonts/icons.eot","path":"fonts/icons.eot","modified":0},{"_id":"themes/mabao-theme/source/favicon.ico","path":"favicon.ico","modified":0},{"_id":"themes/mabao-theme/source/css/style.css","path":"css/style.css","modified":0},{"_id":"themes/mabao-theme/source/css/screen.css","path":"css/screen.css","modified":0},{"_id":"themes/mabao-theme/source/css/normalize.css","path":"css/normalize.css","modified":0}],"Cache":[{"_id":"source/CNAME","shasum":"341a1bd24be6da36f01d2e5438abcb47b7b7d5b5","modified":1447251446634},{"_id":"source/_posts/2016年计划（目标）.md","shasum":"04195686a83de55391938d8d42d4e41c60646925","modified":1467616161797},{"_id":"source/_posts/ChineseInputMethods.md","shasum":"c1db9619ea13b6fd254288c85beee851555f37e8","modified":1467616161797},{"_id":"source/_posts/JavaScript实践.md","shasum":"54e0ff8c333e218002e558e1b8d6147a81a2e153","modified":1452088153255},{"_id":"source/_posts/Less is more.md","shasum":"4d55aafbde10630b1dbbf26b0e04264cf06ca424","modified":1452088178618},{"_id":"source/_posts/introduction-jquery-deferred-objects.md","shasum":"2c0adae0d38cb738bb227bf9ba105b6e74d4653e","modified":1467616161797},{"_id":"source/_posts/nodeJsStudy1.md","shasum":"18bc5593ad4eab6145b03f82c867d2458d9c75b4","modified":1452088207446},{"_id":"source/_posts/jQueryPerformanceOptimization.md","shasum":"22c158b80d983f5bd3a9f730f7c39c647d5cc91c","modified":1452088164429},{"_id":"source/_posts/nodeJsStudy10.md","shasum":"3963f900b1acec973cd7741a788f55bfcb4fc2ff","modified":1467616232576},{"_id":"source/_posts/nodeJsStudy2.md","shasum":"b49d2c0ef0b4697f0bc4bfe27660fa0c054f32e4","modified":1452088214748},{"_id":"source/_posts/nodeJsStudy3.md","shasum":"b7b94c22b1a600262f5c9d37bc93ad53d868559c","modified":1452088225378},{"_id":"source/_posts/nodeJsStudy11.md","shasum":"725436c2f604e447e79f70086c847ae64b14368e","modified":1467616161797},{"_id":"source/_posts/nodeJsStudy4.md","shasum":"6da9982a9808dd45a4cb1b41bf8b5b1aa27e6c86","modified":1452088234805},{"_id":"source/_posts/nodeJsStudy5.md","shasum":"b156daec48acd7c1da7f07a4a394011e30aeaaee","modified":1452088253602},{"_id":"source/_posts/nodeJsStudy6.md","shasum":"19c5f2f2f699fb13aa7819215adfb4945b868550","modified":1452088261283},{"_id":"source/_posts/nodeJsStudy8.md","shasum":"e2bccef26b872f1c2c4f8db81fbabb91d0d9e381","modified":1452088280300},{"_id":"source/_posts/nodeJsStudy7.md","shasum":"13e9032d6f2b81b104585fa1a001e38cd7ed3e55","modified":1452088269482},{"_id":"source/_posts/nodeJsStudy9.md","shasum":"73cea48f86672a9ac6ff8d3f9720b36ee7ba8af2","modified":1452092407836},{"_id":"source/_posts/不是只有“if else”.md","shasum":"9682dd50c0a7da10fa5f5cffad2f34b7e2fa57a6","modified":1452087977571},{"_id":"source/_posts/利用fiddler进行前端调试.md","shasum":"e2d1eea61f9adf9ccef008c6f1e4d652bfd81d7e","modified":1467616161797},{"_id":"source/_posts/各种居中布局的css实现方法.md","shasum":"9f28a0b9d56639899bc674e23f86fb92678010b6","modified":1452088025313},{"_id":"source/_posts/前端知识收集.md","shasum":"9d482405dd9a43e049f88db5eb7e230daeeebc33","modified":1467616161797},{"_id":"source/_posts/好玩的cookie.md","shasum":"0ccf048c4e4140f32c10f853711d209524930d6e","modified":1452081950405},{"_id":"source/_posts/学习日报 2015-09-11.md","shasum":"97570fcc20a94730942d4ce5c5ed79659c094d8f","modified":1447251446637},{"_id":"source/_posts/学习日报 2015-09-08.md","shasum":"eaa13594baccf5adeb567374bc787785f1859e0f","modified":1447251446636},{"_id":"source/_posts/学习日报 2015-09-09.md","shasum":"2fbd4f5b308af6c229548c235121f80ab81b016c","modified":1447251446637},{"_id":"source/_posts/学习日报 2015-09-10.md","shasum":"770651e92f750f5183a6fabff03be7097c82ca4d","modified":1447251446637},{"_id":"source/_posts/学习日报 2015-09-15.md","shasum":"99d4fcfddb6b581bcb9e4d84a75f59dad2ebb134","modified":1447251446638},{"_id":"source/_posts/学习日报 2015-09-16——2015-09-22.md","shasum":"83716c3283a36d91ff097eb902c68e0ff88d825f","modified":1452088054637},{"_id":"source/_posts/学习日报2015-09-23——2015-09-25.md","shasum":"715d5ad532229d8e1004d396f95874d2f746aed3","modified":1452088070639},{"_id":"source/_posts/数组的常用方法.md","shasum":"95e74eaa1240591f51892973c0527fc7128f2460","modified":1452088095893},{"_id":"source/_posts/浏览器的重绘与重排.md","shasum":"ac19b2df1e9a72398d3670dc0085cfbec2083ec8","modified":1452088402019},{"_id":"source/about-me/index.md","shasum":"0ed2842cf5439c2f27f4798a3ed2447cd4512eff","modified":1447251446641},{"_id":"source/_posts/用js原生实现Ajax的get和post.md","shasum":"d1a38d56615a6a2f69d9edeb9d537aebcadac322","modified":1452081950407},{"_id":"source/_posts/请问，你也是一只蘑菇吗.md","shasum":"51a84b614aa37b9ce5ad96efad456324adae0f44","modified":1452088136134},{"_id":"source/_posts/请问您今天要来点兔子吗.md","shasum":"11ab956d27e43f9542d46b0bd410246cc3dd95c2","modified":1452088123806},{"_id":"themes/mabao-theme/LICENSE","shasum":"bd19923410e7f582ade9def0118a910d4d53a696","modified":1447251446642},{"_id":"themes/mabao-theme/layout/_widget/archive.ejs","shasum":"2f48941c453b8d061d39233706b3c62bea912c2c","modified":1447251446644},{"_id":"themes/mabao-theme/README.md","shasum":"b429d5668b3fe10c4af37ccc070ea87cbc53a3f4","modified":1447251446642},{"_id":"themes/mabao-theme/layout/_widget/category.ejs","shasum":"48db9568717bb620de791bd74befe913854d7849","modified":1447251446644},{"_id":"themes/mabao-theme/layout/_widget/recent_posts.ejs","shasum":"3257bfe1c3ebe7d63437ea5d069d2c83a5379ad3","modified":1447251446645},{"_id":"themes/mabao-theme/layout/_widget/tag.ejs","shasum":"e6df099e2556edf4f3cd8be8a35cb649d2b1686a","modified":1447251446645},{"_id":"themes/mabao-theme/layout/_widget/tagcloud.ejs","shasum":"3351e14e53ab36953ba1cc3d85859941387ac734","modified":1447251446645},{"_id":"themes/mabao-theme/layout/archive.ejs","shasum":"1704d02907207de6d4b6207bd9debf926740d82d","modified":1447251446646},{"_id":"themes/mabao-theme/_config.yml","shasum":"77e9af000d8e896ad3664556790ba12a85b38e90","modified":1447251446643},{"_id":"themes/mabao-theme/layout/casper/header.ejs","shasum":"92cf7805e8a344875138c182a2125e0554becc0a","modified":1447251446647},{"_id":"themes/mabao-theme/layout/casper/after_all.ejs","shasum":"f823e66a4e45feafa8126797880141fb576e96a2","modified":1447251446646},{"_id":"themes/mabao-theme/layout/casper/post/author.ejs","shasum":"c0094f46608102d3627ec1887906133ef5559a75","modified":1447251446649},{"_id":"themes/mabao-theme/layout/casper/head.ejs","shasum":"a27c431c195206efd1d705f68c2888249373394f","modified":1447251446647},{"_id":"themes/mabao-theme/layout/casper/post/meta.ejs","shasum":"e949c35e52b5fb4ec8fc31af6a8c8eb9e68c0583","modified":1467619359227},{"_id":"themes/mabao-theme/layout/casper/post/navigation.ejs","shasum":"ba135f3602af2f6f0c4dfdc47a14493a7041bbc0","modified":1447251446650},{"_id":"themes/mabao-theme/layout/casper/footer.ejs","shasum":"904507db6aab2697a4bef585225fa4d60e7cfa1d","modified":1467616161797},{"_id":"themes/mabao-theme/layout/casper/post.ejs","shasum":"61c1581e10ae74ef1bdae84128785040babfdb0d","modified":1467616161797},{"_id":"themes/mabao-theme/layout/casper/sidebar.ejs","shasum":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1447251446651},{"_id":"themes/mabao-theme/layout/category.ejs","shasum":"1704d02907207de6d4b6207bd9debf926740d82d","modified":1447251446651},{"_id":"themes/mabao-theme/layout/index.ejs","shasum":"13fd753d2b2e82ada96902b13a3e0b6dbafcd3c5","modified":1447251446651},{"_id":"themes/mabao-theme/layout/casper/index.ejs","shasum":"7e17010206d3eb4d54060da656dd24fadc7041f9","modified":1447251446648},{"_id":"themes/mabao-theme/layout/page.ejs","shasum":"12b1d7c22468b220bb8c2c53f75081f9a5443e0c","modified":1447251446652},{"_id":"themes/mabao-theme/layout/post.ejs","shasum":"12b1d7c22468b220bb8c2c53f75081f9a5443e0c","modified":1447251446652},{"_id":"themes/mabao-theme/layout/tag.ejs","shasum":"8abfd6cc58a403da7fcb38431d986cb8cc543401","modified":1447251446653},{"_id":"themes/mabao-theme/layout/casper/post/share.ejs","shasum":"6f6a4d2df6961dfec3a3ac29033d16533c17c373","modified":1447251446650},{"_id":"themes/mabao-theme/source/css/normalize.css","shasum":"c2da50e7ef0a8c3a9c9b2cb25d4a3e546fd65d39","modified":1447251446653},{"_id":"themes/mabao-theme/layout/layout.ejs","shasum":"d0dffba0bdce376397b6b9b984741c90c6817c37","modified":1467616161797},{"_id":"themes/mabao-theme/source/css/screen.css","shasum":"8c90f4d7f00d81200e626ca9f7ef5d02cceeeddf","modified":1452081950411},{"_id":"themes/mabao-theme/source/css/style.css","shasum":"8a54815dde8fb47ec1db6256cb3a0a462848cbd2","modified":1447251446654},{"_id":"themes/mabao-theme/source/favicon.ico","shasum":"b5e3d38751ecdf6b22037db5224e43e9186d78de","modified":1447251446655},{"_id":"themes/mabao-theme/source/fonts/icons.eot","shasum":"e307fc2d61d13bbc3aafc9abd75e727cbebadee1","modified":1447251446656},{"_id":"themes/mabao-theme/source/fonts/icons.ttf","shasum":"2169592997f694ffa05b1d4c23d5a1abf35d3203","modified":1447251446658},{"_id":"themes/mabao-theme/source/fonts/icons.woff","shasum":"af538de6ac19d5da1cada203c7451ce32f5daceb","modified":1447251446659},{"_id":"themes/mabao-theme/source/img/3.png","shasum":"9c903cd0002e1edd4d46c866ce74b536dd07d164","modified":1467616161813},{"_id":"themes/mabao-theme/source/img/2.png","shasum":"20c48a04db04b142e99e5b5f34a3cdebae6eb40e","modified":1467616161813},{"_id":"themes/mabao-theme/source/img/icons-demo-nav.png","shasum":"4508247661f7883fed94386acf61f9b05e324dce","modified":1447251446660},{"_id":"themes/mabao-theme/source/img/5.png","shasum":"a25863789e27cad0a8dfe66daaed697c0c7ce1f7","modified":1467616161813},{"_id":"themes/mabao-theme/source/img/6.jpg","shasum":"988c4da6a326aea83263534e14e63ff32c9c1981","modified":1467616161813},{"_id":"themes/mabao-theme/source/img/img-bg.jpg","shasum":"4cf609b11d89b38d2a641a8810dcf6a2bf78a716","modified":1447251446667},{"_id":"themes/mabao-theme/source/js/index.js","shasum":"b8171a0313c2b65d55a8a710d3ae2996fe67e915","modified":1447251446673},{"_id":"themes/mabao-theme/source/img/logo.png","shasum":"158c1cc2dc9d72b5782078d4114adb30649eb9d0","modified":1447251446668},{"_id":"themes/mabao-theme/source/img/logo.svg","shasum":"0d1fecda8d43df31367e254f43fc53f53093f4c8","modified":1447251446672},{"_id":"themes/mabao-theme/source/img/mogu.png","shasum":"74606326921ad39398269cd98f6bd9cba471af8f","modified":1447251446672},{"_id":"themes/mabao-theme/source/js/jquery.fitvids.js","shasum":"0bee3d274aff5ecbbe1700cde4486254a44e30a5","modified":1447251446673},{"_id":"themes/mabao-theme/layout/casper/post/comments.ejs","shasum":"c7d67cbfa73b4cdeeaa3f008e2ca378f02b38b16","modified":1447251446649},{"_id":"themes/mabao-theme/source/js/menu.js","shasum":"c429f19136ebb7e7fe76001f6589bc5d16d39c1d","modified":1447251446674},{"_id":"themes/mabao-theme/source/fonts/icons.svg","shasum":"12bf62bc3a7ba0fa5315a72fbf0bb9b99766a60c","modified":1447251446657},{"_id":"themes/mabao-theme/source/img/1.png","shasum":"579ec39681f74bcfaa89889d97cd00a3a8a262d0","modified":1467616161797},{"_id":"themes/mabao-theme/source/img/4.png","shasum":"bbf39670aaa4abf6cd1e3bdb2abca8b03362b845","modified":1467616161813},{"_id":"themes/mabao-theme/theme-p1.png","shasum":"9711fd87f5f814527de230c2f1a51d0fe635d4ce","modified":1447251446678},{"_id":"themes/mabao-theme/source/img/icons-demo-nav.svg","shasum":"5b6fef00f9386c436238b45b9990d6c87d6a0924","modified":1447251446666},{"_id":"themes/mabao-theme/theme.gif","shasum":"14df48dfcda94912b8e0d0dd046410d8a30dc51c","modified":1447251446688},{"_id":"public/about-me/index.html","modified":1467619423972,"shasum":"532ec3bfad19c9593b777b3f6d1b21f78bd14a50"},{"_id":"public/2016/03/25/introduction-jquery-deferred-objects/index.html","modified":1467619423986,"shasum":"e607470b088a6c81aa4e897fec7a8cbc6d704f9a"},{"_id":"public/2016/02/24/利用fiddler进行前端调试/index.html","modified":1467619423998,"shasum":"6c4457012a1b712387d3aec1ca3f220f7e1af1bc"},{"_id":"public/2016/02/17/2016年计划（目标）/index.html","modified":1467619424004,"shasum":"fbdaedf982a7aa5671c50beabd5f45075231c004"},{"_id":"public/2016/01/27/ChineseInputMethods/index.html","modified":1467619424017,"shasum":"3479763f83779164fda401c0acc05e53e6bac451"},{"_id":"public/2016/01/21/前端知识收集/index.html","modified":1467619424023,"shasum":"a2cf33d4a47173d79a23daab39d795ea9387ed69"},{"_id":"public/2016/01/07/nodeJsStudy11/index.html","modified":1467619424030,"shasum":"e3c1221e70c6f4367515894a74ce0a38fe549491"},{"_id":"public/2016/01/06/nodeJsStudy10/index.html","modified":1467619424041,"shasum":"935de326c2cad650ade68b427745f33226343848"},{"_id":"public/2016/01/06/nodeJsStudy9/index.html","modified":1467619424048,"shasum":"279beffb3db26c15f48d20beb20c740b2225360f"},{"_id":"public/2016/01/06/nodeJsStudy8/index.html","modified":1467619424052,"shasum":"86468e438ccc43e557fc74d0ede6a3850f9dfb5c"},{"_id":"public/2016/01/06/nodeJsStudy7/index.html","modified":1467619424057,"shasum":"8f7286d06c663b99b7c6d4e00f5db4991b409ea9"},{"_id":"public/2016/01/04/nodeJsStudy6/index.html","modified":1467619424064,"shasum":"adbb55dce08be995690055ec8e74ec514b236862"},{"_id":"public/2016/01/04/nodeJsStudy5/index.html","modified":1467619424069,"shasum":"a8c98dfd56da7e2f26528e7776c9bf97a26f559d"},{"_id":"public/2015/12/11/nodeJsStudy4/index.html","modified":1467619424074,"shasum":"2a333ebba6437fe86ac5e8ce4d3731c8ae036ba2"},{"_id":"public/2015/12/03/nodeJsStudy3/index.html","modified":1467619424088,"shasum":"3c682f5ce425dd5d21050961df0a023874235997"},{"_id":"public/2015/12/02/nodeJsStudy2/index.html","modified":1467619424094,"shasum":"f1f7eb0e82721e5268014a896358645d199fb5cb"},{"_id":"public/2015/12/01/nodeJsStudy1/index.html","modified":1467619424101,"shasum":"0436ff34eede6b08820a235299d180e7fae6537b"},{"_id":"public/2015/11/25/jQueryPerformanceOptimization/index.html","modified":1467619424109,"shasum":"84c981876a95d8728ea3f74b405a884ab5b69cc0"},{"_id":"public/2015/11/20/各种居中布局的css实现方法/index.html","modified":1467619424118,"shasum":"d3079e639b81c92d81f26bc4279a07e5d853c185"},{"_id":"public/2015/11/20/不是只有“if else”/index.html","modified":1467619424125,"shasum":"9f5abc317dd1a8634b828ac97d154457f43db363"},{"_id":"public/2015/11/20/数组的常用方法/index.html","modified":1467619424131,"shasum":"38731a6bd836f42bd7a1496bbc155b7b642f808c"},{"_id":"public/2015/11/09/Less is more/index.html","modified":1467619424139,"shasum":"f9e3627f853fd6170f6e70b1428fa18ce64e4dd5"},{"_id":"public/2015/11/06/学习日报2015-09-23——2015-09-25/index.html","modified":1467619424146,"shasum":"7df22b2124f5f3c214ce1c5b0190f88353c9cce1"},{"_id":"public/2015/11/06/请问您今天要来点兔子吗/index.html","modified":1467619424153,"shasum":"6cbfff18ccd11dcf83c0e973483259327836946e"},{"_id":"public/2015/10/28/请问，你也是一只蘑菇吗/index.html","modified":1467619424157,"shasum":"e22fae183993649f6ce7811df56617e513683deb"},{"_id":"public/2015/09/30/学习日报 2015-09-16——2015-09-22/index.html","modified":1467619424161,"shasum":"42dfcc0f4f6617e955d0e9bc9cf78f9106efb9ab"},{"_id":"public/2015/09/30/JavaScript实践/index.html","modified":1467619424166,"shasum":"0449e2ec8ae904b92ba28b3eedcc9e2f80cd632f"},{"_id":"public/2015/09/23/浏览器的重绘与重排/index.html","modified":1467619424172,"shasum":"34c75ba5dc47543cb592573372f7254223142294"},{"_id":"public/2015/09/14/学习日报 2015-09-15/index.html","modified":1467619424177,"shasum":"fdfe6ae7f8e7bdd9e566a133cb2ce17ffc38378b"},{"_id":"public/2015/09/11/学习日报 2015-09-11/index.html","modified":1467619424185,"shasum":"e2cff2d3d7934ad09ed36aa4a83c5a60c55add13"},{"_id":"public/2015/09/10/学习日报 2015-09-10/index.html","modified":1467619424190,"shasum":"3e592bef02ff8b1efeaa74d12a73050efca1abfc"},{"_id":"public/2015/09/09/学习日报 2015-09-09/index.html","modified":1467619424194,"shasum":"0ddf6c40769a2fb81d7ab6e9d9fd518ec319ae3f"},{"_id":"public/2015/09/08/学习日报 2015-09-08/index.html","modified":1467619424200,"shasum":"561786e7c6b18631e8c141b897021b28523bd704"},{"_id":"public/2015/08/18/用js原生实现Ajax的get和post/index.html","modified":1467619424206,"shasum":"dd385fa48223a2d45707e3d156834829ffadc7e1"},{"_id":"public/2015/07/25/好玩的cookie/index.html","modified":1467619424210,"shasum":"9d7739d6a983a2e01709d8da249d6c9827924758"},{"_id":"public/archives/index.html","modified":1467619424224,"shasum":"b0a788b8e0e7f3f7db2367f135f5d75d1c209472"},{"_id":"public/archives/page/2/index.html","modified":1467619424240,"shasum":"3a4986569ef1fafa223480e4b53e8d723f2fddd0"},{"_id":"public/archives/page/3/index.html","modified":1467619424254,"shasum":"9dc02c295d69b439206663077626dcb1a357392b"},{"_id":"public/archives/page/4/index.html","modified":1467619424263,"shasum":"2070181189ee6deb8ba04e0171999782760b8fcb"},{"_id":"public/archives/2015/index.html","modified":1467619424273,"shasum":"d6e6ce29a25fddd3b9c61195f4821fb16e59fce1"},{"_id":"public/archives/2015/page/2/index.html","modified":1467619424283,"shasum":"f64780c5edac98cb66ee8afc1e840248188143b9"},{"_id":"public/archives/2015/page/3/index.html","modified":1467619424289,"shasum":"6ba90694a0dc51c019c2374e5974b1a38e518ff1"},{"_id":"public/archives/2015/07/index.html","modified":1467619424299,"shasum":"05358548faf7d2ada8f881d8999fa3319655ff64"},{"_id":"public/archives/2015/08/index.html","modified":1467619424307,"shasum":"cdbcda71c0a0ffcf397152e63053517405d5b4a6"},{"_id":"public/archives/2015/09/index.html","modified":1467619424318,"shasum":"466245f20923a3c40609f18b73912b7cfd2e19ae"},{"_id":"public/archives/2015/10/index.html","modified":1467619424326,"shasum":"05036f468f559e3c36afd9c04473e7377c03f999"},{"_id":"public/archives/2015/11/index.html","modified":1467619424336,"shasum":"680802c30cea9a3b45c148f7d256a3a02868c62b"},{"_id":"public/archives/2015/12/index.html","modified":1467619424345,"shasum":"8998210f6773e4d3066554a08b86846bb9485975"},{"_id":"public/archives/2016/index.html","modified":1467619424376,"shasum":"d077bbe5ac37340a7660f2c165964cb40f6ad25e"},{"_id":"public/archives/2016/page/2/index.html","modified":1467619424385,"shasum":"408c2a6d6325d0a834414f4deb9851ffba0b6e5e"},{"_id":"public/archives/2016/01/index.html","modified":1467619424399,"shasum":"4e9a5c82ab1bac5ccc6435c54bf9db76c311ff23"},{"_id":"public/archives/2016/02/index.html","modified":1467619424411,"shasum":"dd2a06c58a9218ae0931cbdee92c1c0f6f4df236"},{"_id":"public/archives/2016/03/index.html","modified":1467619424419,"shasum":"0c0823c88af13cf1c95180894541518a75eb2126"},{"_id":"public/index.html","modified":1467619424426,"shasum":"6baa529bd14494b928c3d8058a332c91e38406be"},{"_id":"public/page/2/index.html","modified":1467619424434,"shasum":"762f2931c700bfda68f1fa768cc731f6f20c2cb3"},{"_id":"public/page/3/index.html","modified":1467619424440,"shasum":"0222a103972572990e7ec76fe9743c8b034cba73"},{"_id":"public/page/4/index.html","modified":1467619424445,"shasum":"bd57a7294a1c9f2acee5d24d0f341933788a2c93"},{"_id":"public/tags/矫情不是病/index.html","modified":1467619424455,"shasum":"cc59e7eed6805797c34a3ac8b343b89f429f7704"},{"_id":"public/tags/二次元/index.html","modified":1467619424461,"shasum":"12635d9d252310e10d4cbbbcc665e331f7019f86"},{"_id":"public/tags/Javascript学习笔记/index.html","modified":1467619424470,"shasum":"9ce6c132332d09f9b857fbbec7fa8917f3085c2c"},{"_id":"public/tags/web前端知识/index.html","modified":1467619424479,"shasum":"33f35c0a67996b3b00e0c0b5e136546c8fe2c94f"},{"_id":"public/tags/学习日报/index.html","modified":1467619424492,"shasum":"a22bf684c5d700d2afd8997a1059833490d33b1c"},{"_id":"public/tags/css学习心得/index.html","modified":1467619424501,"shasum":"9bebe8a729151078817d62cf572e4f118be78c2c"},{"_id":"public/tags/node-js学习笔记/index.html","modified":1467619424509,"shasum":"4ac2ea4bfb4894efd1aa26299d92c52fe6ed1f7c"},{"_id":"public/tags/node-js学习笔记/page/2/index.html","modified":1467619424515,"shasum":"818a993237445213835c62492f47761b401fa853"},{"_id":"public/tags/生活琐事/index.html","modified":1467619424521,"shasum":"f83993d227a6a0fe1b0f85c60fa38762f40e3c85"}],"Category":[],"Data":[],"Page":[{"title":"关于我","_content":"![照骗](https://avatars2.githubusercontent.com/u/12221080?v=3&s=230)\n    \n\n陈柯伊 93年的重庆妹子 2016年大学毕业\n喜欢互联网 喜欢前端\n用了一个大学的时间完成了从2b文青到（伪）技术宅（女）的转变\n现于重庆猪八戒网络有限公司实习\n\n业余爱好：动漫 LOL  \n微博：@陈柯伊伊伊伊_\n邮箱：chen_keyi@foxmail.com","source":"about-me/index.md","raw":"title: 关于我\n---\n![照骗](https://avatars2.githubusercontent.com/u/12221080?v=3&s=230)\n    \n\n陈柯伊 93年的重庆妹子 2016年大学毕业\n喜欢互联网 喜欢前端\n用了一个大学的时间完成了从2b文青到（伪）技术宅（女）的转变\n现于重庆猪八戒网络有限公司实习\n\n业余爱好：动漫 LOL  \n微博：@陈柯伊伊伊伊_\n邮箱：chen_keyi@foxmail.com","date":"2015-11-11T14:17:26.641Z","updated":"2015-11-11T14:17:26.641Z","path":"about-me/index.html","comments":1,"layout":"page","_id":"ciq7qdvvn0000s8rk3xh18uhk"}],"Post":[{"title":"请问，你也是一只蘑菇吗","date":"2015-10-28T02:17:50.000Z","_content":"\n我博客名字的来源。\n<!--more-->\n\n以前听过一个冷笑话\n>在一家精神病医院里，有个新来的大夫，收治了一个病人。那个病人很奇怪，既不疯疯癫癫打人，也不大呼小叫吵吵嚷嚷，他只是每天很安静很安静的，撑着一把黑伞，蹲在墙边，不吃不喝的。\n大夫决定对病人进行治疗。可是他用尽了所有的办法，一点成效都没有，那个病人始终都不理睬他，对他的任何话和行为都没有反应。\n最后，那个大夫也去找了把黑伞来，和病人一样撑着伞蹲在墙角，默默的，丝毫不打扰他。\n终于，太阳落山的时候，那个病人缓缓的转头，看了大夫一眼，然后他笑了，轻声的说：‘请问，你也是一只蘑菇吗？’”\n\n\n后来看见这个故事的续集\n>那个大夫就这样每天陪着病人，撑着伞蹲在墙角，默默的，丝毫不打扰他。时间久了，病人渐渐认同大夫和自己一样，也是一只蘑菇。\n有一天，大夫忽然站起来，伸手伸脚活络身体，围着桌子跑圈。病人感到很奇怪，疑惑的问他：‘你不是一只蘑菇吗？’\n“我是啊！”大夫回答说。\n“那你怎么可以走来走去？！”病人更惊讶了。\n“蘑菇当然可以走来走去！”大夫理直气壮。\n病人觉得有道理，后来，他也开始站起来走来走去。\n又有一天，大夫端来很香的饭菜，坐在病人身边大吃大喝。病人感到很奇怪，疑惑的问他：“难道，你不是一只蘑菇吗？”\n“我当然是一只蘑菇！”大夫回答说。\n“那你怎么可以吃东西呢？！”病人更惊讶了。\n“谁说蘑菇不可以吃东西？！蘑菇当然可以吃东西！”大夫理直气壮的，咬了一口鸡腿。\n病人觉得很有道理，于是他也开始吃东西。\n后来这个病人就康复了，很快他出院了，像一个正常人一样的生活，虽然在他的心底，他依旧认为自己是一只蘑菇。\n\n每个人都有蘑菇的一面，在自己的世界，向阴生长。不过，不需担心，因为总能遇到一个人走到你身边，蹲下来。\n而这时你只用问一句：“请问，你也是一只蘑菇吗？” 就好了。\n\n","source":"_posts/请问，你也是一只蘑菇吗.md","raw":"title: 请问，你也是一只蘑菇吗\ndate: 2015-10-28 10:17:50\ntag: 矫情不是病\n---\n\n我博客名字的来源。\n<!--more-->\n\n以前听过一个冷笑话\n>在一家精神病医院里，有个新来的大夫，收治了一个病人。那个病人很奇怪，既不疯疯癫癫打人，也不大呼小叫吵吵嚷嚷，他只是每天很安静很安静的，撑着一把黑伞，蹲在墙边，不吃不喝的。\n大夫决定对病人进行治疗。可是他用尽了所有的办法，一点成效都没有，那个病人始终都不理睬他，对他的任何话和行为都没有反应。\n最后，那个大夫也去找了把黑伞来，和病人一样撑着伞蹲在墙角，默默的，丝毫不打扰他。\n终于，太阳落山的时候，那个病人缓缓的转头，看了大夫一眼，然后他笑了，轻声的说：‘请问，你也是一只蘑菇吗？’”\n\n\n后来看见这个故事的续集\n>那个大夫就这样每天陪着病人，撑着伞蹲在墙角，默默的，丝毫不打扰他。时间久了，病人渐渐认同大夫和自己一样，也是一只蘑菇。\n有一天，大夫忽然站起来，伸手伸脚活络身体，围着桌子跑圈。病人感到很奇怪，疑惑的问他：‘你不是一只蘑菇吗？’\n“我是啊！”大夫回答说。\n“那你怎么可以走来走去？！”病人更惊讶了。\n“蘑菇当然可以走来走去！”大夫理直气壮。\n病人觉得有道理，后来，他也开始站起来走来走去。\n又有一天，大夫端来很香的饭菜，坐在病人身边大吃大喝。病人感到很奇怪，疑惑的问他：“难道，你不是一只蘑菇吗？”\n“我当然是一只蘑菇！”大夫回答说。\n“那你怎么可以吃东西呢？！”病人更惊讶了。\n“谁说蘑菇不可以吃东西？！蘑菇当然可以吃东西！”大夫理直气壮的，咬了一口鸡腿。\n病人觉得很有道理，于是他也开始吃东西。\n后来这个病人就康复了，很快他出院了，像一个正常人一样的生活，虽然在他的心底，他依旧认为自己是一只蘑菇。\n\n每个人都有蘑菇的一面，在自己的世界，向阴生长。不过，不需担心，因为总能遇到一个人走到你身边，蹲下来。\n而这时你只用问一句：“请问，你也是一只蘑菇吗？” 就好了。\n\n","slug":"请问，你也是一只蘑菇吗","published":1,"updated":"2016-01-06T13:48:56.134Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvwj0001s8rkrtdwe1cq"},{"title":"请问您今天要来点兔子吗","date":"2015-11-06T02:17:50.000Z","_content":"再次推一下萌出血的点兔第二季ED（循环洗脑版！！）\n顺便 \nmarkdown 嵌入视频测试~ \n\niframe部分的代码是从A站拷的 科科\n\n<iframe id=\"ACFlashPlayer-re\" frameborder=\"0\" allowfullscreen=\"\" src=\"https://ssl.acfun.tv/block-player-homura.html?salt=167350321&amp;forFlash_=edae4e96-0f5e-4e15-d4c8-5b6c74bd3515,s106,ac2260637,#token=d2d835iu51nn4s4i;vid=2770596;postMessage=1;autoplay=0;fullscreen=0;from=http://www.acfun.tv;hint=小贴士：按下“←”和“→”键即可后退或前进一小段。\" style=\"height: 592px; width: 700px; left: 0px; top: 0px;\"></iframe>\n","source":"_posts/请问您今天要来点兔子吗.md","raw":"title: 请问您今天要来点兔子吗\ndate: 2015-11-06 10:17:50\ntag: 二次元\n---\n再次推一下萌出血的点兔第二季ED（循环洗脑版！！）\n顺便 \nmarkdown 嵌入视频测试~ \n\niframe部分的代码是从A站拷的 科科\n\n<iframe id=\"ACFlashPlayer-re\" frameborder=\"0\" allowfullscreen=\"\" src=\"https://ssl.acfun.tv/block-player-homura.html?salt=167350321&amp;forFlash_=edae4e96-0f5e-4e15-d4c8-5b6c74bd3515,s106,ac2260637,#token=d2d835iu51nn4s4i;vid=2770596;postMessage=1;autoplay=0;fullscreen=0;from=http://www.acfun.tv;hint=小贴士：按下“←”和“→”键即可后退或前进一小段。\" style=\"height: 592px; width: 700px; left: 0px; top: 0px;\"></iframe>\n","slug":"请问您今天要来点兔子吗","published":1,"updated":"2016-01-06T13:48:43.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvwu0004s8rkqrh76qll"},{"title":"用js原生实现Ajax的get和post","date":"2015-08-18T02:17:50.000Z","_content":"\n虽然jquery的ajax挺方便，但是了解了原生实现的原理也是很不错的。而且封装好的原生Js Ajax用起来也挺方便的~ XD~\n<!--more-->\n\n#### 参数序列化函数\n```javascript\nfunction serialize (data) {//将参数序列化\n    if (!data) return '';\n    var pairs = [];\n    for (var name in data){\n        if (!data.hasOwnerProperty(name)) continue;\n        if (typeof data[name] === 'function') continue;\n        var value = data[name].toString();\n        name = uncodeURIComponent(name);\n        value = uncodeURIComponent(value);\n        pairs.push(name + '=' + value);\n  }\n  return pairs.join('&');\n}\n```\n#### 原生封装Ajax的get方法\n```javascript\n  function get(url,options,callback){\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function (){\n        if (xhr.readyState == 4) {\n              if ((xhr.status > 200 && xhr.status < 300) || xhr.status == 304) {\n                callback(xhr.responseText);\n            }else {\n                alert(\"request failed : \" + xhr.status);\n            }\n        };\n    }\n    xhr.open(\"get\",url + \"?\" + serialize(options),true);\n    xhr.send(null);//get 不将数据作为参数传入\n    }\n```\n***调用方式***：\n```javascript\n  get(url,json,function(data){\n  console.log('data');\n  //如果data为json对象，需要JSON.parse(data)解析之后才可以用\n  })\n```\n\n#### 原生封装Ajax的post方法\n```javascript\n  function post(url, options, callback) {\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function(callback) {\n          if(xhr.readyState == 4) {\n            if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n                  callback(xhr.responseText);\n            }else {\n                alert('request failed!' + xhr.status);\n              }\n        }\n      }\n      xhr.open('post', url, true);\n      xhr.send(serialize(options));\n    }\n      \n  //用法：getCookie(\"loginSuc\");\n```\n","source":"_posts/用js原生实现Ajax的get和post.md","raw":"title: 用js原生实现Ajax的get和post\ndate: 2015-08-18 10:17:50\ntags: Javascript学习笔记\n\n---\n\n虽然jquery的ajax挺方便，但是了解了原生实现的原理也是很不错的。而且封装好的原生Js Ajax用起来也挺方便的~ XD~\n<!--more-->\n\n#### 参数序列化函数\n```javascript\nfunction serialize (data) {//将参数序列化\n    if (!data) return '';\n    var pairs = [];\n    for (var name in data){\n        if (!data.hasOwnerProperty(name)) continue;\n        if (typeof data[name] === 'function') continue;\n        var value = data[name].toString();\n        name = uncodeURIComponent(name);\n        value = uncodeURIComponent(value);\n        pairs.push(name + '=' + value);\n  }\n  return pairs.join('&');\n}\n```\n#### 原生封装Ajax的get方法\n```javascript\n  function get(url,options,callback){\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function (){\n        if (xhr.readyState == 4) {\n              if ((xhr.status > 200 && xhr.status < 300) || xhr.status == 304) {\n                callback(xhr.responseText);\n            }else {\n                alert(\"request failed : \" + xhr.status);\n            }\n        };\n    }\n    xhr.open(\"get\",url + \"?\" + serialize(options),true);\n    xhr.send(null);//get 不将数据作为参数传入\n    }\n```\n***调用方式***：\n```javascript\n  get(url,json,function(data){\n  console.log('data');\n  //如果data为json对象，需要JSON.parse(data)解析之后才可以用\n  })\n```\n\n#### 原生封装Ajax的post方法\n```javascript\n  function post(url, options, callback) {\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function(callback) {\n          if(xhr.readyState == 4) {\n            if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n                  callback(xhr.responseText);\n            }else {\n                alert('request failed!' + xhr.status);\n              }\n        }\n      }\n      xhr.open('post', url, true);\n      xhr.send(serialize(options));\n    }\n      \n  //用法：getCookie(\"loginSuc\");\n```\n","slug":"用js原生实现Ajax的get和post","published":1,"updated":"2016-01-06T12:05:50.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvwx0007s8rk532y651h"},{"title":"浏览器的重绘与重排","date":"2015-09-23T12:46:25.000Z","_content":"\n前端开发的过程中，我们不仅要实现设计师提供的炫酷设计稿，同时还要考虑到用最好的方式，最优的性能去实现它。为此，我们需要了解浏览器的重绘与重排概念。\n<!--more-->\n首先我们要先了解浏览器从下载文档到显示页面的过程，这里面就包含了重绘与重排。\n>简单讲，通常在文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了，再根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。\n\n重绘的概念：\n>重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。\n\n重排（也称作回流）是更明显的一种改变，可以理解为渲染树需要重新计算。\n\n触发重排的常见情况有三种：\n1. DOM元素的几何属性变化\n一个DOM元素的几何属性实现改变，会使浏览器重新构建此节点，而且也许会带来相关元素的重排。浏览器会计算相关元素如兄弟元素、子元素的尺寸，进行重新绘制。可见，重排一定会引起浏览器的重绘，一个元素的重排通常带来一系列的反应，性能代价是高昂的。\n\n2. DOM树的结构变化\n    当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。浏览器的布局过程类似于树的前序遍历，是一个从从上到下从左到右的过程。所以，如果在Body最前面插入一个元素，会导致整个文档树的重排，而在最后插入元素，不会影响前面的元素。\n3. 获取某些属性\n    当获取某些属性时，浏览器为了取得正确的值，也会触发重排。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()\n\n    所以，在多次使用这些值时，应该进行缓存。\n\n开发中减少重排次数和缩小重排范围的方法：\n1. 将多次改变样式属性的操作合并为一次操作，也就是将需要改变的的样式写在css中，并给一个类名，在js中只需要改变className即可。\n\n2. 需要多次重排的元素，position值最好为absolute或者fix，让它脱离文档流，这样就不会影响其他元素。所以有动画效果的元素最好设置绝对定位。\n\n3. 需要增加多个节点，可以一次性构建一个html片段，然后一次性添加到文档中去，而不是循环添加每一行。\n\n4. 由于display为none的元素不再渲染树中，对隐藏元素的操作不会引发其他元素的重排。如果要对一个元素进行复杂操作，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。\n\n5. 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。","source":"_posts/浏览器的重绘与重排.md","raw":"title: 浏览器的重绘与重排\ndate: 2015-9-23 20:46:25\ntag: web前端知识\n---\n\n前端开发的过程中，我们不仅要实现设计师提供的炫酷设计稿，同时还要考虑到用最好的方式，最优的性能去实现它。为此，我们需要了解浏览器的重绘与重排概念。\n<!--more-->\n首先我们要先了解浏览器从下载文档到显示页面的过程，这里面就包含了重绘与重排。\n>简单讲，通常在文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了，再根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。\n\n重绘的概念：\n>重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。\n\n重排（也称作回流）是更明显的一种改变，可以理解为渲染树需要重新计算。\n\n触发重排的常见情况有三种：\n1. DOM元素的几何属性变化\n一个DOM元素的几何属性实现改变，会使浏览器重新构建此节点，而且也许会带来相关元素的重排。浏览器会计算相关元素如兄弟元素、子元素的尺寸，进行重新绘制。可见，重排一定会引起浏览器的重绘，一个元素的重排通常带来一系列的反应，性能代价是高昂的。\n\n2. DOM树的结构变化\n    当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。浏览器的布局过程类似于树的前序遍历，是一个从从上到下从左到右的过程。所以，如果在Body最前面插入一个元素，会导致整个文档树的重排，而在最后插入元素，不会影响前面的元素。\n3. 获取某些属性\n    当获取某些属性时，浏览器为了取得正确的值，也会触发重排。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()\n\n    所以，在多次使用这些值时，应该进行缓存。\n\n开发中减少重排次数和缩小重排范围的方法：\n1. 将多次改变样式属性的操作合并为一次操作，也就是将需要改变的的样式写在css中，并给一个类名，在js中只需要改变className即可。\n\n2. 需要多次重排的元素，position值最好为absolute或者fix，让它脱离文档流，这样就不会影响其他元素。所以有动画效果的元素最好设置绝对定位。\n\n3. 需要增加多个节点，可以一次性构建一个html片段，然后一次性添加到文档中去，而不是循环添加每一行。\n\n4. 由于display为none的元素不再渲染树中，对隐藏元素的操作不会引发其他元素的重排。如果要对一个元素进行复杂操作，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。\n\n5. 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。","slug":"浏览器的重绘与重排","published":1,"updated":"2016-01-06T13:53:22.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvx1000as8rk8ehc1p16"},{"title":"Array类型对象的一些常用方法","date":"2015-11-20T02:10:50.000Z","_content":"\nAarry类型是js中很常见的类型，Js原生就给了它一些很方便的方法供我们使用，不需要我们去实现。现在我们来总结一下这些常用的方法。\n<!-- more -->\n** splice() **\n\n第一个介绍的是最强大的数组方法`splice()`，它既可以用于插入数组项，还能用于删除和替换。\n`splice()`方法接受参数，第一个参数是删除数组项的起始位置，第二个参数是删除数组项个数，后面的参数是在删除后添加的数组项内容。\n`splice()`返回的是从原始数组中删除的数组项，若没有删除，则返回空数组。\n\n删除：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(0,2); //返回[\"red\",\"blue\"]，此时colors 为[\"black\",\"green\",\"white\"]\n```\n插入：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(2,0,\"aaa\",\"bbb\"); //返回空数组，此时colors 为[\"red\", \"blue\", \"aaa\", \"bbb\", \"black\", \"green\", \"white\"]\n```\n替换：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(2,1,\"aaa\"); //返回[\"black\"], 此时colors为[\"red\", \"blue\",\"aaa\", \"green\", \"white\"]\n```\n** toString() 与 valueOf() **\n\n调用数组的`toString()`方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用数组的`valueOf()`方法返回的还是数组。\n例：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.toString(); //\"red,blue,black\"\n    colors.valueOf(); //[\"red\", \"blue\", \"black\"] \n```\n** join() **\n\n数组继承的toString()、valueOf()方法，在默认情况下逗号以逗号分隔字符串的形式返回，而如果使用`join()`方法，则可以使用不同的分隔符来构建这个字符串。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.join(\",\"); //\"red,blue,black\"\n    colors.join(\"|\"); //\"red|blue|black\"\n    colors.join(\"\");//\"redblueblack\"\n```\n** push() 和 unshift() **\n\n这两个方法的功能刚好相反。\n`push()`方法可以接受任意数量的参数，把它们逐个添加到数组**末尾**，并返回新数组长度。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.push(\"aaa\",\"bbb\"); //返回5\n    alert(colors);  //[\"red\", \"blue\", \"black\", \"aaa\", \"bbb\"]\n```\n`unshift()`方法可以接受任意数量的参数，把它们逐个添加到数组**前端**，并返回新数组长度。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.push(\"aaa\",\"bbb\"); //返回5\n    alert(colors);  //[\"aaa\", \"bbb\",\"red\", \"blue\", \"black\"]\n```\n** pop() 和 shift() **\n\n这两个方法的功能也是相反的\n`pop()`方法从数组末尾移除**最后一项**，减少数组的length值，然后返回移除的项。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.pop(); //返回 \"black\"\n```\n`shift()`方法从数组末尾移除**第一项**，减少数组的length值，然后返回移除的项。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.pop(); //返回 \"red\"\n```\n我们可以结合push()和pop()方法，实现类似**栈**的LIFO(Last-in-First-out)后进先出。\n也可以结合unshift()和shift()方法，实现类似**队列**的FIFO(First-in-First-out)先进先出。\n\n** reverse() 与 sort() **\n\n`reverse()`方法会反转数组项的顺序,返回经过排序后的数组。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.reverse(); //返回[\"black\", \"blue\", \"red\"]\n```\n`sort()`方法按升序排列数组项，但是由于它其实是先调用数组项的`toString()`方法，然后比较的是字符串，所以如果需要比较数字大小的时候，建议给其传一个比较函数。\n```javascript\n    function compare(value1,value2){ //按升序\n       return value1-value2;\n    }\n    var values = [0,1,33,12,4];\n    values.sort(compare);// [0, 1, 4, 12, 33]\n```\n** slice() **\n`slice()`方法能够给予当前数组中的一或多个项创建一个新数组。slice()方法可接受一或两个参数，即要返回项的起始和结束位置。\n在只有一个参数的情况下，slice()方法返回从参数指定位置到当前数组末尾的所有项。\n如果有两个参数，则返回起始和结束位置之间的项——但不包括结束位置的项。 注意,slice()方法不会影响原始数组。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"];\n    colors.slice(1); //[\"blue\", \"black\", \"green\", \"white\"]\n    colors.slice(1,4); //[\"blue\", \"black\", \"green\"]\n```\n","source":"_posts/数组的常用方法.md","raw":"title: Array类型对象的一些常用方法\ndate: 2015-11-20 10:10:50\ntags: Javascript学习笔记\n---\n\nAarry类型是js中很常见的类型，Js原生就给了它一些很方便的方法供我们使用，不需要我们去实现。现在我们来总结一下这些常用的方法。\n<!-- more -->\n** splice() **\n\n第一个介绍的是最强大的数组方法`splice()`，它既可以用于插入数组项，还能用于删除和替换。\n`splice()`方法接受参数，第一个参数是删除数组项的起始位置，第二个参数是删除数组项个数，后面的参数是在删除后添加的数组项内容。\n`splice()`返回的是从原始数组中删除的数组项，若没有删除，则返回空数组。\n\n删除：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(0,2); //返回[\"red\",\"blue\"]，此时colors 为[\"black\",\"green\",\"white\"]\n```\n插入：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(2,0,\"aaa\",\"bbb\"); //返回空数组，此时colors 为[\"red\", \"blue\", \"aaa\", \"bbb\", \"black\", \"green\", \"white\"]\n```\n替换：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(2,1,\"aaa\"); //返回[\"black\"], 此时colors为[\"red\", \"blue\",\"aaa\", \"green\", \"white\"]\n```\n** toString() 与 valueOf() **\n\n调用数组的`toString()`方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用数组的`valueOf()`方法返回的还是数组。\n例：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.toString(); //\"red,blue,black\"\n    colors.valueOf(); //[\"red\", \"blue\", \"black\"] \n```\n** join() **\n\n数组继承的toString()、valueOf()方法，在默认情况下逗号以逗号分隔字符串的形式返回，而如果使用`join()`方法，则可以使用不同的分隔符来构建这个字符串。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.join(\",\"); //\"red,blue,black\"\n    colors.join(\"|\"); //\"red|blue|black\"\n    colors.join(\"\");//\"redblueblack\"\n```\n** push() 和 unshift() **\n\n这两个方法的功能刚好相反。\n`push()`方法可以接受任意数量的参数，把它们逐个添加到数组**末尾**，并返回新数组长度。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.push(\"aaa\",\"bbb\"); //返回5\n    alert(colors);  //[\"red\", \"blue\", \"black\", \"aaa\", \"bbb\"]\n```\n`unshift()`方法可以接受任意数量的参数，把它们逐个添加到数组**前端**，并返回新数组长度。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.push(\"aaa\",\"bbb\"); //返回5\n    alert(colors);  //[\"aaa\", \"bbb\",\"red\", \"blue\", \"black\"]\n```\n** pop() 和 shift() **\n\n这两个方法的功能也是相反的\n`pop()`方法从数组末尾移除**最后一项**，减少数组的length值，然后返回移除的项。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.pop(); //返回 \"black\"\n```\n`shift()`方法从数组末尾移除**第一项**，减少数组的length值，然后返回移除的项。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.pop(); //返回 \"red\"\n```\n我们可以结合push()和pop()方法，实现类似**栈**的LIFO(Last-in-First-out)后进先出。\n也可以结合unshift()和shift()方法，实现类似**队列**的FIFO(First-in-First-out)先进先出。\n\n** reverse() 与 sort() **\n\n`reverse()`方法会反转数组项的顺序,返回经过排序后的数组。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.reverse(); //返回[\"black\", \"blue\", \"red\"]\n```\n`sort()`方法按升序排列数组项，但是由于它其实是先调用数组项的`toString()`方法，然后比较的是字符串，所以如果需要比较数字大小的时候，建议给其传一个比较函数。\n```javascript\n    function compare(value1,value2){ //按升序\n       return value1-value2;\n    }\n    var values = [0,1,33,12,4];\n    values.sort(compare);// [0, 1, 4, 12, 33]\n```\n** slice() **\n`slice()`方法能够给予当前数组中的一或多个项创建一个新数组。slice()方法可接受一或两个参数，即要返回项的起始和结束位置。\n在只有一个参数的情况下，slice()方法返回从参数指定位置到当前数组末尾的所有项。\n如果有两个参数，则返回起始和结束位置之间的项——但不包括结束位置的项。 注意,slice()方法不会影响原始数组。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"];\n    colors.slice(1); //[\"blue\", \"black\", \"green\", \"white\"]\n    colors.slice(1,4); //[\"blue\", \"black\", \"green\"]\n```\n","slug":"数组的常用方法","published":1,"updated":"2016-01-06T13:48:15.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvx4000ds8rk78h8o35n"},{"title":"学习日报 2015-09-23——2015-09-25","date":"2015-11-06T02:17:50.000Z","_content":"刚过完中秋节，来补日报了。\n<!--more-->\n### 2015-09-25\n#### 一、今天学习了\n1. canvas的图像绘制、图片像素处理等api；\n2. svg\n\n#### 二、今天完成了\n1. 利用canvas完成了图片处理的网页，见http://cky917.github.io/zbjstudy/day14/index.html\n2. 学习了canvas的api 感觉很好玩\n \n \n### 2015-09-24\n### 一、今天学习了\n1. 性能优化，加快网页加载速度的方法\n2. 异步加载\n\n### 二、今天完成了\n1. 老师上课的时候提了几个概念和知识点，我下午进行了一下深入了解学习。主要包括：\n    1.  客户端缓存\n    2.  cache-control、expires、last-Modify\n    3.  强制清除缓存的方法\n    4.  从setTimeout看js的运行机制。\n2. promise的实例代码测试和电子书学习\n\n### 2015-09-23\n今天没有上课，主要是消化一下前面的知识。\n趁着这个机会，我今天主要研究了几个课上老师提出的问题以及自己还不是很了解的知识点 \n1. 当初面试的时候问我浏览器的重排（回流）和重绘，我没回答上，今天对这两个概念进行了学习。\n2. HTTP 协议中 URI 和 URL 有什么区别？\n3. 从输入 URL 到页面加载完成的过程中都发生了什么事情\n4. 详解js跨域问题\n5. 面试时问了我闭包的坏处，也没回答上。所以今天研究了闭包和内存泄露的问题。\n6. 看了一个smarty的教程，因为教程没有结合fis3，所以看了教程还是有点云里雾里 - - 感觉没有php的基础，用smarty比之前用的django模板要难啊","source":"_posts/学习日报2015-09-23——2015-09-25.md","raw":"title: 学习日报 2015-09-23——2015-09-25\ndate: 2015-11-06 10:17:50\ntag: 学习日报\n---\n刚过完中秋节，来补日报了。\n<!--more-->\n### 2015-09-25\n#### 一、今天学习了\n1. canvas的图像绘制、图片像素处理等api；\n2. svg\n\n#### 二、今天完成了\n1. 利用canvas完成了图片处理的网页，见http://cky917.github.io/zbjstudy/day14/index.html\n2. 学习了canvas的api 感觉很好玩\n \n \n### 2015-09-24\n### 一、今天学习了\n1. 性能优化，加快网页加载速度的方法\n2. 异步加载\n\n### 二、今天完成了\n1. 老师上课的时候提了几个概念和知识点，我下午进行了一下深入了解学习。主要包括：\n    1.  客户端缓存\n    2.  cache-control、expires、last-Modify\n    3.  强制清除缓存的方法\n    4.  从setTimeout看js的运行机制。\n2. promise的实例代码测试和电子书学习\n\n### 2015-09-23\n今天没有上课，主要是消化一下前面的知识。\n趁着这个机会，我今天主要研究了几个课上老师提出的问题以及自己还不是很了解的知识点 \n1. 当初面试的时候问我浏览器的重排（回流）和重绘，我没回答上，今天对这两个概念进行了学习。\n2. HTTP 协议中 URI 和 URL 有什么区别？\n3. 从输入 URL 到页面加载完成的过程中都发生了什么事情\n4. 详解js跨域问题\n5. 面试时问了我闭包的坏处，也没回答上。所以今天研究了闭包和内存泄露的问题。\n6. 看了一个smarty的教程，因为教程没有结合fis3，所以看了教程还是有点云里雾里 - - 感觉没有php的基础，用smarty比之前用的django模板要难啊","slug":"学习日报2015-09-23——2015-09-25","published":1,"updated":"2016-01-06T13:47:50.639Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvx7000fs8rk3lhtm8tn"},{"title":"学习日报 2015-09-16——2015-09-22","date":"2015-09-30T02:17:50.000Z","_content":"\n好久没有更新日报了- - 前几天忙着找房子，终于结束了每天来回奔波几个小时的悲惨生活。这几天学习进度又很赶，没时间写博客（其实就是懒- -）今天老师忙校招去了，让我们好好消化一下前几天的知识，所以今天就有了时间继续写日报啦~ 今天就直接把这几天的日报总结起来写好了。\n<!--more-->\n\n---\n###  2015-09-22\n\n####  一、今日学习了\n1. 正则表达式\n2. 前后端模板，主要是smarty\n\n####  二、今日完成了\n1. 任务一：完成规定正则表达式书写 :\n    1. 书写一个正则表达式匹配ip地址：\n            /((?:(?:25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))\\.){3}(?:25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d))))/\n\n    2. 书写一个正则表达式匹配邮箱地址:\n            /^([a-z0-9_])+@([a-z0-9_])+\\.([a-z0-9_])+/i\n\n    刚开始一直在纠结为什么上面的正则能够运行成功，而`/^([a-z0-9_])+@\\1+\\.\\1+/i`不能，后来查阅资料后发现是因为正则的后向引用，引用的就是匹配成功后的内容，引用的是结果，而不是表达式。\n    如果用`/^([a-z0-9_])+@\\1+\\.\\1+/ig `来匹配`zhubajie@zhubajie.zhubajie`则能够成功匹配，因为`\\1`的匹配结果只是`zhubajie`而已。\n\n    3. 书写一个正则表达式验证字符串包括了小写字母、大写字母、数字中至少两种字符\n            /([a-z]+[A-Z0-9][a-zA-Z0-9]*)|([A-Z]+[a-z0-9][a-zA-Z0-9]*)|([0-9]+[a-zA-Z][a-zA-Z0-9]*)/g\n\n2. 任务二：安装wamp和java运行时环境\n3. 将天棚网之前的json数据在php文件中构成模拟数组，并通过smarty语法页面上渲染输出。主要是为了让我们熟悉smarty。\n\n---\n\n### 2015-09-21\n \n#### 一、今日学习了\n1. chrome调试工具，以前调试js大部分的console.log()、alert() 很少利用断点- -，今天又学到了很多关于chrome开发者工具的新技能。\n2. http协议 对于同源和跨域有了深入了解 ，但是感觉自己计算机基础还需要重新复习。。\n3. ajax ，很好用的一个东西\n4. WebSocket与实时通讯，感觉很厉害，但是还没有实际操作过。\n\n#### 二、今日完成了\n1. 任务一：模拟json数据，用ajax完成day2的“海量作品”部分标签切换。同时我参考了天蓬网官网的方案，实现只有第一次点击标签时发送请求，之后都不发送请求，而是用之前已经缓存好的数据。http://cky917.github.io/zbjstudy/output/day2/day2.html\n2. 任务二：打开 http://task.t6.zbj.com/, 在首页的幻灯片执行的时候断点，找到 幻灯片执行函数和 播放按钮 绑定的事件，附上截图。 https://github.com/cky917/zbjstudy/blob/master/day10/task2.md\n3. 任务三：安装 PageSpeed，对猪八戒首页进行测试，提出提升速度的改进措施。https://github.com/cky917/zbjstudy/blob/master/day10/task3.md\n4. 任务四：通过网络请求，查看猪八戒首页引用了什么字体，附上截图。https://github.com/cky917/zbjstudy/blob/master/day10/task4.md\n\n---\n### 2015-09-18 \n \n#### 一、今日学习了\n1. html、css、js的模块化思想，amd、cmd；\n2. less、sea.js等工具\n2. 团队协作流程，前后端接口的制定方法\n\n#### 二、今日完成了\n1. 针对day2天蓬网的前端后端交互制定了数据接口文档\n2. 重构day2 天蓬网的html、css、js代码，用了模块化的思想。因为html css之前写的时候就有注意模块化，所以没怎么改。主要用了闭包封装的方式重构了js代码，感觉在这方面有了很大收获，对以后的代码风格也有帮助。\n\n---\n### 2015-09-17\n\n#### 一、今日学习：\n1.  移动开发的相关知识：\n    1. 地理信息\n    2. 重力感应\n    3. 网络连接信息\n    4. 微信JSSDK\n    5. 混合模式通信\n对移动开发挺有兴趣的，毕竟移动端也是一个很大的市场。今天的课主要是给了一个学习方向，还是需要自己多多研究。\n\n2. 响应式布局：媒体查询，px em rem的区别；\n\n\n#### 二、今日完成了&收获了:\n1. 做了一个指南针。\n2. 完成day2的导航响应式布局\n \n---\n### 2015-09-16\n\n#### 一、今日学习：\n1. js BOM相关知识；\n2. js DOM相关知识；\n3. js 事件相关知识；\n\n#### 二、今日完成了&收获了:\n1. day7作业，天蓬网Banner轮播，海量作品点击标签切换显示内容 完成效果见：http://cky917.github.io/zbjstudy/output/day2/day2.html；\n2. 对于定时器又回顾了一下，开始在做轮播时并没有完全清除定时器，导致后来图片越切越快，后来想到在定时器开始前都清除一下，解决了BUG；\n3. 做了一些测试数据，用字符串拼接的方式，不是很好的方案，但是没有用后台模板时，暂时还想不到其他方案- -","source":"_posts/学习日报 2015-09-16——2015-09-22.md","raw":"title: 学习日报 2015-09-16——2015-09-22\ndate: 2015-09-30 10:17:50\ntag: 学习日报\n---\n\n好久没有更新日报了- - 前几天忙着找房子，终于结束了每天来回奔波几个小时的悲惨生活。这几天学习进度又很赶，没时间写博客（其实就是懒- -）今天老师忙校招去了，让我们好好消化一下前几天的知识，所以今天就有了时间继续写日报啦~ 今天就直接把这几天的日报总结起来写好了。\n<!--more-->\n\n---\n###  2015-09-22\n\n####  一、今日学习了\n1. 正则表达式\n2. 前后端模板，主要是smarty\n\n####  二、今日完成了\n1. 任务一：完成规定正则表达式书写 :\n    1. 书写一个正则表达式匹配ip地址：\n            /((?:(?:25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))\\.){3}(?:25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d))))/\n\n    2. 书写一个正则表达式匹配邮箱地址:\n            /^([a-z0-9_])+@([a-z0-9_])+\\.([a-z0-9_])+/i\n\n    刚开始一直在纠结为什么上面的正则能够运行成功，而`/^([a-z0-9_])+@\\1+\\.\\1+/i`不能，后来查阅资料后发现是因为正则的后向引用，引用的就是匹配成功后的内容，引用的是结果，而不是表达式。\n    如果用`/^([a-z0-9_])+@\\1+\\.\\1+/ig `来匹配`zhubajie@zhubajie.zhubajie`则能够成功匹配，因为`\\1`的匹配结果只是`zhubajie`而已。\n\n    3. 书写一个正则表达式验证字符串包括了小写字母、大写字母、数字中至少两种字符\n            /([a-z]+[A-Z0-9][a-zA-Z0-9]*)|([A-Z]+[a-z0-9][a-zA-Z0-9]*)|([0-9]+[a-zA-Z][a-zA-Z0-9]*)/g\n\n2. 任务二：安装wamp和java运行时环境\n3. 将天棚网之前的json数据在php文件中构成模拟数组，并通过smarty语法页面上渲染输出。主要是为了让我们熟悉smarty。\n\n---\n\n### 2015-09-21\n \n#### 一、今日学习了\n1. chrome调试工具，以前调试js大部分的console.log()、alert() 很少利用断点- -，今天又学到了很多关于chrome开发者工具的新技能。\n2. http协议 对于同源和跨域有了深入了解 ，但是感觉自己计算机基础还需要重新复习。。\n3. ajax ，很好用的一个东西\n4. WebSocket与实时通讯，感觉很厉害，但是还没有实际操作过。\n\n#### 二、今日完成了\n1. 任务一：模拟json数据，用ajax完成day2的“海量作品”部分标签切换。同时我参考了天蓬网官网的方案，实现只有第一次点击标签时发送请求，之后都不发送请求，而是用之前已经缓存好的数据。http://cky917.github.io/zbjstudy/output/day2/day2.html\n2. 任务二：打开 http://task.t6.zbj.com/, 在首页的幻灯片执行的时候断点，找到 幻灯片执行函数和 播放按钮 绑定的事件，附上截图。 https://github.com/cky917/zbjstudy/blob/master/day10/task2.md\n3. 任务三：安装 PageSpeed，对猪八戒首页进行测试，提出提升速度的改进措施。https://github.com/cky917/zbjstudy/blob/master/day10/task3.md\n4. 任务四：通过网络请求，查看猪八戒首页引用了什么字体，附上截图。https://github.com/cky917/zbjstudy/blob/master/day10/task4.md\n\n---\n### 2015-09-18 \n \n#### 一、今日学习了\n1. html、css、js的模块化思想，amd、cmd；\n2. less、sea.js等工具\n2. 团队协作流程，前后端接口的制定方法\n\n#### 二、今日完成了\n1. 针对day2天蓬网的前端后端交互制定了数据接口文档\n2. 重构day2 天蓬网的html、css、js代码，用了模块化的思想。因为html css之前写的时候就有注意模块化，所以没怎么改。主要用了闭包封装的方式重构了js代码，感觉在这方面有了很大收获，对以后的代码风格也有帮助。\n\n---\n### 2015-09-17\n\n#### 一、今日学习：\n1.  移动开发的相关知识：\n    1. 地理信息\n    2. 重力感应\n    3. 网络连接信息\n    4. 微信JSSDK\n    5. 混合模式通信\n对移动开发挺有兴趣的，毕竟移动端也是一个很大的市场。今天的课主要是给了一个学习方向，还是需要自己多多研究。\n\n2. 响应式布局：媒体查询，px em rem的区别；\n\n\n#### 二、今日完成了&收获了:\n1. 做了一个指南针。\n2. 完成day2的导航响应式布局\n \n---\n### 2015-09-16\n\n#### 一、今日学习：\n1. js BOM相关知识；\n2. js DOM相关知识；\n3. js 事件相关知识；\n\n#### 二、今日完成了&收获了:\n1. day7作业，天蓬网Banner轮播，海量作品点击标签切换显示内容 完成效果见：http://cky917.github.io/zbjstudy/output/day2/day2.html；\n2. 对于定时器又回顾了一下，开始在做轮播时并没有完全清除定时器，导致后来图片越切越快，后来想到在定时器开始前都清除一下，解决了BUG；\n3. 做了一些测试数据，用字符串拼接的方式，不是很好的方案，但是没有用后台模板时，暂时还想不到其他方案- -","slug":"学习日报 2015-09-16——2015-09-22","published":1,"updated":"2016-01-06T13:47:34.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvxb000is8rkqm3cxkdy"},{"title":"学习日报 2015-09-14","date":"2015-09-14T12:34:22.000Z","_content":"一、今日学习&收获了：\n1.css常见布局的几种实现方法；\n2.css兼容性\n3.js基础，js的几种类型以及识别方式,以及函数需要注意的一些点，发现自己对于基础的知识还是记忆不深。\n\n二、今日完成了:\n1.day5的作业，用 JavaScript 编写一个函数 输入： 一个正整数  输出：0 到输入间的所有回⽂文数字到控制台;\n2.上周五完成了day2的布局，今天主要解决了代码上传到Github上提示找不到css文件的问题，因为output的路径要是相对路径才能找到。所以今天成功上传至github，生成了gitpages；\n布局[完成效果](http://cky917.github.io/zbjstudy/output/day2/day2.html);\n \n三、明日目标：\n1.研究面向对象的编程方式。","source":"_posts/学习日报 2015-09-15.md","raw":"title: 学习日报 2015-09-14\ndate: 2015-09-14 20:34:22\ntag: 学习日报\n---\n一、今日学习&收获了：\n1.css常见布局的几种实现方法；\n2.css兼容性\n3.js基础，js的几种类型以及识别方式,以及函数需要注意的一些点，发现自己对于基础的知识还是记忆不深。\n\n二、今日完成了:\n1.day5的作业，用 JavaScript 编写一个函数 输入： 一个正整数  输出：0 到输入间的所有回⽂文数字到控制台;\n2.上周五完成了day2的布局，今天主要解决了代码上传到Github上提示找不到css文件的问题，因为output的路径要是相对路径才能找到。所以今天成功上传至github，生成了gitpages；\n布局[完成效果](http://cky917.github.io/zbjstudy/output/day2/day2.html);\n \n三、明日目标：\n1.研究面向对象的编程方式。","slug":"学习日报 2015-09-15","published":1,"updated":"2015-11-11T14:17:26.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvxd000ks8rkehlom12y"},{"title":"学习日报 2015-09-11","date":"2015-09-11T14:13:50.000Z","_content":"今天完成了：\n\n1.对前几天的知识查漏补缺\n2.完成了作业：测试图片加载资源的行为，测试结果如下：[文档](http://git.zhubajie.la/fetraining/chenkeyi/blob/master/day4/day4.md)\n3.完成了day2作业的天蓬网的css，并且兼容到了ie8；","source":"_posts/学习日报 2015-09-11.md","raw":"title: 学习日报 2015-09-11\ndate: 2015-09-11 22:13:50\ntag: 学习日报\n---\n今天完成了：\n\n1.对前几天的知识查漏补缺\n2.完成了作业：测试图片加载资源的行为，测试结果如下：[文档](http://git.zhubajie.la/fetraining/chenkeyi/blob/master/day4/day4.md)\n3.完成了day2作业的天蓬网的css，并且兼容到了ie8；","slug":"学习日报 2015-09-11","published":1,"updated":"2015-11-11T14:17:26.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvxh000ms8rk91ncd6td"},{"title":"学习日报 2015-09-10","date":"2015-09-10T12:17:50.000Z","_content":"话说每天都赶1个半小时的车程来回学校和公司还是有点伤啊…洗完澡都23点30分了- -\n<!--more-->\n### 一、今天学习&收获了：\n1. css以及css3基础，css3动画。\n2. css选择器、盒模型、定位。\n3. css3真的是一个神奇的东西，虽然在PC端依然有很多兼容性问题，但是在移动端用起来简直爽啊。想半年前起了学习前端的念头时候，也是因为炫酷的css3动画，之后还要好好研究研究。\n\n### 二、今天的完成了：\n\n1. 作业1 用1个标签、2个标签、3个标签、5个标签实现十字架；[实现效果](http://cky917.github.io/zbjstudy/day3/test1.html)\n2. 作业2 用css3实现相应的动画；[实现效果](http://cky917.github.io/zbjstudy/day3/test2.html)\n3. 实现了一部分day2的css布局;\n\n### 三、问题：\n\n1. 关于FIS3的问题，我在本地的服务器上可以正常浏览。但是我把文件上传到github上，就告诉我css路径不对..还得接着研究..","source":"_posts/学习日报 2015-09-10.md","raw":"title: 学习日报 2015-09-10\ndate: 2015-09-10 20:17:50\ntag: 学习日报\n---\n话说每天都赶1个半小时的车程来回学校和公司还是有点伤啊…洗完澡都23点30分了- -\n<!--more-->\n### 一、今天学习&收获了：\n1. css以及css3基础，css3动画。\n2. css选择器、盒模型、定位。\n3. css3真的是一个神奇的东西，虽然在PC端依然有很多兼容性问题，但是在移动端用起来简直爽啊。想半年前起了学习前端的念头时候，也是因为炫酷的css3动画，之后还要好好研究研究。\n\n### 二、今天的完成了：\n\n1. 作业1 用1个标签、2个标签、3个标签、5个标签实现十字架；[实现效果](http://cky917.github.io/zbjstudy/day3/test1.html)\n2. 作业2 用css3实现相应的动画；[实现效果](http://cky917.github.io/zbjstudy/day3/test2.html)\n3. 实现了一部分day2的css布局;\n\n### 三、问题：\n\n1. 关于FIS3的问题，我在本地的服务器上可以正常浏览。但是我把文件上传到github上，就告诉我css路径不对..还得接着研究..","slug":"学习日报 2015-09-10","published":1,"updated":"2015-11-11T14:17:26.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvxj000os8rk5wwu5mnf"},{"title":"学习日报 2015-09-09","date":"2015-09-09T15:16:34.000Z","_content":"实习第二天，又来写日报啦。\n<!--more-->\n### 一、今天学习&收获了：\n1. HTML基础知识，标签的使用规范；\n2. 切图技巧、思路，在切图前首先要大致分析一遍设计图，想好哪些图是要切的，哪些图是用字体图标的，哪些部分是要写的，哪些部分是可以用现成的组件的。\n3. 今天还学了最新的photoshop cc2014更方便的切图方法,简直神器；\n4. 前端工具的使用，如PS、FIS；\n5. stay hungry , stay foolish.\n\n### 二、今天的完成了：\n1. 根据老师给的天蓬网主页PSD文件进行了HTML结构排版。\n2. 研究FIS3工具，之前由于FIS3自带的某个文件有错误，FIS3 init一直无法成功，后来研究了一阵，把报错文件的错误行给注释掉之后终于成功进行fis3 init，耽误了一些时间。\n3. 切出需要的图片后，运用FIS3工具生成了雪碧图 参考资料。\n\n### 三、明天计划\n1. 继续深入学习FIS3的功能。\n2. 完善今天的HTML结构，完成CSS布局。","source":"_posts/学习日报 2015-09-09.md","raw":"title: 学习日报 2015-09-09\ndate: 2015-09-09 23:16:34\ntag: 学习日报\n---\n实习第二天，又来写日报啦。\n<!--more-->\n### 一、今天学习&收获了：\n1. HTML基础知识，标签的使用规范；\n2. 切图技巧、思路，在切图前首先要大致分析一遍设计图，想好哪些图是要切的，哪些图是用字体图标的，哪些部分是要写的，哪些部分是可以用现成的组件的。\n3. 今天还学了最新的photoshop cc2014更方便的切图方法,简直神器；\n4. 前端工具的使用，如PS、FIS；\n5. stay hungry , stay foolish.\n\n### 二、今天的完成了：\n1. 根据老师给的天蓬网主页PSD文件进行了HTML结构排版。\n2. 研究FIS3工具，之前由于FIS3自带的某个文件有错误，FIS3 init一直无法成功，后来研究了一阵，把报错文件的错误行给注释掉之后终于成功进行fis3 init，耽误了一些时间。\n3. 切出需要的图片后，运用FIS3工具生成了雪碧图 参考资料。\n\n### 三、明天计划\n1. 继续深入学习FIS3的功能。\n2. 完善今天的HTML结构，完成CSS布局。","slug":"学习日报 2015-09-09","published":1,"updated":"2015-11-11T14:17:26.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvxp000qs8rko5k2dutv"},{"title":"学习日报 2015-09-08","date":"2015-09-08T02:17:50.000Z","_content":"最近加入了重庆猪八戒，进行前端实习。公司要求每天写学习日报，正好对自己也是一个总结，所以在博客上也更新我的学习日报。希望能够坚持~\n<!--more-->\n### 一、今日主要学习内容\n\n1. 今天上午学习了前端开发工具、环境的下载和配置，还有猪八戒的前端规范。\n2. 下午进行了作业训练，注册了公司的gitlab账号并加入了group。创建了自己的git项目，并且上传了相应的作业文件。\n3. 今天安装了git、node、fis、ps。\n\n### 二、今日收获\n\n1. git之前有接触过，熟悉一些常用的命令，也帮助了一起实习的同学关于git的一些问题，他们之前大都用的SVN。\n2. 不过我之前一直使用的是git pull，今天老师说git pull不建议使用，因为git pull = git fetch+git merge，又学到了（不过在自己个人的小项目上还是喜欢用git pull偷懒- -)。\n3. node和fis一直处于不明觉厉的阶段，期待有更多实践上的指导和学习。\n4. 关于猪八戒前端规范，和我之前了解的前端规范基本差不多，而且更细致一些。只有做到规范化的代码，能大大减少团队合作的阻力和后期维护成本。\n5. 还有今天用上了公司提供的翻墙软件，开心。之前红杏被封了好久没出墙了- -","source":"_posts/学习日报 2015-09-08.md","raw":"title: 学习日报 2015-09-08\ndate: 2015-09-08 10:17:50\ntag: 学习日报\n---\n最近加入了重庆猪八戒，进行前端实习。公司要求每天写学习日报，正好对自己也是一个总结，所以在博客上也更新我的学习日报。希望能够坚持~\n<!--more-->\n### 一、今日主要学习内容\n\n1. 今天上午学习了前端开发工具、环境的下载和配置，还有猪八戒的前端规范。\n2. 下午进行了作业训练，注册了公司的gitlab账号并加入了group。创建了自己的git项目，并且上传了相应的作业文件。\n3. 今天安装了git、node、fis、ps。\n\n### 二、今日收获\n\n1. git之前有接触过，熟悉一些常用的命令，也帮助了一起实习的同学关于git的一些问题，他们之前大都用的SVN。\n2. 不过我之前一直使用的是git pull，今天老师说git pull不建议使用，因为git pull = git fetch+git merge，又学到了（不过在自己个人的小项目上还是喜欢用git pull偷懒- -)。\n3. node和fis一直处于不明觉厉的阶段，期待有更多实践上的指导和学习。\n4. 关于猪八戒前端规范，和我之前了解的前端规范基本差不多，而且更细致一些。只有做到规范化的代码，能大大减少团队合作的阻力和后期维护成本。\n5. 还有今天用上了公司提供的翻墙软件，开心。之前红杏被封了好久没出墙了- -","slug":"学习日报 2015-09-08","published":1,"updated":"2015-11-11T14:17:26.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvxs000ss8rkn08okcc8"},{"title":"好玩的cookie","date":"2015-07-25T02:17:50.000Z","_content":"最近接触了cookie，发现浏览器cookie真的挺好玩的，前端做的事也可以在网页关闭或刷新后依然存在，多难得啊（被用户清除了cookie就没办法了...）。cookie可以帮助前端实现一些用户行为储存，进而实现一些针对用户的操作。\n<!--more-->\ncookie的增删查改也并不难，但是有一些细节还是得注意。\n\n***cookie的设置/修改封装函数***\n\n1. 直接也可以设置:`document.cookie= 'name=value'`;\n2. 更推荐封装函数：\n```javascript\n// 设置expires\n// var date=new Date(); \n// var expiresDays=10; \n// 将date设置为10天以后的时间 \n// date.setTime(date.getTime()+expiresDays*24*3600*1000); \nfunction setCookie(name,value,expires,path,domain,secure){\n    var cookie = encodeURIComponent(name) + '=' +encodeURIComponent(value);\n    if(expires){\n        cookie += ';expires=' + expires.toGMTString();//失效时间\n    }\n    if(path){\n        cookie += ';path=' +path;\n    }\n    if(domain){\n        cookie +=';secure' + secure;//http协议时生效，默认false\n    }\n    document.cookie = cookie;\n\n    //用法：set(\"loginSuc\",\"yes\",date,path,domain,secure)\n}\n```\n\n***cookie的获取封装函数***\n\n```javascript\n   String.prototype.trim=function(){//去除字符串两端空格\n      return this.replace(/(^\\s*)|(\\s*$)/g, ”); \n     }\n   function getcookie(Name) {\n       var cookie = {};\n       var all = document.cookie;\n      if (all === '')\n           return cookie;\n       var list = all.split('; ');\n       for (var i = 0; i < list.length; i++) {\n           var item = list[i];\n           var p = item.indexOf('=');\n           var name = item.substring(0, p);\n           name = decodeURIComponent(name).trim();//注意这里有个坑，除了第一个name，后面的name前面都有一个空格，所以要处理掉前面的空格才行；\n           var value = item.substring(p + 1);\n           value = decodeURIComponent(value);\n           cookie[name] = value;\n       }\n       return cookie[Name];\n   }\n//用法：getCookie(\"loginSuc\");\n```\n***cookie的删除函数封装***\n```javascript\n    function removeCookie(name) { \n        var exp = new Date(); \n        exp.setTime(exp.getTime() - 1); \n        var cval=getCookie(name); \n        if(cval!=null) document.cookie= name + \"=\"+cval+\";expires=\"+exp.toGMTString(); \n    } \n```\n\n使用cookie我们可以设置用户的登录状态，亦或是点击了不再显示后就设置一个不再显示的cookie,通过获取cookie来达到效果。感觉棒棒哒！","source":"_posts/好玩的cookie.md","raw":"title: 好玩的cookie\ndate: 2015-07-25 10:17:50\ntags: Javascript学习笔记\n\n---\n最近接触了cookie，发现浏览器cookie真的挺好玩的，前端做的事也可以在网页关闭或刷新后依然存在，多难得啊（被用户清除了cookie就没办法了...）。cookie可以帮助前端实现一些用户行为储存，进而实现一些针对用户的操作。\n<!--more-->\ncookie的增删查改也并不难，但是有一些细节还是得注意。\n\n***cookie的设置/修改封装函数***\n\n1. 直接也可以设置:`document.cookie= 'name=value'`;\n2. 更推荐封装函数：\n```javascript\n// 设置expires\n// var date=new Date(); \n// var expiresDays=10; \n// 将date设置为10天以后的时间 \n// date.setTime(date.getTime()+expiresDays*24*3600*1000); \nfunction setCookie(name,value,expires,path,domain,secure){\n    var cookie = encodeURIComponent(name) + '=' +encodeURIComponent(value);\n    if(expires){\n        cookie += ';expires=' + expires.toGMTString();//失效时间\n    }\n    if(path){\n        cookie += ';path=' +path;\n    }\n    if(domain){\n        cookie +=';secure' + secure;//http协议时生效，默认false\n    }\n    document.cookie = cookie;\n\n    //用法：set(\"loginSuc\",\"yes\",date,path,domain,secure)\n}\n```\n\n***cookie的获取封装函数***\n\n```javascript\n   String.prototype.trim=function(){//去除字符串两端空格\n      return this.replace(/(^\\s*)|(\\s*$)/g, ”); \n     }\n   function getcookie(Name) {\n       var cookie = {};\n       var all = document.cookie;\n      if (all === '')\n           return cookie;\n       var list = all.split('; ');\n       for (var i = 0; i < list.length; i++) {\n           var item = list[i];\n           var p = item.indexOf('=');\n           var name = item.substring(0, p);\n           name = decodeURIComponent(name).trim();//注意这里有个坑，除了第一个name，后面的name前面都有一个空格，所以要处理掉前面的空格才行；\n           var value = item.substring(p + 1);\n           value = decodeURIComponent(value);\n           cookie[name] = value;\n       }\n       return cookie[Name];\n   }\n//用法：getCookie(\"loginSuc\");\n```\n***cookie的删除函数封装***\n```javascript\n    function removeCookie(name) { \n        var exp = new Date(); \n        exp.setTime(exp.getTime() - 1); \n        var cval=getCookie(name); \n        if(cval!=null) document.cookie= name + \"=\"+cval+\";expires=\"+exp.toGMTString(); \n    } \n```\n\n使用cookie我们可以设置用户的登录状态，亦或是点击了不再显示后就设置一个不再显示的cookie,通过获取cookie来达到效果。感觉棒棒哒！","slug":"好玩的cookie","published":1,"updated":"2016-01-06T12:05:50.405Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvxv000us8rkbt4mbl7w"},{"title":"垂直居中布局的几种css实现方法","date":"2015-11-20T02:17:50.000Z","_content":"\n在开发中经常会需要实现一些居中布局问题，今天来总结一下垂直居中布局的css实现方法。\n<!-- more -->\n### 任意高度的垂直居中布局\n\n#### 1.父元素tabel-cell +vertical-align\n此方法的优点：兼容性好，兼容ie8+。\n```html\n<style type=\"text/css\">\n    .parent{\n        <!-- 样式内容省略 -->\n        display: tabel-cell;\n        vertical-align:middle;\n    }\n    .child{\n        <!-- 样式内容省略 -->\n    }\n</style>\n<div class=\"parent\">\n    <div class=\"child\">DEMO</div>\n</div>\n```\n<textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: table-cell;vertical-align:middle;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n#### 2. absolute + transform\n优点：不会干扰其他元素  \n缺点：兼容性不好\n```html\n<style>\n    .parent{\n        <!-- 样式内容省略 -->\n        position:relative;\n    }\n    .child{\n        <!-- 样式内容省略 -->\n        position: absolute;\n        top: 50%;\n        transform: translateY(-50%);\n        \n    }\n</style>\n<div class=\"parent\">\n    <div class=\"child\">DEMO</div>\n</div>\n```\n<textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;line-height:100px;position: absolute;top: 50%;transform: translateY(-50%);}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n#### 3.flex+align-items\n优点：和第一种方法一样只需要对父元素设置 \n缺点：兼容性不好\n```html\n    <style type=\"text/css\">\n        .parent{\n            <!-- 样式内容省略 -->\n            display: flex;\n            align-items:center;\n        }\n        .child{\n            <!-- 样式内容省略 -->\n        }\n    </style>\n    <div class=\"parent\">\n        <div class=\"child\">DEMO</div>\n    </div>\n```\n<textarea id=\"runCode3\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: flex;align-items:center;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode3')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n### 固定高度的垂直居中布局\n这个用以上的方法也可以，不过我比较喜欢用负margin实现\n```html\n    <style>\n        .parent{\n            <!-- 样式内容省略 -->\n            position:relative;\n        }\n        .child{\n            <!-- 部分样式内容省略 -->\n            height:200px;\n            position: absolute;\n            top: 50%;\n            margin-top:-100px;\n        }\n    </style>\n    <div class=\"parent\">\n        <div class=\"child\">DEMO</div>\n    </div>\n```\n<textarea id=\"runCode4\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;height:200px;position: absolute;top: 50%; margin-top:-100px;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode4')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n总结了几种方法，各有利弊，还是那句话：具体情况具体分析~ \n\nps:增加了运行代码的功能 更好的代码功能还在研究当中。","source":"_posts/各种居中布局的css实现方法.md","raw":"title: 垂直居中布局的几种css实现方法\ndate: 2015-11-20 10:17:50\ntags: css学习心得\n---\n\n在开发中经常会需要实现一些居中布局问题，今天来总结一下垂直居中布局的css实现方法。\n<!-- more -->\n### 任意高度的垂直居中布局\n\n#### 1.父元素tabel-cell +vertical-align\n此方法的优点：兼容性好，兼容ie8+。\n```html\n<style type=\"text/css\">\n    .parent{\n        <!-- 样式内容省略 -->\n        display: tabel-cell;\n        vertical-align:middle;\n    }\n    .child{\n        <!-- 样式内容省略 -->\n    }\n</style>\n<div class=\"parent\">\n    <div class=\"child\">DEMO</div>\n</div>\n```\n<textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: table-cell;vertical-align:middle;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n#### 2. absolute + transform\n优点：不会干扰其他元素  \n缺点：兼容性不好\n```html\n<style>\n    .parent{\n        <!-- 样式内容省略 -->\n        position:relative;\n    }\n    .child{\n        <!-- 样式内容省略 -->\n        position: absolute;\n        top: 50%;\n        transform: translateY(-50%);\n        \n    }\n</style>\n<div class=\"parent\">\n    <div class=\"child\">DEMO</div>\n</div>\n```\n<textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;line-height:100px;position: absolute;top: 50%;transform: translateY(-50%);}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n#### 3.flex+align-items\n优点：和第一种方法一样只需要对父元素设置 \n缺点：兼容性不好\n```html\n    <style type=\"text/css\">\n        .parent{\n            <!-- 样式内容省略 -->\n            display: flex;\n            align-items:center;\n        }\n        .child{\n            <!-- 样式内容省略 -->\n        }\n    </style>\n    <div class=\"parent\">\n        <div class=\"child\">DEMO</div>\n    </div>\n```\n<textarea id=\"runCode3\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: flex;align-items:center;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode3')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n### 固定高度的垂直居中布局\n这个用以上的方法也可以，不过我比较喜欢用负margin实现\n```html\n    <style>\n        .parent{\n            <!-- 样式内容省略 -->\n            position:relative;\n        }\n        .child{\n            <!-- 部分样式内容省略 -->\n            height:200px;\n            position: absolute;\n            top: 50%;\n            margin-top:-100px;\n        }\n    </style>\n    <div class=\"parent\">\n        <div class=\"child\">DEMO</div>\n    </div>\n```\n<textarea id=\"runCode4\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;height:200px;position: absolute;top: 50%; margin-top:-100px;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode4')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n总结了几种方法，各有利弊，还是那句话：具体情况具体分析~ \n\nps:增加了运行代码的功能 更好的代码功能还在研究当中。","slug":"各种居中布局的css实现方法","published":1,"updated":"2016-01-06T13:47:05.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvy0000ws8rk9ipzy9id"},{"title":"前端知识收集","date":"2016-01-21T06:55:50.000Z","_content":"\n整理了一些自己比较感兴趣的前端知识比较好的博文或者网址\n<!--more-->\n1. [HTTP 协议中 URI 和 URL 有什么区别？](http://www.zhihu.com/question/21950864)\n2. [从输入 URL 到页面加载完成的过程中都发生了什么事情？](http://fex.baidu.com/blog/2014/05/what-happen/)\n3. [详解js跨域问题](http://segmentfault.com/a/1190000000718840)\n4. [浅析闭包和内存泄露的问题](http://www.cnblogs.com/yakun/p/3932026.html)\n5. [HTTP缓存相关头](http://www.cnblogs.com/yjf512/p/3244882.html)\n6. [从setTimeout谈JavaScript运行机制](http://web.jobbole.com/82631/)\n7. [JavaScript Promise迷你书（中文版）](http://liubin.github.io/promises-book/#introduction)\n8. [张宁：web前端？](http://dudu.zhihu.com/story/7117186?from=timeline&isappinstalled=0) \n9. [Code Guide by @AlloyTeam](http://alloyteam.github.io/CodeGuide/)\n10. [《React 和 Webpack 小书》](https://fakefish.github.io/react-webpack-cookbook/index.html)\n","source":"_posts/前端知识收集.md","raw":"title: 前端知识收集\ndate: 2016-01-21 14:55:50\ntag: web前端知识\n---\n\n整理了一些自己比较感兴趣的前端知识比较好的博文或者网址\n<!--more-->\n1. [HTTP 协议中 URI 和 URL 有什么区别？](http://www.zhihu.com/question/21950864)\n2. [从输入 URL 到页面加载完成的过程中都发生了什么事情？](http://fex.baidu.com/blog/2014/05/what-happen/)\n3. [详解js跨域问题](http://segmentfault.com/a/1190000000718840)\n4. [浅析闭包和内存泄露的问题](http://www.cnblogs.com/yakun/p/3932026.html)\n5. [HTTP缓存相关头](http://www.cnblogs.com/yjf512/p/3244882.html)\n6. [从setTimeout谈JavaScript运行机制](http://web.jobbole.com/82631/)\n7. [JavaScript Promise迷你书（中文版）](http://liubin.github.io/promises-book/#introduction)\n8. [张宁：web前端？](http://dudu.zhihu.com/story/7117186?from=timeline&isappinstalled=0) \n9. [Code Guide by @AlloyTeam](http://alloyteam.github.io/CodeGuide/)\n10. [《React 和 Webpack 小书》](https://fakefish.github.io/react-webpack-cookbook/index.html)\n","slug":"前端知识收集","published":1,"updated":"2016-07-04T07:09:21.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvyf000zs8rkc8dwlkyd"},{"title":"利用Fiddler进行前端调试","date":"2016-02-24T01:34:50.000Z","_content":"最近刚get了一个很方便前端调试的新技能，特别在已上线网页上修复bug的时候调试很实用，比如我在本地改了一个test1.js文件想要测试效果，但是又不想很麻烦地推到测试环境，就可以用这个工具把线上的test1.js文件请求到自己的本地test1.js文件，这样你的代码可以直接进行调试了。\n\n首先我们要用的工具是[Fiddler](http://www.telerik.com/fiddler)，这是一个强大的工具，在这里我就不详细介绍了，有兴趣的可以去了解一下[慕课网：Fiddler工具的使用](http://www.imooc.com/learn/37)。\n\n我们直接进入正题：利用Fiddler进行前端调试。\n\n打开软件，我们看到的是这样的界面：\n![软件界面](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/1.png)\n左边那些就是你的网络请求列表，右边是一些工具面板。\n\n我们以coolmogu.com为例，打开本网站，出现以下请求：\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/2.png)\n\n假如我们要修改index.js，在本地我们有一个index.js，具体步骤如下图\n\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/4.png)\n\n这样再刷新页面，实际coolmogu.com以后请求的index.js就是请求的你本地的Index.js了。假如我index.js里加了一行`alert(\"cky\")`, ![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/3.png) 看看效果：\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/5.png)\n\n很简单吧，还可以用同样的方法进行css文件调试等~\n\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/6.jpg)\n\n（本来之前用的图床，结果图床挂了- -，今天来修复图片。以后图片还是放在自己的github上吧）","source":"_posts/利用fiddler进行前端调试.md","raw":"title: 利用Fiddler进行前端调试\ndate: 2016-02-24 09:34:50\ntags: web前端知识\n\n---\n最近刚get了一个很方便前端调试的新技能，特别在已上线网页上修复bug的时候调试很实用，比如我在本地改了一个test1.js文件想要测试效果，但是又不想很麻烦地推到测试环境，就可以用这个工具把线上的test1.js文件请求到自己的本地test1.js文件，这样你的代码可以直接进行调试了。\n\n首先我们要用的工具是[Fiddler](http://www.telerik.com/fiddler)，这是一个强大的工具，在这里我就不详细介绍了，有兴趣的可以去了解一下[慕课网：Fiddler工具的使用](http://www.imooc.com/learn/37)。\n\n我们直接进入正题：利用Fiddler进行前端调试。\n\n打开软件，我们看到的是这样的界面：\n![软件界面](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/1.png)\n左边那些就是你的网络请求列表，右边是一些工具面板。\n\n我们以coolmogu.com为例，打开本网站，出现以下请求：\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/2.png)\n\n假如我们要修改index.js，在本地我们有一个index.js，具体步骤如下图\n\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/4.png)\n\n这样再刷新页面，实际coolmogu.com以后请求的index.js就是请求的你本地的Index.js了。假如我index.js里加了一行`alert(\"cky\")`, ![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/3.png) 看看效果：\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/5.png)\n\n很简单吧，还可以用同样的方法进行css文件调试等~\n\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/6.jpg)\n\n（本来之前用的图床，结果图床挂了- -，今天来修复图片。以后图片还是放在自己的github上吧）","slug":"利用fiddler进行前端调试","published":1,"updated":"2016-07-04T07:09:21.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvyj0011s8rka1bbdzfr"},{"title":"不是只有if和else","date":"2015-11-20T02:17:50.000Z","_content":"\n在我们写javascript函数的时候，经常会使用到条件判断，使用得最多的就是if else进行判断了。使用得多了渐渐会特别依赖这个最简单的方法，而导致整个函数里好多if else,甚至嵌套很多层。仔细研究，我们会发现用一大段if else的逻辑，其实用其他方法，一句话就能够完全实现同样的功能。\n\n#### 初级替代之一：三元表达式\n    var max = a>b?a:b;\n\n三元表达式的规则就是，当\"?\"前的表达式为true时，返回\":\"前的值，否则返回\":\"后的值。\n所以上面那句表达式等价于\n```javascript\nif(a>b){\n    max=a;\n}else{\n    max=b;\n}\n```\n#### 初级替代之二：switch\n\nswitch作为条件判断的方法之二，很明显可以替代一些简单但是重复的if else。实例\n\n```javascript\n    if(str==\"项链\"){//用if else\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }else{\n        type=\"人类\";\n    }\n```\n```javascript\n    switch(str){//switch\n        case \"项链\": type=\"珠宝\";\n        break;\n        case \"苹果\": type=\"水果\";\n        break;\n        case \"仙人掌\": type=\"植物\";\n        break;\n        default:\n        type==\"人类\";\n    }\n```\n但是看了上面的代码，肯定很多人会说，switch根本没有好到哪里去嘛，只是看上去稍微清晰了一点点。确实，所以我们有更简单的方法。\n\n#### 高级替代：对象字面量；\n    \n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = typeMap[str];\n\n上面两句话就完成了之前一大段的逻辑，不过还没有完全完成，因为有个默认值“人类”没有写进去。这个该怎么加进去呢？\n\n#### 还有“&&”和“||”\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = typeMap[str]||\"人类\";\n\n就这么两句话就完全实现了之前一大段逻辑判断的功能。不相信？可以试一试哦。\n```javascript\n    var type = typeMap[\"项链\"]||\"人类\";\n    console.log(type)// 珠宝\n\n    var type2 = typeMap[\"不认识\"]||\"人类\";\n    console.log(type2)// 人类\n```\n\n要了解这之中的原因，首先要了解“||”的机制。\n一般我们用“||”是用来进行布尔判断，前后都是布尔值，但是当其中一个不是布尔值时，它遵循以下原则:\n>- 如果第一个操作数是对象，则返回第一个操作数。\n- 如果第一个操作数的求值结果为false，则返回第二个操作数。\n- 如果两个操作数都是对象，则返回第一个操作数。\n- 如果两个操作数都是null，则返回null。\n- 如果两个操作数都是NaN，则返回NaN。\n- 如果两个操作数都是undefined，则返回undefined。\n\n而且这是短路操作符，也就是说，如果第一个操作数的结果为true，则不会对第二个操作数求值了。\n所以很多时候，我们也用“||” 来给变量定义默认值。如：`var a= str|| default`\n\n&&的用法和||正好相反，它的机制是：\n>- 如果第一个操作数是对象，则返回第二个操作数。\n- 如果第二个操作数是对象，且只有第一个操作数的求值结果为true，则返回第二个操作数。\n- 如果有一个操作数都是对象，则返回第一个操作数。\n- 如果有一个操作数都是null，则返回null。\n- 如果有一个操作数都是NaN，则返回NaN。\n- 如果有一个操作数都是undefined，则返回undefined。\n\n所以我们可以这么用\n```javascript\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = (year>1) && typeMap[str];\n```\n上面这段话等同于\n```javascript\nif(year>1){\n    if(str==\"项链\"){\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }\n}\n```\n然后我们还可以这样来\n```javascript\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = ((year>1) && typeMap[str]) || \"人类\";\n```\n这段话等同于\n```javascript\nif(year>1){\n    if(str==\"项链\"){\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }else{\n        type=\"人类\";\n    }\n}else{\n    type=\"人类\";\n}\n```\n卧槽，简直简便了好多对吧，不过为了维护性，还是不建议同时使用多个\"&&\" \"||\"，因为多了阅读起来就和阅读正则一样困难了。\n\n\n讲了以上几个方法，至于到底要怎么做，还是要具体情况具体分析啦。","source":"_posts/不是只有“if else”.md","raw":"title: 不是只有if和else\ndate: 2015-11-20 10:17:50\ntags: Javascript学习笔记\n---\n\n在我们写javascript函数的时候，经常会使用到条件判断，使用得最多的就是if else进行判断了。使用得多了渐渐会特别依赖这个最简单的方法，而导致整个函数里好多if else,甚至嵌套很多层。仔细研究，我们会发现用一大段if else的逻辑，其实用其他方法，一句话就能够完全实现同样的功能。\n\n#### 初级替代之一：三元表达式\n    var max = a>b?a:b;\n\n三元表达式的规则就是，当\"?\"前的表达式为true时，返回\":\"前的值，否则返回\":\"后的值。\n所以上面那句表达式等价于\n```javascript\nif(a>b){\n    max=a;\n}else{\n    max=b;\n}\n```\n#### 初级替代之二：switch\n\nswitch作为条件判断的方法之二，很明显可以替代一些简单但是重复的if else。实例\n\n```javascript\n    if(str==\"项链\"){//用if else\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }else{\n        type=\"人类\";\n    }\n```\n```javascript\n    switch(str){//switch\n        case \"项链\": type=\"珠宝\";\n        break;\n        case \"苹果\": type=\"水果\";\n        break;\n        case \"仙人掌\": type=\"植物\";\n        break;\n        default:\n        type==\"人类\";\n    }\n```\n但是看了上面的代码，肯定很多人会说，switch根本没有好到哪里去嘛，只是看上去稍微清晰了一点点。确实，所以我们有更简单的方法。\n\n#### 高级替代：对象字面量；\n    \n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = typeMap[str];\n\n上面两句话就完成了之前一大段的逻辑，不过还没有完全完成，因为有个默认值“人类”没有写进去。这个该怎么加进去呢？\n\n#### 还有“&&”和“||”\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = typeMap[str]||\"人类\";\n\n就这么两句话就完全实现了之前一大段逻辑判断的功能。不相信？可以试一试哦。\n```javascript\n    var type = typeMap[\"项链\"]||\"人类\";\n    console.log(type)// 珠宝\n\n    var type2 = typeMap[\"不认识\"]||\"人类\";\n    console.log(type2)// 人类\n```\n\n要了解这之中的原因，首先要了解“||”的机制。\n一般我们用“||”是用来进行布尔判断，前后都是布尔值，但是当其中一个不是布尔值时，它遵循以下原则:\n>- 如果第一个操作数是对象，则返回第一个操作数。\n- 如果第一个操作数的求值结果为false，则返回第二个操作数。\n- 如果两个操作数都是对象，则返回第一个操作数。\n- 如果两个操作数都是null，则返回null。\n- 如果两个操作数都是NaN，则返回NaN。\n- 如果两个操作数都是undefined，则返回undefined。\n\n而且这是短路操作符，也就是说，如果第一个操作数的结果为true，则不会对第二个操作数求值了。\n所以很多时候，我们也用“||” 来给变量定义默认值。如：`var a= str|| default`\n\n&&的用法和||正好相反，它的机制是：\n>- 如果第一个操作数是对象，则返回第二个操作数。\n- 如果第二个操作数是对象，且只有第一个操作数的求值结果为true，则返回第二个操作数。\n- 如果有一个操作数都是对象，则返回第一个操作数。\n- 如果有一个操作数都是null，则返回null。\n- 如果有一个操作数都是NaN，则返回NaN。\n- 如果有一个操作数都是undefined，则返回undefined。\n\n所以我们可以这么用\n```javascript\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = (year>1) && typeMap[str];\n```\n上面这段话等同于\n```javascript\nif(year>1){\n    if(str==\"项链\"){\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }\n}\n```\n然后我们还可以这样来\n```javascript\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = ((year>1) && typeMap[str]) || \"人类\";\n```\n这段话等同于\n```javascript\nif(year>1){\n    if(str==\"项链\"){\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }else{\n        type=\"人类\";\n    }\n}else{\n    type=\"人类\";\n}\n```\n卧槽，简直简便了好多对吧，不过为了维护性，还是不建议同时使用多个\"&&\" \"||\"，因为多了阅读起来就和阅读正则一样困难了。\n\n\n讲了以上几个方法，至于到底要怎么做，还是要具体情况具体分析啦。","slug":"不是只有“if else”","published":1,"updated":"2016-01-06T13:46:17.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvym0013s8rk0775bmad"},{"title":"node.js学习笔记(九)——Express框架入门介绍","date":"2016-01-06T13:56:50.000Z","_content":"### 一、为什么要用Express框架？\nNode.js由于不需要另外的HTTP服务器，因此减少了一层抽象，给性能带来不少的提升，同时也因此提高了开发难度，实现一个POST数据的表单。例如：\n```html\n<form>\n\t<input type=\"text\" name=\"title\"/>\n\t<input type=\"submit\"/>\n</form>\n```\nPHP中获取POST请求参数可以直接用 `$_POST('title');`\nJAVA语言也可以用`request.getParameter('title')`；\n而Node中获取就比较麻烦了，前几篇文章的例子中可以看到。\nnode.js虽然提供了HTTP模块，却不是让你直接用这个模块进行web开发的。http模块仅仅是一个HTTP服务器内核的封装。\n使用express实现上述案例：\n```javascript\nvar express = require('express');\nvar app = express.createServer();\napp.use(express.bodyParser());\napp.all('/',function(req,res){\n\tres.send(req.body.title);\n});\napp.listen(3000);\n```\n### 二、Express框架\nnpm提供了大量的第三方模块，其中不乏许多Web框架，我们没有必要重复造轮子，因此我们选择Express作为开发框架。\n其提供了更高层的接口外，还实现了许多功能，如：\n路由控制、模板解析支持、动态视图、用户会话、CSRF保护、静态文件服务、错误控制器、访问日志、缓存、插件支持等。\n\n### 三、安装Express\n`npm install -g express`\n安装完成之后使用`express -help` 检测是否安装成功\n如果报错express不是一个命令， 则执行`npm install -g express-generator`即可\nExpress在初始化一个项目的时候需要指定模板引擎，模式支持jade和ejs，为了降低学习难度，建议使用ejs。\n\n### 四、建立工程\nexpress -e pcat\n当前目录出现了子目录pcat并产生了一些文件：\n![](http://i4.tietuku.com/724f4057ebf5adfc.png)\n提示我们进入pcat目录执行npm install命令\n无参数的npm install命令会检查当前目录下的package.json并自动安装所有指定的依赖。\n\n### 五、启动服务器\nwindow环境下：\n执行`set DEBUG=pcat`\n再执行`npm start`\n访问localhost:3000即可访问。\n\n更多介绍见[express官网](http://www.expressjs.com.cn/)","source":"_posts/nodeJsStudy9.md","raw":"title: node.js学习笔记(九)——Express框架入门介绍\ndate: 2016-01-06 21:56:50\ntags: node.js学习笔记\n---\n### 一、为什么要用Express框架？\nNode.js由于不需要另外的HTTP服务器，因此减少了一层抽象，给性能带来不少的提升，同时也因此提高了开发难度，实现一个POST数据的表单。例如：\n```html\n<form>\n\t<input type=\"text\" name=\"title\"/>\n\t<input type=\"submit\"/>\n</form>\n```\nPHP中获取POST请求参数可以直接用 `$_POST('title');`\nJAVA语言也可以用`request.getParameter('title')`；\n而Node中获取就比较麻烦了，前几篇文章的例子中可以看到。\nnode.js虽然提供了HTTP模块，却不是让你直接用这个模块进行web开发的。http模块仅仅是一个HTTP服务器内核的封装。\n使用express实现上述案例：\n```javascript\nvar express = require('express');\nvar app = express.createServer();\napp.use(express.bodyParser());\napp.all('/',function(req,res){\n\tres.send(req.body.title);\n});\napp.listen(3000);\n```\n### 二、Express框架\nnpm提供了大量的第三方模块，其中不乏许多Web框架，我们没有必要重复造轮子，因此我们选择Express作为开发框架。\n其提供了更高层的接口外，还实现了许多功能，如：\n路由控制、模板解析支持、动态视图、用户会话、CSRF保护、静态文件服务、错误控制器、访问日志、缓存、插件支持等。\n\n### 三、安装Express\n`npm install -g express`\n安装完成之后使用`express -help` 检测是否安装成功\n如果报错express不是一个命令， 则执行`npm install -g express-generator`即可\nExpress在初始化一个项目的时候需要指定模板引擎，模式支持jade和ejs，为了降低学习难度，建议使用ejs。\n\n### 四、建立工程\nexpress -e pcat\n当前目录出现了子目录pcat并产生了一些文件：\n![](http://i4.tietuku.com/724f4057ebf5adfc.png)\n提示我们进入pcat目录执行npm install命令\n无参数的npm install命令会检查当前目录下的package.json并自动安装所有指定的依赖。\n\n### 五、启动服务器\nwindow环境下：\n执行`set DEBUG=pcat`\n再执行`npm start`\n访问localhost:3000即可访问。\n\n更多介绍见[express官网](http://www.expressjs.com.cn/)","slug":"nodeJsStudy9","published":1,"updated":"2016-01-06T15:00:07.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvyo0015s8rkc9nabp4v"},{"title":"node.js学习笔记(八)——HTTP客户端","date":"2016-01-06T02:19:50.000Z","_content":"### 一、http模块提供了两个函数http.request和http.get。\n功能是作为客户端向HTTP服务器发起请求。\n#### 1. http.request(options,callback)\nhttp.request发起HTTP请求，接受两个参数，option是一个类似关联数组的对象，表示请求的参数，callback是请求的回调函数，option常用的参数如下：\n\n|参数 |含义|\n|------|-----|\n|host |请求网站的域名或IP地址|\n|port |请求网站的端口，默认是80|\n|method |请求方法，比如GET、POST|\n|path|请求的相对于根的路径，默认是\"/\"。QueryString应该包含在其中，例如/search?query=cky|\n|header |一个关联数组对象，为请求头的内容|\ncallback传递一个参数，为http.ClientResponse的实例。\nhttp.request返回一个http.ClientRequest的实例。\n\n例：\n```javascript\n//clientRequest.js\nvar http = require('http');\nvar querystring = require('querystring');\n//启动服务\nhttp.createServer(function(req,res){\n\tconsole.log('请求到了，解析参数');\n\tvar post = '';\n\treq.on('data',function(chunk){\n\t\tpost+=chunk;\n\t});\n\treq.on('end',function(){\n\t\tpost = querystring.parse(post);\n\t\t//解析完成\n\t\tconsole.log(\"参数解析完成，返回给客户端name参数\");\n\t\tres.end(post.address);\n\t});\n}).listen(3000);\n\n//客户端请求\nvar contents = querystring.stringify({//将JSON对象转换成JSON字符串\n\tname:'cky',\n\tage:21,\n\taddress:'重庆'\n});\nvar options = {\n\thost:'localhost',\n\tpath:'/',\n\tport:3000,\n\tmethod:'POST',\n\theaders:{\n\t\t'Content-Type':'application/x-www-form-urlencoded',\n\t\t'Content-Length':contents.length\n\t}\n}\n//发送请求\nvar req = http.request(options,function(res){\n\tres.setEncoding('utf-8');\n\tres.on('data',function(data){\n\t\tconsole.log('后端返回数据');\n\t\tconsole.log(data);\n\t});\n});\nreq.write(contents);\n//必须调end()\nreq.end();\n```\n执行结果：\n```javascript\n请求到了，解析参数\n参数解析完成，返回给客户端name参数\n后端返回数据\ncky\n```\n#### 2. http.get(options,callback)\n http模块还提供了一个更加简便的方法——http.get。它是http.request的简化版，唯一的区别在于http.get自动将请求方法设为GET请求，同时不需要手动调用req.end()；\n\n 例：\n ```javascript\n//clientGet.js\nvar http = require('http');\nvar url = require('url');\nvar util = require('util');\n//启动服务\nhttp.createServer(function(req,res){\n\tconsole.log('请求到了，解析参数');\n\tvar params = url.parse(req.url,true);\n\tconsole.log('解析完成');\n\tconsole.log(util.inspect(params));\n\tconsole.log('向客户端返回');\n\tres.end(params.query.name);\n}).listen(3000);\n\n//客户端请求\nhttp.get({\n\t'host':'localhost',\n\tpath:'/user?name=cky&age=21',\n\tport:3000},function(res){\n\t\tres.setEncoding('utf-8');\n\t\tres.on('data',function(data){\n\t\t\tconsole.log('服务器端返回来的是：'+ data);\n\t\t});\n\t}\n);\n\n ```\n 执行结果：\n ```javascript\n请求到了，解析参数\n解析完成\nUrl {\n  protocol: null,\n  slashes: null,\n  auth: null,\n  host: null,\n  port: null,\n  hostname: null,\n  hash: null,\n  search: '?name=cky&age=21\n  query: { name: 'cky', age\n  pathname: '/user',\n  path: '/user?name=cky&age\n  href: '/user?name=cky&age\n向客户端返回\n服务器端返回来的是：cky\n ```\n ### 二、http.ClientRequest\n 该对象是由`http.request`或`http.get`返回产生的对象，表示一个已经产生而且正在进行的http请求，它提供了response事件，即`http.request`或`http.get`第二个参数指定的回调函数的绑定对象，__请求必须调用end方法结束请求__\n 提供的函数：\n `request.abort()` 终止正在发送的请求\n `request.setTimeOut(time,[callback])`设置请求超时事件。\n 更多请参考 ：[api文档](http://nodeapi.ucdok.com/#/api/http.html)\n\n ### 三、http.ClientResponse\n`http.ClientResponse`是与`http.Response`相似，提供三个事件，data、end和close，分别在数据到达、传输结束、连接结束时触发。其中data事件传递一个参数chunk，表示接受到的数据。\n res的属性（表示请求的结果状态）：\n\n||\n|-|\n|statusCode|http状态码|\n|httpVersion|http协议版本|\n|headers|HTTP请求头|\n|trailers|HTTP请求尾|\n\nres函数：\n`response.setEncoding([encoding]):`设置默认的编码，当data事件被触发时，数据将以encoding编码，默认为null,以buffer形式储存。\n`response.parse()`:暂停接收数据和发送事件，方便实现下载功能\n`renspose.resume()`:以暂停状态恢复。","source":"_posts/nodeJsStudy8.md","raw":"title: node.js学习笔记(八)——HTTP客户端\ndate: 2016-01-06 10:19:50\ntags: node.js学习笔记\n---\n### 一、http模块提供了两个函数http.request和http.get。\n功能是作为客户端向HTTP服务器发起请求。\n#### 1. http.request(options,callback)\nhttp.request发起HTTP请求，接受两个参数，option是一个类似关联数组的对象，表示请求的参数，callback是请求的回调函数，option常用的参数如下：\n\n|参数 |含义|\n|------|-----|\n|host |请求网站的域名或IP地址|\n|port |请求网站的端口，默认是80|\n|method |请求方法，比如GET、POST|\n|path|请求的相对于根的路径，默认是\"/\"。QueryString应该包含在其中，例如/search?query=cky|\n|header |一个关联数组对象，为请求头的内容|\ncallback传递一个参数，为http.ClientResponse的实例。\nhttp.request返回一个http.ClientRequest的实例。\n\n例：\n```javascript\n//clientRequest.js\nvar http = require('http');\nvar querystring = require('querystring');\n//启动服务\nhttp.createServer(function(req,res){\n\tconsole.log('请求到了，解析参数');\n\tvar post = '';\n\treq.on('data',function(chunk){\n\t\tpost+=chunk;\n\t});\n\treq.on('end',function(){\n\t\tpost = querystring.parse(post);\n\t\t//解析完成\n\t\tconsole.log(\"参数解析完成，返回给客户端name参数\");\n\t\tres.end(post.address);\n\t});\n}).listen(3000);\n\n//客户端请求\nvar contents = querystring.stringify({//将JSON对象转换成JSON字符串\n\tname:'cky',\n\tage:21,\n\taddress:'重庆'\n});\nvar options = {\n\thost:'localhost',\n\tpath:'/',\n\tport:3000,\n\tmethod:'POST',\n\theaders:{\n\t\t'Content-Type':'application/x-www-form-urlencoded',\n\t\t'Content-Length':contents.length\n\t}\n}\n//发送请求\nvar req = http.request(options,function(res){\n\tres.setEncoding('utf-8');\n\tres.on('data',function(data){\n\t\tconsole.log('后端返回数据');\n\t\tconsole.log(data);\n\t});\n});\nreq.write(contents);\n//必须调end()\nreq.end();\n```\n执行结果：\n```javascript\n请求到了，解析参数\n参数解析完成，返回给客户端name参数\n后端返回数据\ncky\n```\n#### 2. http.get(options,callback)\n http模块还提供了一个更加简便的方法——http.get。它是http.request的简化版，唯一的区别在于http.get自动将请求方法设为GET请求，同时不需要手动调用req.end()；\n\n 例：\n ```javascript\n//clientGet.js\nvar http = require('http');\nvar url = require('url');\nvar util = require('util');\n//启动服务\nhttp.createServer(function(req,res){\n\tconsole.log('请求到了，解析参数');\n\tvar params = url.parse(req.url,true);\n\tconsole.log('解析完成');\n\tconsole.log(util.inspect(params));\n\tconsole.log('向客户端返回');\n\tres.end(params.query.name);\n}).listen(3000);\n\n//客户端请求\nhttp.get({\n\t'host':'localhost',\n\tpath:'/user?name=cky&age=21',\n\tport:3000},function(res){\n\t\tres.setEncoding('utf-8');\n\t\tres.on('data',function(data){\n\t\t\tconsole.log('服务器端返回来的是：'+ data);\n\t\t});\n\t}\n);\n\n ```\n 执行结果：\n ```javascript\n请求到了，解析参数\n解析完成\nUrl {\n  protocol: null,\n  slashes: null,\n  auth: null,\n  host: null,\n  port: null,\n  hostname: null,\n  hash: null,\n  search: '?name=cky&age=21\n  query: { name: 'cky', age\n  pathname: '/user',\n  path: '/user?name=cky&age\n  href: '/user?name=cky&age\n向客户端返回\n服务器端返回来的是：cky\n ```\n ### 二、http.ClientRequest\n 该对象是由`http.request`或`http.get`返回产生的对象，表示一个已经产生而且正在进行的http请求，它提供了response事件，即`http.request`或`http.get`第二个参数指定的回调函数的绑定对象，__请求必须调用end方法结束请求__\n 提供的函数：\n `request.abort()` 终止正在发送的请求\n `request.setTimeOut(time,[callback])`设置请求超时事件。\n 更多请参考 ：[api文档](http://nodeapi.ucdok.com/#/api/http.html)\n\n ### 三、http.ClientResponse\n`http.ClientResponse`是与`http.Response`相似，提供三个事件，data、end和close，分别在数据到达、传输结束、连接结束时触发。其中data事件传递一个参数chunk，表示接受到的数据。\n res的属性（表示请求的结果状态）：\n\n||\n|-|\n|statusCode|http状态码|\n|httpVersion|http协议版本|\n|headers|HTTP请求头|\n|trailers|HTTP请求尾|\n\nres函数：\n`response.setEncoding([encoding]):`设置默认的编码，当data事件被触发时，数据将以encoding编码，默认为null,以buffer形式储存。\n`response.parse()`:暂停接收数据和发送事件，方便实现下载功能\n`renspose.resume()`:以暂停状态恢复。","slug":"nodeJsStudy8","published":1,"updated":"2016-01-06T13:51:20.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvyr0018s8rk3k6iah6s"},{"title":"node.js学习笔记(七)——HTTP服务器","date":"2016-01-06T02:17:50.000Z","_content":"node.js提供了http模块。其中封装了一个高效的HTTP服务器和一个简易的HTTP客户端。\nhttp.server是一个基于事件的HTTP服务器。内部有C++实现。接口由javascript封装。\nhttp.request则是一个HTTP客户端工具。用户向服务器发送请求。\n<!-- more -->\n### 一、HTTP服务器\nhttp.Server实现的，它提供了一套封装级别很低的API，仅仅是流控制和简单的解析，所有的高层功能都要通过它的接口。\n例：\n```javascript\n//引入模块\nvar http = require('http');\n//创建服务\nhttp.createServer(function(req,res){\n    //响应头\n    res.writeHead(200,{'Content-Type':'text/html'});\n    //响应内容\n    res.write(\"<h1>Node.wqewqewqjs</h1>\");\n    //结束响应\n    res.end('<p>PCAT</p>');\n//监听端口\n}).listen('3000');\nconsole.log('HTTP server is listening at port 3000');\n```\n执行后访问结果：\n![](http://i4.tietuku.com/7ef205ca829b96f0.png)\n\n代码分析：\nhttp.creatServer()创建了一个http.Server的实例，将一个函数作为HTTP请求处理函数。这个函数接受两个参数，请求对象req和响应对象res。res显式地写入了响应代码200（表示请求成功），指定响应头，写入响应体，调用end结束并发送。该实例调用listen函数，启动服务器并监听3000端口。\n#### 1.http.server事件\nhttp.server是一个基于事件的HTTP服务器，所有请求都被封装成独立的事件，开发者只要对它的事件编写相应的函数即可实现HTTP服务器的所有功能，它继承于EventEmitter，提供了以下事件：\n**request**：当客户端请求到来时，该事件被触发，提供两个参数req和res，分别是http.ServerRequest和http.ServerResponse的实例，表示请求和响应信息。\n例：\n在上面代码的`http.creatServer()`回调函数中，加入一句`console.log(req.url);`\n当在浏览器中输入路径`http://localhost:3000/user?name=cky`时。\n结果：\n![](http://i4.tietuku.com/3316acda98d8a698.jpg)\n**connection**：当TCP连接建立时，该事件被触发，提供了一个参数socket，为net.Socket的实例（底层协议对象）。\n**close**：当服务器关闭时，该事件被触发。\n最常用和关心的是：request事件，http提供了一个捷径：http.createServer()方法。不需要原生创建。\n原生创建方法：\n```javascript\nvar http = require('http');\nvar server = new http.Server();\nserver.on('request',function(req,res){\n    res.writeHead(200,{'Content-Type':'text/html'});\n    res.write(\"<h1>Node.wqewqewqjs</h1>\");\n    res.end('<p>PCAT</p>');\n});\nserver.listen('3000')\n```\n更多详细内容，见[api文档](http://nodeapi.ucdok.com/#/api/http.html);\n\n#### 2.http.ServerRequest，请求的信息\n此对象是后端开发者最关注的内容，它一般由http.Server的request事件发送，作为第一个参数传递，通常简写成request或req。HTTP请求分为两部分：请求头和请求体。请求内容短的直接在请求头解析完成后立即读取，而请求体可能相对较长，需要一定时间传输，因此提供了三个时间用于控制请求体传输。\n- data:当请求体数据到来时，该事件被触发，该事件有一个参数chunk,表示接收到的数据。\n- end：当请求体数据传输完成时，该事件被触发，伺候将不会再有数据到来，\n- close: 用户当前请求结束时，该事件被触发，不同于end，如果用户强制终止了传输，也会触发close。\n\n__ServerRequest的属性：__\n\n| 属性       | 含义           |\n| ---------|-------------| \n| complete  | 客户端请求是否已经发送完成 | \n| httpVersion | HTTP协议版本，通常是1.0或1.1 |\n| method  | HTTP请求方法，如GET,POST |\n| url | 原始的请求路径 | \n| headers | HTTP请求头 |\n| trailers| HTTP请求尾（不常见） |\n| connection | 当前HTTP连接套接字，为net.Socket的实例 | \n| socket | connection属性的别名 |\n| client| client属性的别名 |\n\n#### 3.获取GET请求内容\n由于GET请求直接被嵌入在路径中，URL完成的请求路径，包括了？后面的部分，因此你可以手动解析。node.js的url模块中的parse函数也提供了这个功能。\n例：\n```javascript\n//引入模块\nvar http = require('http');\nvar urls = require('url');\nvar util = require('util');\n//创建服务\nhttp.createServer(function(req,res){\n    res.writeHead(2000,{'Content-Type':'text/plain'});\n    //解析并打成字符串返回给客户端\n    res.end(util.inspect(urls.parse(req.url,true)));\n}).listen(3000);\n```\n执行结果：\n![](http://i4.tietuku.com/6703100aee0d87f1.jpg)\n\n#### 4.获取POST请求的内容\nPOST请求的内容全部都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。譬如上传文件。恶意的POST请求会大大消耗服务器的资源。所以Node.js是不会解析请求体，当你需要的时候，需要手动来做。\n例：\n```javascript\nvar http = require('http');\nvar querystring = require('querystring');\nvar util = require('util');\nhttp.createServer(function(req,res){\n    var post = '';\n    //注册data事件监听函数，每当接收请求体的数据\n    req.on('data',function(chunk){\n        post+=chunk;\n    });\n    req.on('end',function(){\n        //将字符串解析为一个JSON对象\n        post = querystring.parse(post);\n        //向前端返回\n        res.end(util.inspect(post));\n    });\n}).listen(3000);\n```\n\n#### 5.http.serverResponse，返回给客户端的信息\n决定了用户最终得到的结果，它是由http.Server的request事件发送的，作为第二个参数传递。一般为response或res。\n主要的三个函数：\n- response.writeHead(statusCode,[headers]);向请求的客户端发送响应头。\n    - statusCode是HTTP状态码，如200位成功，404为未找到等。\n    - headers是一个类似关联数组的对象，表示响应头的每个属性。\n- response.write(data,[encoding])向请求客户端发送相应的内容，data是buffer或字符串，encoding为编码。\n- response.end([data],[encoding])结束响应，告知用户所有发送已经完成，当所有要返回的内容发送完毕，该函数必须被调用一次，如果不调用，客户端永远处于等待状态。","source":"_posts/nodeJsStudy7.md","raw":"title: node.js学习笔记(七)——HTTP服务器\ndate: 2016-01-06 10:17:50\ntags: node.js学习笔记\n---\nnode.js提供了http模块。其中封装了一个高效的HTTP服务器和一个简易的HTTP客户端。\nhttp.server是一个基于事件的HTTP服务器。内部有C++实现。接口由javascript封装。\nhttp.request则是一个HTTP客户端工具。用户向服务器发送请求。\n<!-- more -->\n### 一、HTTP服务器\nhttp.Server实现的，它提供了一套封装级别很低的API，仅仅是流控制和简单的解析，所有的高层功能都要通过它的接口。\n例：\n```javascript\n//引入模块\nvar http = require('http');\n//创建服务\nhttp.createServer(function(req,res){\n    //响应头\n    res.writeHead(200,{'Content-Type':'text/html'});\n    //响应内容\n    res.write(\"<h1>Node.wqewqewqjs</h1>\");\n    //结束响应\n    res.end('<p>PCAT</p>');\n//监听端口\n}).listen('3000');\nconsole.log('HTTP server is listening at port 3000');\n```\n执行后访问结果：\n![](http://i4.tietuku.com/7ef205ca829b96f0.png)\n\n代码分析：\nhttp.creatServer()创建了一个http.Server的实例，将一个函数作为HTTP请求处理函数。这个函数接受两个参数，请求对象req和响应对象res。res显式地写入了响应代码200（表示请求成功），指定响应头，写入响应体，调用end结束并发送。该实例调用listen函数，启动服务器并监听3000端口。\n#### 1.http.server事件\nhttp.server是一个基于事件的HTTP服务器，所有请求都被封装成独立的事件，开发者只要对它的事件编写相应的函数即可实现HTTP服务器的所有功能，它继承于EventEmitter，提供了以下事件：\n**request**：当客户端请求到来时，该事件被触发，提供两个参数req和res，分别是http.ServerRequest和http.ServerResponse的实例，表示请求和响应信息。\n例：\n在上面代码的`http.creatServer()`回调函数中，加入一句`console.log(req.url);`\n当在浏览器中输入路径`http://localhost:3000/user?name=cky`时。\n结果：\n![](http://i4.tietuku.com/3316acda98d8a698.jpg)\n**connection**：当TCP连接建立时，该事件被触发，提供了一个参数socket，为net.Socket的实例（底层协议对象）。\n**close**：当服务器关闭时，该事件被触发。\n最常用和关心的是：request事件，http提供了一个捷径：http.createServer()方法。不需要原生创建。\n原生创建方法：\n```javascript\nvar http = require('http');\nvar server = new http.Server();\nserver.on('request',function(req,res){\n    res.writeHead(200,{'Content-Type':'text/html'});\n    res.write(\"<h1>Node.wqewqewqjs</h1>\");\n    res.end('<p>PCAT</p>');\n});\nserver.listen('3000')\n```\n更多详细内容，见[api文档](http://nodeapi.ucdok.com/#/api/http.html);\n\n#### 2.http.ServerRequest，请求的信息\n此对象是后端开发者最关注的内容，它一般由http.Server的request事件发送，作为第一个参数传递，通常简写成request或req。HTTP请求分为两部分：请求头和请求体。请求内容短的直接在请求头解析完成后立即读取，而请求体可能相对较长，需要一定时间传输，因此提供了三个时间用于控制请求体传输。\n- data:当请求体数据到来时，该事件被触发，该事件有一个参数chunk,表示接收到的数据。\n- end：当请求体数据传输完成时，该事件被触发，伺候将不会再有数据到来，\n- close: 用户当前请求结束时，该事件被触发，不同于end，如果用户强制终止了传输，也会触发close。\n\n__ServerRequest的属性：__\n\n| 属性       | 含义           |\n| ---------|-------------| \n| complete  | 客户端请求是否已经发送完成 | \n| httpVersion | HTTP协议版本，通常是1.0或1.1 |\n| method  | HTTP请求方法，如GET,POST |\n| url | 原始的请求路径 | \n| headers | HTTP请求头 |\n| trailers| HTTP请求尾（不常见） |\n| connection | 当前HTTP连接套接字，为net.Socket的实例 | \n| socket | connection属性的别名 |\n| client| client属性的别名 |\n\n#### 3.获取GET请求内容\n由于GET请求直接被嵌入在路径中，URL完成的请求路径，包括了？后面的部分，因此你可以手动解析。node.js的url模块中的parse函数也提供了这个功能。\n例：\n```javascript\n//引入模块\nvar http = require('http');\nvar urls = require('url');\nvar util = require('util');\n//创建服务\nhttp.createServer(function(req,res){\n    res.writeHead(2000,{'Content-Type':'text/plain'});\n    //解析并打成字符串返回给客户端\n    res.end(util.inspect(urls.parse(req.url,true)));\n}).listen(3000);\n```\n执行结果：\n![](http://i4.tietuku.com/6703100aee0d87f1.jpg)\n\n#### 4.获取POST请求的内容\nPOST请求的内容全部都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。譬如上传文件。恶意的POST请求会大大消耗服务器的资源。所以Node.js是不会解析请求体，当你需要的时候，需要手动来做。\n例：\n```javascript\nvar http = require('http');\nvar querystring = require('querystring');\nvar util = require('util');\nhttp.createServer(function(req,res){\n    var post = '';\n    //注册data事件监听函数，每当接收请求体的数据\n    req.on('data',function(chunk){\n        post+=chunk;\n    });\n    req.on('end',function(){\n        //将字符串解析为一个JSON对象\n        post = querystring.parse(post);\n        //向前端返回\n        res.end(util.inspect(post));\n    });\n}).listen(3000);\n```\n\n#### 5.http.serverResponse，返回给客户端的信息\n决定了用户最终得到的结果，它是由http.Server的request事件发送的，作为第二个参数传递。一般为response或res。\n主要的三个函数：\n- response.writeHead(statusCode,[headers]);向请求的客户端发送响应头。\n    - statusCode是HTTP状态码，如200位成功，404为未找到等。\n    - headers是一个类似关联数组的对象，表示响应头的每个属性。\n- response.write(data,[encoding])向请求客户端发送相应的内容，data是buffer或字符串，encoding为编码。\n- response.end([data],[encoding])结束响应，告知用户所有发送已经完成，当所有要返回的内容发送完毕，该函数必须被调用一次，如果不调用，客户端永远处于等待状态。","slug":"nodeJsStudy7","published":1,"updated":"2016-01-06T13:51:09.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvyv001as8rkarde1dcx"},{"title":"node.js学习笔记(六)——文件操作","date":"2016-01-04T02:18:50.000Z","_content":"fs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接POSIX文件系统操作。与其他模块不同的是，*fs模块中的所有操作都提供了异步和同步两个版本，*例如读取文件内容函数的异步方法：readFile(),同步方法readFileSync()。\n<!-- more -->\n#### 一、`fs.readFile(filename,[encoding],[callback(err,data)])`是最简单的读取文件函数。\n参数：\nfilename：读取的文件名。\nencoding：文件的字符编码。 \ncallback 回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。如果指定了encoding，data是一个解析后的字符串，否则将会以buffer形式表示的二进制数据。\n例1：\n```javascript\n//异步读取文件\n//file.txt内容为\"哈哈哈\"\nvar fs = require('fs');\nfs.readFile('file.txt','utf-8',function(err,data){\n    if(err){\n        console.log(err);\n    }else{\n        console.log(data);\n    }\n});\nconsole.log('end');\n```\n执行结果：\n```javascript\nend\n哈哈哈\n```\n#### 二、fs.readFileSync(filename,[encoding])\n同步读取文件接受的参数和fs.readFile()相同，而读取到的文件内容会以函数返回值的形式返回，如果有错误发生，fs将抛出异常，你需要try和catch捕获并处理异常。\n例2；\n```javascript\n//同步读取文件\nvar fs = require('fs');\ntry{\n    var data = fs.readFileSync('file1.txt','utf-8');\n    console.log(data);\n    console.log('end');\n}catch(e){\n    console.log(e);\n}\n\n```\n执行结果：\n```javascript\n哈哈哈\nend\n```\n#### 三、fs.open(path,flags,[mode],[callback(err,fd)])\n是POSIXopen函数的封装，与C语言标准库中的fopen函数类似，它接受两个必选参数。\npath为文件路径，\nflag可以为以下值：\n\n| 值       | 作用           |\n| ---------|-------------| \n| r  | 以只读模式打开文件 | \n| r+ | 以读写模式打开文件 |\n| w  | 以写入模式打开文件，如果文件不存在则创建 |\n| w+ | 以读写模式打开文件，如果文件不存在则创建 | \n| a  | 以追加模式打开文件，如果文件不存在则创建 |\n| a+ | 以读取追加模式打开文件，如果文件不存在则创建 |\n\nmode:用于创建文件时给文件指定权限，默认是0666，回调函数将会传递一个文件描述符fd。\n0666:文件权限值POSIX系统中对文件读取和访问权限的范围，通常用八进制数表示。0754表示文件所有者权限是7（读、写、执行），同组用户权限是5（读、执行），其他用户的权限是4（读）。\nfd:文件描述是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引。\n\n#### 四、fs.read(fd,buffer,offset,length,position,[callback(err,bytesRead,buffer)])\n是POSIX中read函数的封装，相比readFild()提供了更底层的接口，从指定的文件描述fd中读取数据并写入。\nfd:指定的文件描述\nbuffer:指向的缓存区对象，\noffset:是buffer的写入偏量值\nlength:读取的字节数\nposition:文件读取的起始数，如果为null，则从当前文件指针读取。\n回调函数传递err,bytesRead和buffer，分别表示读取的字节数和缓冲区对象。\n例：\n```javascript\nvar fs = require('fs');\nfs.open('file.txt','r',function(err,fd){\n    if(err){\n        console.log(err);\n        return;\n    }\n    var buf = new Buffer(8);\n    fs.read(fd,buf,0,8,null,function(err,bytesRead,buffer){\n        if(err){\n            console.log(err);\n            return;\n        }\n        console.log('bytesRead '+bytesRead);\n        console.log(buffer);\n    });\n});\n\n```\n执行结果：\n```javascript\nbytesRead 8\n<Buffer e5 95 a6 e5 95 a6 e5 95>\n```\n更多内容请参考[api手册](http://nodeapi.ucdok.com/#/api/fs.html)","source":"_posts/nodeJsStudy6.md","raw":"title: node.js学习笔记(六)——文件操作\ndate: 2016-01-04 10:18:50\ntags: node.js学习笔记\n---\nfs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接POSIX文件系统操作。与其他模块不同的是，*fs模块中的所有操作都提供了异步和同步两个版本，*例如读取文件内容函数的异步方法：readFile(),同步方法readFileSync()。\n<!-- more -->\n#### 一、`fs.readFile(filename,[encoding],[callback(err,data)])`是最简单的读取文件函数。\n参数：\nfilename：读取的文件名。\nencoding：文件的字符编码。 \ncallback 回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。如果指定了encoding，data是一个解析后的字符串，否则将会以buffer形式表示的二进制数据。\n例1：\n```javascript\n//异步读取文件\n//file.txt内容为\"哈哈哈\"\nvar fs = require('fs');\nfs.readFile('file.txt','utf-8',function(err,data){\n    if(err){\n        console.log(err);\n    }else{\n        console.log(data);\n    }\n});\nconsole.log('end');\n```\n执行结果：\n```javascript\nend\n哈哈哈\n```\n#### 二、fs.readFileSync(filename,[encoding])\n同步读取文件接受的参数和fs.readFile()相同，而读取到的文件内容会以函数返回值的形式返回，如果有错误发生，fs将抛出异常，你需要try和catch捕获并处理异常。\n例2；\n```javascript\n//同步读取文件\nvar fs = require('fs');\ntry{\n    var data = fs.readFileSync('file1.txt','utf-8');\n    console.log(data);\n    console.log('end');\n}catch(e){\n    console.log(e);\n}\n\n```\n执行结果：\n```javascript\n哈哈哈\nend\n```\n#### 三、fs.open(path,flags,[mode],[callback(err,fd)])\n是POSIXopen函数的封装，与C语言标准库中的fopen函数类似，它接受两个必选参数。\npath为文件路径，\nflag可以为以下值：\n\n| 值       | 作用           |\n| ---------|-------------| \n| r  | 以只读模式打开文件 | \n| r+ | 以读写模式打开文件 |\n| w  | 以写入模式打开文件，如果文件不存在则创建 |\n| w+ | 以读写模式打开文件，如果文件不存在则创建 | \n| a  | 以追加模式打开文件，如果文件不存在则创建 |\n| a+ | 以读取追加模式打开文件，如果文件不存在则创建 |\n\nmode:用于创建文件时给文件指定权限，默认是0666，回调函数将会传递一个文件描述符fd。\n0666:文件权限值POSIX系统中对文件读取和访问权限的范围，通常用八进制数表示。0754表示文件所有者权限是7（读、写、执行），同组用户权限是5（读、执行），其他用户的权限是4（读）。\nfd:文件描述是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引。\n\n#### 四、fs.read(fd,buffer,offset,length,position,[callback(err,bytesRead,buffer)])\n是POSIX中read函数的封装，相比readFild()提供了更底层的接口，从指定的文件描述fd中读取数据并写入。\nfd:指定的文件描述\nbuffer:指向的缓存区对象，\noffset:是buffer的写入偏量值\nlength:读取的字节数\nposition:文件读取的起始数，如果为null，则从当前文件指针读取。\n回调函数传递err,bytesRead和buffer，分别表示读取的字节数和缓冲区对象。\n例：\n```javascript\nvar fs = require('fs');\nfs.open('file.txt','r',function(err,fd){\n    if(err){\n        console.log(err);\n        return;\n    }\n    var buf = new Buffer(8);\n    fs.read(fd,buf,0,8,null,function(err,bytesRead,buffer){\n        if(err){\n            console.log(err);\n            return;\n        }\n        console.log('bytesRead '+bytesRead);\n        console.log(buffer);\n    });\n});\n\n```\n执行结果：\n```javascript\nbytesRead 8\n<Buffer e5 95 a6 e5 95 a6 e5 95>\n```\n更多内容请参考[api手册](http://nodeapi.ucdok.com/#/api/fs.html)","slug":"nodeJsStudy6","published":1,"updated":"2016-01-06T13:51:01.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvyy001cs8rk61kdkws3"},{"title":"node.js学习笔记(五)——常用工具util和事件EventEmitter","date":"2016-01-04T02:17:50.000Z","_content":"### 一、util全局变量\n#### 1. `util.inherits(constructor,superConstructor)`\n此方法是一个实现对象间原型继承的函数。javaScript通过原型赋值来实现继承。\n<!-- more -->\n例：\n```javascript\n//inherits.js\nvar util = require('util');\nfunction Base(){\n    this.name = 'base';\n    this.base = 2012;\n    this.sayHello = function(){\n        console.log('hello ' + this.name + ' this year is ' + this.base);\n    };\n}\nBase.prototype.showName = function(){\n    console.log(this.name);\n};\nfunction Sub(){\n    this.name = 'sub';\n}\nutil.inherits(Sub, Base);\n//原有输出\nvar objBase = new Base();\nobjBase.showName();\nobjBase.sayHello();\n\nconsole.log(objBase);\n//继承后的子类输出\nvar objSub = new Sub();\nobjSub.showName();\n//objSub.sayHello(); 报错\nconsole.log(objSub);\n```\n    执行结果：\n    ```javascript\n    base\n    hello base this year is 2012\n    Base { name: 'base', base: 2012, sayHello: [Function] }\n    sub\n    Sub { name: 'sub' }\n    ```\n注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。\n#### 2. `util.inspect(object,[showHidden],[depth],[colors])`\n此方法是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。\nshowHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。\ndepth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。\n特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。\n\n#### 3.`util.isArray(object)`\n如果给定的参数 \"object\" 是一个数组返回true，否则返回false。\n```javascript\nvar util = require('util');\n\nutil.isArray([])\n  // true\nutil.isArray(new Array)\n  // true\nutil.isArray({})\n  // false\n```\n类似的还有`util.isRegExp(object)`、`util.isDate(object)`、`util.isError(object)`\n\n更多api点击[参考链接](http://nodeapi.ucdok.com/#/api/util.html)\n\n### 二、事件驱动\nevents是Node.js最重要的模板，原因是Node.js本身架构就是事件式的，而它提供了唯一的接口。events模块不仅用于用户代码与NOde.js下层事件循环的交互。还几乎被所有的模块依赖。\n#### 1.事件发射器\nevents模块只提供了一个对象——events.EventEmitter。EventEmitter的核心就是事件发射与时间监听器功能的封装。EventEmitter的每个事件由一个事件或若干个参数组成，事件名是一个字符串，通常表达一定的语义，对于每个事件，EventEmitter支持若干个事件监听器。当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。\n例子：\n```javascript\nvar events = require('events');\n//实例化事件对象\nvar emitter = new events.EventEmitter();\n//注册事件监听1\nemitter.on('someEvent',function(arg1,arg2){\n    console.log('Listener1',arg1,arg2);\n});\n//注册事件监听2\nemitter.on('someEvent', function(arg1,arg2){\n    console.log('Listener2',arg1,arg2);\n});\n//触发事件\nemitter.emit('someEvent','cky',1991);\n```\n执行结果：\n```javascript\nListener1 cky 1991\nListener2 cky 1991\n```\n\n更多请参考[api文档](http://nodeapi.ucdok.com/#/api/events.html)\n\n#### 2.error事件\nEventEmitter定义了一个特殊的事件error，它包含错误的定义，我们在遇到异常的时候通常会发射error事件，当error事件被发射时，EventEmitter规定如果没有相应的监听器，Node.js会把它当作异常，退出程序打印调用栈，我们一般要为发射error的事件对象设置监听器，避免遇到错误后整个程序崩溃。\n#### 3.继承Event\n大多数时候我们不会直接使用EventEmitter，而是在对象中继承它，包括fs，net，http在内的。只要是支持事件相应的核心模块都是EventEmiiter的子类。\n为什么这样做呢？\n1. 具有某个实体功能的对象实现事件的符合语义，事件的监听和发射应该是一个对象的方法。\n2. javascript的对象机制是基于原型的，支持部分多重继承，继承EventEmitter不会打乱对象原有的继承关系。","source":"_posts/nodeJsStudy5.md","raw":"title: node.js学习笔记(五)——常用工具util和事件EventEmitter\ndate: 2016-01-04 10:17:50\ntags: node.js学习笔记\n---\n### 一、util全局变量\n#### 1. `util.inherits(constructor,superConstructor)`\n此方法是一个实现对象间原型继承的函数。javaScript通过原型赋值来实现继承。\n<!-- more -->\n例：\n```javascript\n//inherits.js\nvar util = require('util');\nfunction Base(){\n    this.name = 'base';\n    this.base = 2012;\n    this.sayHello = function(){\n        console.log('hello ' + this.name + ' this year is ' + this.base);\n    };\n}\nBase.prototype.showName = function(){\n    console.log(this.name);\n};\nfunction Sub(){\n    this.name = 'sub';\n}\nutil.inherits(Sub, Base);\n//原有输出\nvar objBase = new Base();\nobjBase.showName();\nobjBase.sayHello();\n\nconsole.log(objBase);\n//继承后的子类输出\nvar objSub = new Sub();\nobjSub.showName();\n//objSub.sayHello(); 报错\nconsole.log(objSub);\n```\n    执行结果：\n    ```javascript\n    base\n    hello base this year is 2012\n    Base { name: 'base', base: 2012, sayHello: [Function] }\n    sub\n    Sub { name: 'sub' }\n    ```\n注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。\n#### 2. `util.inspect(object,[showHidden],[depth],[colors])`\n此方法是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。\nshowHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。\ndepth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。\n特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。\n\n#### 3.`util.isArray(object)`\n如果给定的参数 \"object\" 是一个数组返回true，否则返回false。\n```javascript\nvar util = require('util');\n\nutil.isArray([])\n  // true\nutil.isArray(new Array)\n  // true\nutil.isArray({})\n  // false\n```\n类似的还有`util.isRegExp(object)`、`util.isDate(object)`、`util.isError(object)`\n\n更多api点击[参考链接](http://nodeapi.ucdok.com/#/api/util.html)\n\n### 二、事件驱动\nevents是Node.js最重要的模板，原因是Node.js本身架构就是事件式的，而它提供了唯一的接口。events模块不仅用于用户代码与NOde.js下层事件循环的交互。还几乎被所有的模块依赖。\n#### 1.事件发射器\nevents模块只提供了一个对象——events.EventEmitter。EventEmitter的核心就是事件发射与时间监听器功能的封装。EventEmitter的每个事件由一个事件或若干个参数组成，事件名是一个字符串，通常表达一定的语义，对于每个事件，EventEmitter支持若干个事件监听器。当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。\n例子：\n```javascript\nvar events = require('events');\n//实例化事件对象\nvar emitter = new events.EventEmitter();\n//注册事件监听1\nemitter.on('someEvent',function(arg1,arg2){\n    console.log('Listener1',arg1,arg2);\n});\n//注册事件监听2\nemitter.on('someEvent', function(arg1,arg2){\n    console.log('Listener2',arg1,arg2);\n});\n//触发事件\nemitter.emit('someEvent','cky',1991);\n```\n执行结果：\n```javascript\nListener1 cky 1991\nListener2 cky 1991\n```\n\n更多请参考[api文档](http://nodeapi.ucdok.com/#/api/events.html)\n\n#### 2.error事件\nEventEmitter定义了一个特殊的事件error，它包含错误的定义，我们在遇到异常的时候通常会发射error事件，当error事件被发射时，EventEmitter规定如果没有相应的监听器，Node.js会把它当作异常，退出程序打印调用栈，我们一般要为发射error的事件对象设置监听器，避免遇到错误后整个程序崩溃。\n#### 3.继承Event\n大多数时候我们不会直接使用EventEmitter，而是在对象中继承它，包括fs，net，http在内的。只要是支持事件相应的核心模块都是EventEmiiter的子类。\n为什么这样做呢？\n1. 具有某个实体功能的对象实现事件的符合语义，事件的监听和发射应该是一个对象的方法。\n2. javascript的对象机制是基于原型的，支持部分多重继承，继承EventEmitter不会打乱对象原有的继承关系。","slug":"nodeJsStudy5","published":1,"updated":"2016-01-06T13:50:53.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvz0001es8rk7idwkbec"},{"title":"node.js学习笔记(四)——全局对象与全局变量","date":"2015-12-11T02:17:50.000Z","_content":"所有属性都可以在程序的任何地方访问，即全局变量。在javascript中，通常window是全局对象，而node.js的全局对象是global，所有全局变量都是global对象的属性，如：console、process等。\n<!-- more -->\n### 一、全局对象与全局变量\n global最根本的作用是作为全局变量的宿主。满足以下条件成为全局变量。\n 1. 在最外层定义的变量\n 2. 全局对象的属性\n 3. 隐式定义的变量（未定义直接赋值的变量）\n node.js中不可能在最外层定义变量，因为所有的用户代码都是属于当前模块的，而模块本身不是最外层上下文。node.js中也不提倡自定义全局变量。\n\n__Node提供以下几个全局对象，它们是所有模块都可以调用的__。\n- global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。\n\n- process：该对象表示Node所处的当前进程，允许开发者与该进程互动。\n- console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。\n\n__Node还提供一些全局函数__。\n\n- setTimeout()：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。\n- clearTimeout()：用于终止一个setTimeout方法新建的定时器。\n- setInterval()：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。\n- clearInterval()：终止一个用setInterval方法新建的定时器。\n- require()：用于加载模块。\n- Buffer()：用于操作二进制数据。\n\n__Node提供两个全局变量，都以两个下划线开头__。\n\n_filename：指向当前运行的脚本文件名。\n_dirname：指向当前运行的脚本所在的目录。\n除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。\n\n### 二、 process\n 它用于描述当前Node.js进程状态的对象。提供了一个与操作系统的简单接口，通常写本地命令行程序的时候，会用到它。\n 例：\n ```javascript\n//命令行输入 node argv.js 'cky' 1993\n//argv.js\nconsole.log(process.argv);\nprocess.stdout.write('cky');\n ```\n 运行结果：\n ```javascript\n[ 'E:\\\\下载的东西\\\\node\\\\node.exe',\n  'D:\\\\myStudy\\\\nodeJsStudy\\\\process\\\\argv.js',\n  'cky',\n  '1993' ]\ncky\n ```\n 1. process.argv是命令行参数数组，第一个输出是node程序所在位置，第二个输出是脚本文件所在位置，第三个输出开始是运行参数。\n 2. process.stdout是标准输出流，通常我们使用的console.log()其底层是用process.stdout.write()实现的。\n 3. process.stdin是标准的输入流，在初识时他是被暂停的。要想从标准输入流读取数据，必须恢复流，并手动编写流的事件的相应函数。\n ```javascript\n //恢复流\nprocess.stdin.resume();\nprocess.stdin.on('data',function(data){\n    process.stdout.write('read form' +data.toString());\n});\n```\n 执行结果：\n![](http://i12.tietuku.com/1c4b90d94b2fb0e7.png)\n\n 4. process.nextTick(callback)的功能是为事件循环设置一项任务。Node.js会在下次事件循环调用callback。\nNode.js适合IO密集型的应用，而不是计算密集型的应用。process.nextTick()提供了一个这样的工具，可以把复杂的工作拆散，变为较小的事件。将一个回调函数放在下次事件循环的顶部。\n ```javascript\nfunction compute(){\n    console.log('I am a compute method');\n}\nfunction somethingComplited(args){\n    console.log('I am somthingComplited method');\n    console.log(args);\n}\nfunction doSomething(args,callback){\n    somethingComplited(args);\n    callback();\n}\ndoSomething('12345',function onEnd(){\n    compute();\n});\n ```\n 如果假设compute()和somethingComplited()是两个较为耗时的函数。以上的程序在调用doSomething时会先执行somethingComplited(args)后立即调用回调函数，在onEnd()中又会执行compute()，改写为：\n\n ```javascript\nfunction doSomething(args,callback){\n    somethingComplited(args);\n    process.nextTick(callback);\n}\n ```\n 使用process.nextTick()后，改写后的程序会把上面耗时的操作拆分为两个事件，减少每个事件的执行事件，提高事件响应速度。\n更多process API可参考 [参考链接1](http://www.css88.com/archives/4548)，[参考链接2](http://www.nodejs.net/a/20121231/083747.html)\n\n### 三、console\n用于提供控制台的标准输出，node.js沿用了这个标准，提供与习惯行为一致的console对象。\n1. `console.log()` 向标准输出流打印字符并以换行符结束。\n案例：\n```javascript\nconsole.log(\"hello\");\nconsole.log(\"hello%cky\");\nconsole.log(\"hello%cky\",\"cky\");\n```\n2. `console.error()`用法与标准console.log()相同，只是向标准错误流输出。\n3. `console.trace()`向标准错误流输出当前的调用栈。","source":"_posts/nodeJsStudy4.md","raw":"title: node.js学习笔记(四)——全局对象与全局变量\ndate: 2015-12-11 10:17:50\ntags: node.js学习笔记\n---\n所有属性都可以在程序的任何地方访问，即全局变量。在javascript中，通常window是全局对象，而node.js的全局对象是global，所有全局变量都是global对象的属性，如：console、process等。\n<!-- more -->\n### 一、全局对象与全局变量\n global最根本的作用是作为全局变量的宿主。满足以下条件成为全局变量。\n 1. 在最外层定义的变量\n 2. 全局对象的属性\n 3. 隐式定义的变量（未定义直接赋值的变量）\n node.js中不可能在最外层定义变量，因为所有的用户代码都是属于当前模块的，而模块本身不是最外层上下文。node.js中也不提倡自定义全局变量。\n\n__Node提供以下几个全局对象，它们是所有模块都可以调用的__。\n- global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。\n\n- process：该对象表示Node所处的当前进程，允许开发者与该进程互动。\n- console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。\n\n__Node还提供一些全局函数__。\n\n- setTimeout()：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。\n- clearTimeout()：用于终止一个setTimeout方法新建的定时器。\n- setInterval()：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。\n- clearInterval()：终止一个用setInterval方法新建的定时器。\n- require()：用于加载模块。\n- Buffer()：用于操作二进制数据。\n\n__Node提供两个全局变量，都以两个下划线开头__。\n\n_filename：指向当前运行的脚本文件名。\n_dirname：指向当前运行的脚本所在的目录。\n除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。\n\n### 二、 process\n 它用于描述当前Node.js进程状态的对象。提供了一个与操作系统的简单接口，通常写本地命令行程序的时候，会用到它。\n 例：\n ```javascript\n//命令行输入 node argv.js 'cky' 1993\n//argv.js\nconsole.log(process.argv);\nprocess.stdout.write('cky');\n ```\n 运行结果：\n ```javascript\n[ 'E:\\\\下载的东西\\\\node\\\\node.exe',\n  'D:\\\\myStudy\\\\nodeJsStudy\\\\process\\\\argv.js',\n  'cky',\n  '1993' ]\ncky\n ```\n 1. process.argv是命令行参数数组，第一个输出是node程序所在位置，第二个输出是脚本文件所在位置，第三个输出开始是运行参数。\n 2. process.stdout是标准输出流，通常我们使用的console.log()其底层是用process.stdout.write()实现的。\n 3. process.stdin是标准的输入流，在初识时他是被暂停的。要想从标准输入流读取数据，必须恢复流，并手动编写流的事件的相应函数。\n ```javascript\n //恢复流\nprocess.stdin.resume();\nprocess.stdin.on('data',function(data){\n    process.stdout.write('read form' +data.toString());\n});\n```\n 执行结果：\n![](http://i12.tietuku.com/1c4b90d94b2fb0e7.png)\n\n 4. process.nextTick(callback)的功能是为事件循环设置一项任务。Node.js会在下次事件循环调用callback。\nNode.js适合IO密集型的应用，而不是计算密集型的应用。process.nextTick()提供了一个这样的工具，可以把复杂的工作拆散，变为较小的事件。将一个回调函数放在下次事件循环的顶部。\n ```javascript\nfunction compute(){\n    console.log('I am a compute method');\n}\nfunction somethingComplited(args){\n    console.log('I am somthingComplited method');\n    console.log(args);\n}\nfunction doSomething(args,callback){\n    somethingComplited(args);\n    callback();\n}\ndoSomething('12345',function onEnd(){\n    compute();\n});\n ```\n 如果假设compute()和somethingComplited()是两个较为耗时的函数。以上的程序在调用doSomething时会先执行somethingComplited(args)后立即调用回调函数，在onEnd()中又会执行compute()，改写为：\n\n ```javascript\nfunction doSomething(args,callback){\n    somethingComplited(args);\n    process.nextTick(callback);\n}\n ```\n 使用process.nextTick()后，改写后的程序会把上面耗时的操作拆分为两个事件，减少每个事件的执行事件，提高事件响应速度。\n更多process API可参考 [参考链接1](http://www.css88.com/archives/4548)，[参考链接2](http://www.nodejs.net/a/20121231/083747.html)\n\n### 三、console\n用于提供控制台的标准输出，node.js沿用了这个标准，提供与习惯行为一致的console对象。\n1. `console.log()` 向标准输出流打印字符并以换行符结束。\n案例：\n```javascript\nconsole.log(\"hello\");\nconsole.log(\"hello%cky\");\nconsole.log(\"hello%cky\",\"cky\");\n```\n2. `console.error()`用法与标准console.log()相同，只是向标准错误流输出。\n3. `console.trace()`向标准错误流输出当前的调用栈。","slug":"nodeJsStudy4","published":1,"updated":"2016-01-06T13:50:34.805Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvz3001gs8rkw82ryaq2"},{"title":"node.js学习笔记(三)——模块与包","date":"2015-12-03T02:17:50.000Z","_content":"模块(Module)和包(package)是Node.js最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、分装、然后组合起来。模块正是为了实现这种方式而诞生，而浏览器JavaScript中，脚本模块的拆分和组合通常使用HTML的script标签来实现，Node.js提供了require函数来调用其他模块，而且**模块都是基于文件**，机制非常简单，模块和包的区别是透明的，因此经常不做区分。\n<!-- more  -->\n### 一、模块\n1. #### 什么是模块\n模块和文件是一一对应的。一个Node.js文件就是一个模块，这个文件可能是JavaSript代码、JSON或者编译过的C/C++扩展。\n`var http = require('http')`，其中的`http`是Node.js的一个核心模块，通过require函数获取这个模块，然后使用其中的对象。\n\n2. #### 创建及加载模块\n (1). 创建模块\n Node.js提供了exports和require两个对象，其中exports是模块公开的接口，require用于从外部获取一个模块的接口，即获取模块的exports对象。\n ```javascript\n //module.js\nvar name;\nexports.setName = function(theName){\n    name = theName;\n};\nexports.sayHello = function(){\n    console.log('hello '+ name);\n};\n ```\n ```javascript\n //getModule.js\nvar myModule = require('./module');\nmyModule.setName('cky');\nmyModule.sayHello();\n ```\n 执行getModule.js结果：\n```javascript\n\"hello cky\"\n```\n (2). 单次加载\n  ```javascript\n //getModule2.js\nvar myModule1 = require('./module');\nmyModule1.setName('cky1');\nvar myModule2 = require('./module');\nmyModule2.setName('cky2');\nmyModule1.sayHello();\n```\n 执行getModule2.js结果：\n```javascript\n\"hello cky2\"\n```\n  以上的例子类似创建对象，但是和创建对象有本质区别。因为**require不会重复加载模块**，也就是无论调用多少次require，所获取到的模块都是同一个(见第四点说到的require查找策略)。\n\n (3). 覆盖exports\n 有时候我们只是想把一个对象封装到模块中，就可以这样：\n ```javascript\n //singleObject.js\nfunction hello(){\n    var name;\n    this.setName = function(theName){\n        name = theName;\n    };\n    this.sayHello = function(){\n        console.log('hello' + name);\n    };\n}\nmodule.exports = hello;\n ```\n ```javascript\n //getSingleObject.js\nvar hello = require('./singleObject');\nvar he1 = new hello();\nhe1.setName('cky1');\nhe1.sayHello();\nvar he2 = new hello();\nhe2.setName('cky2');\nhe2.sayHello();\n ```\n 执行getSingleObject.js结果：\n```javascript\n\"hello cky1\"\n\"hello cky2\"\n```\n\n3. #### 模块分类\n Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。\n\n 在文件模块中，又分为3类模块。这三类文件模块以后缀来区分，Node.js会根据后缀名来决定加载方法。\n\n - .js。通过fs模块同步读取js文件并编译执行。\n - .node。通过C/C++进行编写的Addon。通过dlopen方法进行加载。\n - .json。读取文件，调用JSON.parse解析加载。\n\n Node.提供了exports和require两个对象,其中exports是模块公开的接口,require用于从外部获取一个模块接口,即所获取模块的exports对象.\n\n4. #### require查找策略\n __原生模块__在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类__文件模块__是动态加载的，加载速度比原生模块慢。但是Node.js对原生模块和文件模块都进行了缓存，于是在第二次require时，是不会有重复开销的。尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。\n ![require查找策略](http://i12.tietuku.com/c914066941701bb7.jpg)\n\n require方法接受以下几种参数的传递：\n\n - http、fs、path等原生模块。\n - ./mod或../mod，相对路径的文件模块。\n - /pathtomodule/mod，绝对路径的文件模块。\n - mod，非原生模块的文件模块。\n\n 当require一个文件模块时,从当前文件目录开始查找node_modules目录；然后依次进入父目录，查找父目录下的node_modules目录；依次迭代，直到根目录下的node_modules目录。\n\n 简而言之，如果require绝对路径的文件，查找时不会去遍历每一个node_modules目录，其速度最快。其余流程如下：\n\n 1. 从module path数组中取出第一个目录作为查找基准。\n 2. 直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。\n尝试添加.js、.json、.node后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。\n 3. 尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得main参数指定的文件。\n 4. 尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第3条查找。\n 5. 如果继续失败，则取出module path数组中的下一个目录作为基准查找，循环第1至5个步骤。\n 6. 如果继续失败，循环第1至6个步骤，直到module path中的最后一个值。\n 7. 如果仍然失败，则抛出异常。\n\n### 二、包\n1. 包的概念\n    包是在模块基础上更深一步的抽象，Node.js的包类似于C/C++的函数库或者java的类库，他将某个独立的功能封装起来，用于发布、更新、依赖管理的版本控制。开发了npm来解决了包的发布和获取需求。\n\n这个待我之后补充。- -","source":"_posts/nodeJsStudy3.md","raw":"title: node.js学习笔记(三)——模块与包\ndate: 2015-12-03 10:17:50\ntags: node.js学习笔记\n---\n模块(Module)和包(package)是Node.js最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、分装、然后组合起来。模块正是为了实现这种方式而诞生，而浏览器JavaScript中，脚本模块的拆分和组合通常使用HTML的script标签来实现，Node.js提供了require函数来调用其他模块，而且**模块都是基于文件**，机制非常简单，模块和包的区别是透明的，因此经常不做区分。\n<!-- more  -->\n### 一、模块\n1. #### 什么是模块\n模块和文件是一一对应的。一个Node.js文件就是一个模块，这个文件可能是JavaSript代码、JSON或者编译过的C/C++扩展。\n`var http = require('http')`，其中的`http`是Node.js的一个核心模块，通过require函数获取这个模块，然后使用其中的对象。\n\n2. #### 创建及加载模块\n (1). 创建模块\n Node.js提供了exports和require两个对象，其中exports是模块公开的接口，require用于从外部获取一个模块的接口，即获取模块的exports对象。\n ```javascript\n //module.js\nvar name;\nexports.setName = function(theName){\n    name = theName;\n};\nexports.sayHello = function(){\n    console.log('hello '+ name);\n};\n ```\n ```javascript\n //getModule.js\nvar myModule = require('./module');\nmyModule.setName('cky');\nmyModule.sayHello();\n ```\n 执行getModule.js结果：\n```javascript\n\"hello cky\"\n```\n (2). 单次加载\n  ```javascript\n //getModule2.js\nvar myModule1 = require('./module');\nmyModule1.setName('cky1');\nvar myModule2 = require('./module');\nmyModule2.setName('cky2');\nmyModule1.sayHello();\n```\n 执行getModule2.js结果：\n```javascript\n\"hello cky2\"\n```\n  以上的例子类似创建对象，但是和创建对象有本质区别。因为**require不会重复加载模块**，也就是无论调用多少次require，所获取到的模块都是同一个(见第四点说到的require查找策略)。\n\n (3). 覆盖exports\n 有时候我们只是想把一个对象封装到模块中，就可以这样：\n ```javascript\n //singleObject.js\nfunction hello(){\n    var name;\n    this.setName = function(theName){\n        name = theName;\n    };\n    this.sayHello = function(){\n        console.log('hello' + name);\n    };\n}\nmodule.exports = hello;\n ```\n ```javascript\n //getSingleObject.js\nvar hello = require('./singleObject');\nvar he1 = new hello();\nhe1.setName('cky1');\nhe1.sayHello();\nvar he2 = new hello();\nhe2.setName('cky2');\nhe2.sayHello();\n ```\n 执行getSingleObject.js结果：\n```javascript\n\"hello cky1\"\n\"hello cky2\"\n```\n\n3. #### 模块分类\n Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。\n\n 在文件模块中，又分为3类模块。这三类文件模块以后缀来区分，Node.js会根据后缀名来决定加载方法。\n\n - .js。通过fs模块同步读取js文件并编译执行。\n - .node。通过C/C++进行编写的Addon。通过dlopen方法进行加载。\n - .json。读取文件，调用JSON.parse解析加载。\n\n Node.提供了exports和require两个对象,其中exports是模块公开的接口,require用于从外部获取一个模块接口,即所获取模块的exports对象.\n\n4. #### require查找策略\n __原生模块__在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类__文件模块__是动态加载的，加载速度比原生模块慢。但是Node.js对原生模块和文件模块都进行了缓存，于是在第二次require时，是不会有重复开销的。尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。\n ![require查找策略](http://i12.tietuku.com/c914066941701bb7.jpg)\n\n require方法接受以下几种参数的传递：\n\n - http、fs、path等原生模块。\n - ./mod或../mod，相对路径的文件模块。\n - /pathtomodule/mod，绝对路径的文件模块。\n - mod，非原生模块的文件模块。\n\n 当require一个文件模块时,从当前文件目录开始查找node_modules目录；然后依次进入父目录，查找父目录下的node_modules目录；依次迭代，直到根目录下的node_modules目录。\n\n 简而言之，如果require绝对路径的文件，查找时不会去遍历每一个node_modules目录，其速度最快。其余流程如下：\n\n 1. 从module path数组中取出第一个目录作为查找基准。\n 2. 直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。\n尝试添加.js、.json、.node后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。\n 3. 尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得main参数指定的文件。\n 4. 尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第3条查找。\n 5. 如果继续失败，则取出module path数组中的下一个目录作为基准查找，循环第1至5个步骤。\n 6. 如果继续失败，循环第1至6个步骤，直到module path中的最后一个值。\n 7. 如果仍然失败，则抛出异常。\n\n### 二、包\n1. 包的概念\n    包是在模块基础上更深一步的抽象，Node.js的包类似于C/C++的函数库或者java的类库，他将某个独立的功能封装起来，用于发布、更新、依赖管理的版本控制。开发了npm来解决了包的发布和获取需求。\n\n这个待我之后补充。- -","slug":"nodeJsStudy3","published":1,"updated":"2016-01-06T13:50:25.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvz7001is8rkx28flfbd"},{"title":"node.js学习笔记(二)——node.js回调函数与事件","date":"2015-12-02T02:17:50.000Z","_content":"### 一、回调函数\n#### 1.异步读取文件\n```javascript\nvar fs = require('fs');\nfs.readFile('file.txt','utf-8',function(err,data){\n    if(err){\n        console.log(err);\n    }else{\n        console.log(data);\n    }\n});\nconsole.log('end');\n```\n运行结果：\n```\n\"end\"\n\"fileContent\"\n```\n\n#### 2.同步式读取文件\n```javascript\nvar fs = require('fs');\nvar data = fs.readFileSync('file.txt','utf-8');\nconsole.log(data);\nconsole.log('end');\n```\n运行结果:\n```\n\"fileContent\"\n\"end\"\n```\n#### 3.分析\n异步调用时所做的工作只是将异步式I/O请求发送给了操作系统，然后立即返回并执行后面的语句，执行完以后进入事件循环监听事件，当fs接收到I/O请求完成的事件时，事件循环会主动调用回调函数完成后续工作。\n同步则是阻塞等待完成后，继续执行。\n\n### 事件\n#### 1.普通事件的使用\n```javascript\n//声明事件对象\nvar EventEmitter = require('events').EventEmitter;\nvar event1 = new EventEmitter();\n//注册事件\nevent1.on('cky_event',function(){\n    console.log('这是一个自定义事件');\n});\n//触发事件\nsetTimeout(function(){\n    event1.emit('cky_event');\n}, 1000);\n```\n执行结果：\n```\n//1s后\n\"这是一个自定义事件\"\n```\n\n#### 2. node.js的事件循环机制\n1. Node.js在什么时候进入事件循环呢？\n答案是Node.js程序是由事件循环开始，一直在寻找有没有新的没有处理的事件，然后一次去执行处理，直到事件循环结束，所有的逻辑都是事件的回调函数。\n\n2. 如何使用自定义事件呢？\n事件的回调函数在执行过程中，可能会发出IO请求或直接发射(emit)事件，执行完成后再返回这个事件的循环。","source":"_posts/nodeJsStudy2.md","raw":"title: node.js学习笔记(二)——node.js回调函数与事件\ndate: 2015-12-02 10:17:50\ntags: node.js学习笔记\n---\n### 一、回调函数\n#### 1.异步读取文件\n```javascript\nvar fs = require('fs');\nfs.readFile('file.txt','utf-8',function(err,data){\n    if(err){\n        console.log(err);\n    }else{\n        console.log(data);\n    }\n});\nconsole.log('end');\n```\n运行结果：\n```\n\"end\"\n\"fileContent\"\n```\n\n#### 2.同步式读取文件\n```javascript\nvar fs = require('fs');\nvar data = fs.readFileSync('file.txt','utf-8');\nconsole.log(data);\nconsole.log('end');\n```\n运行结果:\n```\n\"fileContent\"\n\"end\"\n```\n#### 3.分析\n异步调用时所做的工作只是将异步式I/O请求发送给了操作系统，然后立即返回并执行后面的语句，执行完以后进入事件循环监听事件，当fs接收到I/O请求完成的事件时，事件循环会主动调用回调函数完成后续工作。\n同步则是阻塞等待完成后，继续执行。\n\n### 事件\n#### 1.普通事件的使用\n```javascript\n//声明事件对象\nvar EventEmitter = require('events').EventEmitter;\nvar event1 = new EventEmitter();\n//注册事件\nevent1.on('cky_event',function(){\n    console.log('这是一个自定义事件');\n});\n//触发事件\nsetTimeout(function(){\n    event1.emit('cky_event');\n}, 1000);\n```\n执行结果：\n```\n//1s后\n\"这是一个自定义事件\"\n```\n\n#### 2. node.js的事件循环机制\n1. Node.js在什么时候进入事件循环呢？\n答案是Node.js程序是由事件循环开始，一直在寻找有没有新的没有处理的事件，然后一次去执行处理，直到事件循环结束，所有的逻辑都是事件的回调函数。\n\n2. 如何使用自定义事件呢？\n事件的回调函数在执行过程中，可能会发出IO请求或直接发射(emit)事件，执行完成后再返回这个事件的循环。","slug":"nodeJsStudy2","published":1,"updated":"2016-01-06T13:50:14.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvza001ks8rkz5i90ypz"},{"title":"node.js学习笔记(十一)——路由控制","date":"2016-01-07T06:08:50.000Z","_content":"### 一、工作原理\n当访问http://localhost:3000， 浏览器会向服务器发送请求，包括请求的方法、路径、HTTP协议版本和请求头信息。app会解析请求的路径，调用相应的逻辑，route/index.js中有 `router.get('/',function(){})`通过`res.render('index',{title:\"cky\"})`调用视图模板index，传递title变量，最终生成HTML页面，返回给浏览器。\n浏览器收到内容后，通过分析需要获取/stylesheet/style.css，因此会再次向服务器发起请求，app.js并没有一个路由指派到/stylesheets/style.css，但app通过`app.use(express.static(__dirname+'/public'))`配置了静态文件服务器，因此会定向到app.js所在目录下的/public/stylesheets/style.css拿取这个文件。\n\n这是一个典型的MVC架构，浏览器发送请求，由路由控制接收，根据不同的路径定向到不同的服务器，控制器处理用户具体的请求，可能会访问数据库中的对象，即模型部分，生成视图的HTML，最后再由控制器返回给浏览器，完成一次请求。\n\n### 二、创建路由规则\n当我们在浏览器访问http://localhost:3000/cky 的时候，服务器响应头返回404 NOT FOUND的错误，这是因为/cky是一个不存在的路由规则，而且它也不是一个public目录下的文件，所以响应404。\n假设我们创建一个/cky的路由规则\n```javascript\nrouter.get('/cky', function(req, res, next) {\n  res.send(\"cky route\");\n});\n\n```\n即可访问。\n服务器开始监听之前，设置好了所有的路由规则，当请求到来时直接分配到相应的函数，app.get是路由规则创建函数。\n\n### 三、路径匹配\n上面讲到了为固定的路径设置路由规则，Express还提供了更高级的路径匹配模式。\n1.\n```javascript\nrouter.get('/user/:username',function(req,res){\n    res.send('user:' +req.params.username);\n});\n```\n访问结果：\n![](http://i4.tietuku.com/52a6b8b573c8450b.jpg)\n路径规则/user/username会自动编译成正则表达式，类似于\\/user\\/([^\\/]+)\\/?这样的形式，路径参数可以在相应函数中通过req.params的属性访问。\n\n2. 路径规则同样支持javascript正则表达式，例如`router.get(\\/user\\/([^\\/]+)\\/?,callback)`这样的好处在于可以定义更加复杂的路径规则，不同之处是配置的参数是匿名的，因此需要通过req.params[0]这样的形式访问。\n\n### 四、REST风格的路由规则\nExpress支持REST风格的请求方式，REST意思是表征状态转移，它是一种基于HTTP协议的网络应用的接口风格，充分利用HTTP的方法实现了统一风格的接口服务，HTTP协议定义了以下8个标准方法：\n\n|请求方法|用途|\n|---|---|\n|GET|请求获取的资源 获取|\n|POST|向指定资源提交数据 新增|\n|DELETE|请求服务器删除指定资源 删除|\n|PUT|请求服务器存储一个资源 更新|\n|HEAD|请求指定资源的响应头|\n|TRACE|回显服务器数到的请求，主要用户测试或诊断|\n|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。|\n|OPTIONS|返回服务器支持HTTP请求方法|\n\nExpress对每种HTTP请求方法都设计了不同的路由绑定函数 \n- GET : app.get(path,callback);\n- POST: app.post(path,callback);\n- PUT : app.put(path,callback);\n- DELETE: app.delete(path,callback);\n...\n...\n所有方法 app.all(path,callback);\napp.all函数，它支持把所有的请求方法绑定到同一个相应函数，是一个非常灵活的函数。\n\n### 五、控制权转移\nExpress支持同一路径绑定多个响应函数\n```javascript\napp.all('test/:user',function(req,res,next){\n    res.send(\"all method is call\");\n    next();\n});\n\napp.get('/test/:user',function(req,res){\n    res.send(\"user: \" + req.params.user); \n});\n```\n但是我们访问都只会返回一次。\nExpress提供了路由控制权转移的方法，即next()函数，通过调用则将控制权交给后面的规则","source":"_posts/nodeJsStudy11.md","raw":"title: node.js学习笔记(十一)——路由控制\ndate: 2016-01-07 14:08:50\ntags: node.js学习笔记\n---\n### 一、工作原理\n当访问http://localhost:3000， 浏览器会向服务器发送请求，包括请求的方法、路径、HTTP协议版本和请求头信息。app会解析请求的路径，调用相应的逻辑，route/index.js中有 `router.get('/',function(){})`通过`res.render('index',{title:\"cky\"})`调用视图模板index，传递title变量，最终生成HTML页面，返回给浏览器。\n浏览器收到内容后，通过分析需要获取/stylesheet/style.css，因此会再次向服务器发起请求，app.js并没有一个路由指派到/stylesheets/style.css，但app通过`app.use(express.static(__dirname+'/public'))`配置了静态文件服务器，因此会定向到app.js所在目录下的/public/stylesheets/style.css拿取这个文件。\n\n这是一个典型的MVC架构，浏览器发送请求，由路由控制接收，根据不同的路径定向到不同的服务器，控制器处理用户具体的请求，可能会访问数据库中的对象，即模型部分，生成视图的HTML，最后再由控制器返回给浏览器，完成一次请求。\n\n### 二、创建路由规则\n当我们在浏览器访问http://localhost:3000/cky 的时候，服务器响应头返回404 NOT FOUND的错误，这是因为/cky是一个不存在的路由规则，而且它也不是一个public目录下的文件，所以响应404。\n假设我们创建一个/cky的路由规则\n```javascript\nrouter.get('/cky', function(req, res, next) {\n  res.send(\"cky route\");\n});\n\n```\n即可访问。\n服务器开始监听之前，设置好了所有的路由规则，当请求到来时直接分配到相应的函数，app.get是路由规则创建函数。\n\n### 三、路径匹配\n上面讲到了为固定的路径设置路由规则，Express还提供了更高级的路径匹配模式。\n1.\n```javascript\nrouter.get('/user/:username',function(req,res){\n    res.send('user:' +req.params.username);\n});\n```\n访问结果：\n![](http://i4.tietuku.com/52a6b8b573c8450b.jpg)\n路径规则/user/username会自动编译成正则表达式，类似于\\/user\\/([^\\/]+)\\/?这样的形式，路径参数可以在相应函数中通过req.params的属性访问。\n\n2. 路径规则同样支持javascript正则表达式，例如`router.get(\\/user\\/([^\\/]+)\\/?,callback)`这样的好处在于可以定义更加复杂的路径规则，不同之处是配置的参数是匿名的，因此需要通过req.params[0]这样的形式访问。\n\n### 四、REST风格的路由规则\nExpress支持REST风格的请求方式，REST意思是表征状态转移，它是一种基于HTTP协议的网络应用的接口风格，充分利用HTTP的方法实现了统一风格的接口服务，HTTP协议定义了以下8个标准方法：\n\n|请求方法|用途|\n|---|---|\n|GET|请求获取的资源 获取|\n|POST|向指定资源提交数据 新增|\n|DELETE|请求服务器删除指定资源 删除|\n|PUT|请求服务器存储一个资源 更新|\n|HEAD|请求指定资源的响应头|\n|TRACE|回显服务器数到的请求，主要用户测试或诊断|\n|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。|\n|OPTIONS|返回服务器支持HTTP请求方法|\n\nExpress对每种HTTP请求方法都设计了不同的路由绑定函数 \n- GET : app.get(path,callback);\n- POST: app.post(path,callback);\n- PUT : app.put(path,callback);\n- DELETE: app.delete(path,callback);\n...\n...\n所有方法 app.all(path,callback);\napp.all函数，它支持把所有的请求方法绑定到同一个相应函数，是一个非常灵活的函数。\n\n### 五、控制权转移\nExpress支持同一路径绑定多个响应函数\n```javascript\napp.all('test/:user',function(req,res,next){\n    res.send(\"all method is call\");\n    next();\n});\n\napp.get('/test/:user',function(req,res){\n    res.send(\"user: \" + req.params.user); \n});\n```\n但是我们访问都只会返回一次。\nExpress提供了路由控制权转移的方法，即next()函数，通过调用则将控制权交给后面的规则","slug":"nodeJsStudy11","published":1,"updated":"2016-07-04T07:09:21.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvzh001ms8rkn1nc77oe"},{"title":"node.js学习笔记(十)——工程的结构","date":"2016-01-06T15:16:50.000Z","_content":"### 一、app.js工程的入口\n分析app.js代码：\n<!-- more -->\n```javascript\n//引用模块\n//我们导入了express模块，前面我们通过npm install依赖上了，在这里就可以通过require直接获取\nvar express = require('express');\nvar path = require('path');\nvar favicon = require('serve-favicon');\nvar logger = require('morgan');\nvar cookieParser = require('cookie-parser');\nvar bodyParser = require('body-parser');\nvar debug = require('debug')('myapp:server');\nvar http = require('http');\n//routes是一个文件夹形式的本地模块，即/routes/index.\nvar routes = require('./routes/index');\nvar users = require('./routes/users');\n//实例化express对象\nvar app = express();\n//配置app的参数和启用中间件 见注1 注2\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\napp.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));\napp.use(logger('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/', routes);\napp.use('/users', users);\n//错误处理中间件\napp.use(function(req, res, next) {\n  var err = new Error('Not Found');\n  err.status = 404;\n  next(err);\n});\napp.use(function(err, req, res, next) {\n  res.status(err.status || 500);\n  res.render('error', {\n    message: err.message,\n    error: {}\n  });\n});\n//开发模式下\nif (app.get('env') === 'development') {\n  app.use(function(err, req, res, next) {\n    res.status(err.status || 500);\n    res.render('error', {\n      message: err.message,\n      error: err\n    });\n  });\n}\n\n//Get port from environment and store in Express.\nvar port = normalizePort(process.env.PORT || '3000');\napp.set('port', port);\n\n//创建http服务\nvar server = http.createServer(app);\n//Listen on provided port, on all network interfaces.\nserver.listen(port);\nserver.on('error', onError);\nserver.on('listening', onListening);\n//Normalize a port into a number, string, or false.\nfunction normalizePort(val) {\n  var port = parseInt(val, 10);\n  if (isNaN(port)) {\n    // named pipe\n    return val;\n  }\n  if (port >= 0) {\n    // port number\n    return port;\n  }\n  return false;\n}\n//Event listener for HTTP server \"error\" event.\nfunction onError(error) {\n  if (error.syscall !== 'listen') {\n    throw error;\n  }\n  var bind = typeof port === 'string'\n    ? 'Pipe ' + port\n    : 'Port ' + port;\n  // handle specific listen errors with friendly messages\n  switch (error.code) {\n    case 'EACCES':\n      console.error(bind + ' requires elevated privileges');\n      process.exit(1);\n      break;\n    case 'EADDRINUSE':\n      console.error(bind + ' is already in use');\n      process.exit(1);\n      break;\n    default:\n      throw error;\n  }\n}\n//Event listener for HTTP server \"listening\" event.\nfunction onListening() {\n  var addr = server.address();\n  var bind = typeof addr === 'string'\n    ? 'pipe ' + addr\n    : 'port ' + addr.port;\n  debug('Listening on ' + bind);\n}\n\nmodule.exports = app;\n\n```\n\n注1. app.set是一个Express()的参数设置工具，接受一个键(key)和一个值(value)，可以用的参数如下：\n\n|参数|用途|\n|--|--|\n|basepath|基础机制，通常用于res.redirect()跳转|\n|port|指定的端口|\n|view|视图文件目录，存放模板文件|\n|view engine|视图模块引擎（如ejs jade）|\n|view options|全局视图参数对象|\n|view cache|启用视图缓存|\n|case sensitive routes|路径区分大小写|\n|strict routing|严格路径，启用后不会忽略路径末尾的\"/\"|\n|jsonp callback|开启透明的jsonp支持|\n更多请见[api文档](http://www.expressjs.com.cn/4x/api.html#app.set)\n\n注2. 老版本Express依赖于connect，connect更加短小精悍，是一个偏向基础设施的框架，提供了大量的中间件，可以通过app.use()启用。\n从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 [中间件列表](https://github.com/senchalabs/connect#middleware)。\n[中间件](http://www.expressjs.com.cn/guide/using-middleware.html)：一系列的组件连接到一起，然后让http的请求一次流过这些组件。这些被connect串联起来的组件被称为中间件。\n\n### 二、routes/index.js\nroutes/index.js是路由文件,相当于控制器，用于组织展示的内容。\napp.js中通过`app.use('/',routes)`将'/'路径映射到routes/index.js函数下，交由其处理。\n```javascript\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'cky1' });\n});\n\nmodule.exports = router;\n```\t\n\n### 三、index.ejs模板文件\n它的基础是HTML语言，其中包含了`<%=title%>，功能是显示引用的变量，即通过render传过来的第二个参数的属性。","source":"_posts/nodeJsStudy10.md","raw":"title: node.js学习笔记(十)——工程的结构\ndate: 2016-01-06 23:16:50\ntags: node.js学习笔记\n---\n### 一、app.js工程的入口\n分析app.js代码：\n<!-- more -->\n```javascript\n//引用模块\n//我们导入了express模块，前面我们通过npm install依赖上了，在这里就可以通过require直接获取\nvar express = require('express');\nvar path = require('path');\nvar favicon = require('serve-favicon');\nvar logger = require('morgan');\nvar cookieParser = require('cookie-parser');\nvar bodyParser = require('body-parser');\nvar debug = require('debug')('myapp:server');\nvar http = require('http');\n//routes是一个文件夹形式的本地模块，即/routes/index.\nvar routes = require('./routes/index');\nvar users = require('./routes/users');\n//实例化express对象\nvar app = express();\n//配置app的参数和启用中间件 见注1 注2\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\napp.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));\napp.use(logger('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/', routes);\napp.use('/users', users);\n//错误处理中间件\napp.use(function(req, res, next) {\n  var err = new Error('Not Found');\n  err.status = 404;\n  next(err);\n});\napp.use(function(err, req, res, next) {\n  res.status(err.status || 500);\n  res.render('error', {\n    message: err.message,\n    error: {}\n  });\n});\n//开发模式下\nif (app.get('env') === 'development') {\n  app.use(function(err, req, res, next) {\n    res.status(err.status || 500);\n    res.render('error', {\n      message: err.message,\n      error: err\n    });\n  });\n}\n\n//Get port from environment and store in Express.\nvar port = normalizePort(process.env.PORT || '3000');\napp.set('port', port);\n\n//创建http服务\nvar server = http.createServer(app);\n//Listen on provided port, on all network interfaces.\nserver.listen(port);\nserver.on('error', onError);\nserver.on('listening', onListening);\n//Normalize a port into a number, string, or false.\nfunction normalizePort(val) {\n  var port = parseInt(val, 10);\n  if (isNaN(port)) {\n    // named pipe\n    return val;\n  }\n  if (port >= 0) {\n    // port number\n    return port;\n  }\n  return false;\n}\n//Event listener for HTTP server \"error\" event.\nfunction onError(error) {\n  if (error.syscall !== 'listen') {\n    throw error;\n  }\n  var bind = typeof port === 'string'\n    ? 'Pipe ' + port\n    : 'Port ' + port;\n  // handle specific listen errors with friendly messages\n  switch (error.code) {\n    case 'EACCES':\n      console.error(bind + ' requires elevated privileges');\n      process.exit(1);\n      break;\n    case 'EADDRINUSE':\n      console.error(bind + ' is already in use');\n      process.exit(1);\n      break;\n    default:\n      throw error;\n  }\n}\n//Event listener for HTTP server \"listening\" event.\nfunction onListening() {\n  var addr = server.address();\n  var bind = typeof addr === 'string'\n    ? 'pipe ' + addr\n    : 'port ' + addr.port;\n  debug('Listening on ' + bind);\n}\n\nmodule.exports = app;\n\n```\n\n注1. app.set是一个Express()的参数设置工具，接受一个键(key)和一个值(value)，可以用的参数如下：\n\n|参数|用途|\n|--|--|\n|basepath|基础机制，通常用于res.redirect()跳转|\n|port|指定的端口|\n|view|视图文件目录，存放模板文件|\n|view engine|视图模块引擎（如ejs jade）|\n|view options|全局视图参数对象|\n|view cache|启用视图缓存|\n|case sensitive routes|路径区分大小写|\n|strict routing|严格路径，启用后不会忽略路径末尾的\"/\"|\n|jsonp callback|开启透明的jsonp支持|\n更多请见[api文档](http://www.expressjs.com.cn/4x/api.html#app.set)\n\n注2. 老版本Express依赖于connect，connect更加短小精悍，是一个偏向基础设施的框架，提供了大量的中间件，可以通过app.use()启用。\n从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 [中间件列表](https://github.com/senchalabs/connect#middleware)。\n[中间件](http://www.expressjs.com.cn/guide/using-middleware.html)：一系列的组件连接到一起，然后让http的请求一次流过这些组件。这些被connect串联起来的组件被称为中间件。\n\n### 二、routes/index.js\nroutes/index.js是路由文件,相当于控制器，用于组织展示的内容。\napp.js中通过`app.use('/',routes)`将'/'路径映射到routes/index.js函数下，交由其处理。\n```javascript\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'cky1' });\n});\n\nmodule.exports = router;\n```\t\n\n### 三、index.ejs模板文件\n它的基础是HTML语言，其中包含了`<%=title%>，功能是显示引用的变量，即通过render传过来的第二个参数的属性。","slug":"nodeJsStudy10","published":1,"updated":"2016-07-04T07:10:32.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvzm001os8rkbul3ogtd"},{"title":"node.js学习笔记(一)——node.js异步式I/O与事件编程","date":"2015-12-01T02:17:50.000Z","_content":"Node.js最大的特性就是**异步式IO**与**事件**紧密结合的编程模式，这种模式与传统的同步式I/O线性的编程思路有很大的不同，因为控制流很大程度上靠事件和回调函数来组织。\n\n### 阻塞与线程\n#### 1.同步式I/O(阻塞式I/O)：\n线程在执行过程中如果遇到磁盘读写或网络通信，通常要耗费较长的时间。这时操作系统会剥夺这个线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞。当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。\n\n#### 2. 异步式I/O(非阻塞式I/O)\n针对所有的I/O操作不采用阻塞策略，当线程遇到I/O操作时，不会以阻塞的方式等待I/O操作的完成或数据的返回，而只是将I/O请求发给操作系统，继续执行下一句语句，当操作系统完成I/O操作时，以事件的形式通知执行I/O操作的线程，线程会在特定时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。\n\n#### 3.非阻塞与阻塞模式的区别\n非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的CPU核心利用率永远是100%，I/O以事件的方式通知。\n阻塞模式下，多线程往往能提高系统的吞吐量，因为一个线程阻塞还有其他线程在工作，多线程可以让CPU资源不被阻塞中的线程浪费。\n\n#### 4. 同步式I/O与异步式I/O区别\n|同步式I/O(阻塞式)|异步式I/O(非阻塞)|\n|---|:---\n|利用多线程提供吞吐量|单线程即可实现高吞吐量|\n|通过事件片分隔和线程调度利用多核CPU|通过功能划分利用多核|\n|需要由操作系统调度多线程使用多核CPU|可以将单线程绑定到单核CPU|\n|难以充分利用CPU资源|可以充分利用CPU资源|\n|内存轨迹大，数据局部性弱|内存轨迹小，数据局部性强|\n|符合线性的编程思维|不符合传统编程思维|","source":"_posts/nodeJsStudy1.md","raw":"title: node.js学习笔记(一)——node.js异步式I/O与事件编程\ndate: 2015-12-01 10:17:50\ntags: node.js学习笔记\n---\nNode.js最大的特性就是**异步式IO**与**事件**紧密结合的编程模式，这种模式与传统的同步式I/O线性的编程思路有很大的不同，因为控制流很大程度上靠事件和回调函数来组织。\n\n### 阻塞与线程\n#### 1.同步式I/O(阻塞式I/O)：\n线程在执行过程中如果遇到磁盘读写或网络通信，通常要耗费较长的时间。这时操作系统会剥夺这个线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞。当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。\n\n#### 2. 异步式I/O(非阻塞式I/O)\n针对所有的I/O操作不采用阻塞策略，当线程遇到I/O操作时，不会以阻塞的方式等待I/O操作的完成或数据的返回，而只是将I/O请求发给操作系统，继续执行下一句语句，当操作系统完成I/O操作时，以事件的形式通知执行I/O操作的线程，线程会在特定时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。\n\n#### 3.非阻塞与阻塞模式的区别\n非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的CPU核心利用率永远是100%，I/O以事件的方式通知。\n阻塞模式下，多线程往往能提高系统的吞吐量，因为一个线程阻塞还有其他线程在工作，多线程可以让CPU资源不被阻塞中的线程浪费。\n\n#### 4. 同步式I/O与异步式I/O区别\n|同步式I/O(阻塞式)|异步式I/O(非阻塞)|\n|---|:---\n|利用多线程提供吞吐量|单线程即可实现高吞吐量|\n|通过事件片分隔和线程调度利用多核CPU|通过功能划分利用多核|\n|需要由操作系统调度多线程使用多核CPU|可以将单线程绑定到单核CPU|\n|难以充分利用CPU资源|可以充分利用CPU资源|\n|内存轨迹大，数据局部性弱|内存轨迹小，数据局部性强|\n|符合线性的编程思维|不符合传统编程思维|","slug":"nodeJsStudy1","published":1,"updated":"2016-01-06T13:50:07.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvzu001qs8rkuydhba0m"},{"title":"jQuery性能优化","date":"2015-11-25T02:17:50.000Z","_content":"jQuery已经成为前端开发中重要的类库之一，也是前端开发er的一个利器，了解到如何正确使用jQuery达到最佳性能是一个很重要的事。下面从各个方面来总结一下jQuery性能优化技巧和注意事项。\n<!-- more -->\n### 一、使用合适的选择器\n**$('#id')**\n使用id来定位DOM元素无疑是提高性能的最佳方式，因为这会直接调用本地方法`document.getElementById()`。\n如果这样找不到所需要的元素，可以使用find()方法。`$(\"#content\").find(\"div\");`为了提高性能，建议从最近的id元素开始往下搜索。\n\n**$('p'),$('div'),$('input')**\n标签选择器也不错，因为jQuery是直接调用本地方法`document.getElementsByTagName()`。\n\n**$('.class')**\n对于比较新的浏览器，它支持本地方法`document.getElementsByClassName()`。但是对于ie8及以下版本浏览器，只能通过DOM搜索的方法来实现，这无疑会带来一些性能的影响。建议有选择地使用。\n\n**$(\"[attribute=value]\")**\n对于利用属性来定位DOM元素，本地javascript并没有方法直接实现，大多是使用DOM搜索的方式来达到效果。很多现代浏览器支持querySelectAll()方法，但是不同浏览器的性能还是有区别。总体来说，使用这种方式性能不是非常理想，所以为了获得更好的优化效果，建议尽量避免这种对性能有害的方式。\n\n**$(\":hidden\")**\n和上面利用属性定位DOM元素一样，这种伪选择器也同样没有直接在本地javascript方法中实现，并且jQuery需要搜索每一个元素来定位这个选择器，这将对性能带来比较大的影响，所以建议尽量不要使用。如果非要使用，请先使用ID选择器定位父元素然后再使用该选择器，这样对性能优化有帮助。\n\n- **尽量使用ID选择器**\n- **尽量给选择器指定上下文**\n\n### 二、缓存对象\n其实这是javascript也需要注意的地方\n```javascript\n//bad\n$(\"#light\").bind('click',function(){...});\n$(\"#light\").css('border',\"1px solid red\");\n$(\"#light\").fadeIn(\"slow\");\n\n//good\nvar light = $(\"#light\");\nlight.bind('click',function(){...});\nlight.css('border',\"1px solid red\");\nlight.fadeIn(\"slow\");\n```\n本例中用链式方式将更加简洁，上面只是为了说明缓存变量的重要性。\n```javascript\n//链式\nvar light = $(\"#light\");\nlight.bind('click',function(){...})\n    .css('border',\"1px solid red\")\n    .fadeIn(\"slow\");\n```\n如果打算在其他函数中使用jQuery对象，那么可以把它们缓存到全局环境中。如下代码所示：\n```javascript\nwindow.$my = {\n    head : $('head'),\n    light: $('#light'),\n    light_button: $(\"#light_button\")\n};\nfunction dosomething(){\n    //现在可以引用存储结构并操作它们\n    var script = docuement.creatElement(\"script\");\n    $my.head.append(script);\n    // 当你在函数内部操作时，可以继续将查询存入全局对象中去\n    $my.cool_results = $(\"#some_ul li\");\n    $my.other_results = $(\"#some\");\n    // 全局函数作为一个普通的jquery对象去使用\n    $my.other_results.css(\"border-color\",\"red\");\n}\n```\n记住，永远不要让相同的选择器在你的代码里出现多次。\n\n### 三、事件代理\n每一个JavaScript事件（例如click、mouseover等）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时，这点会很好用。比如,我们要为一个表格绑定这样的行为：点击td后，把背景色设置为红色，代码如下：\n```javascript\n//bad\n$(\"#mytable td\").click(functuon(){\n   $(this).css('background','red');\n});\n```\n假如有100个td元素，在使用以上方式时，绑定了100个事件，这将带来很负面的性能影响。\n```javascript\n//good\n$(\"#mytable\").click(function(e){\n    var $clicked = $(e.target);//e.target 捕捉到触发的目标元素\n    $clicked.css('background','red');\n});\n```\n在这种方式中，只为一个元素绑定了事件，明显优于之前那种。\n在jQuery 1.7中，提供了新的方式on()来帮助我们将整个事件监听封装到一个便利的方法中。\n```javascript\n//good\n$(\"#mytable\").on('click','td',function(e){\n    $(this).css('background','red');\n});\n```\n\n### 四、将你的代码转换为jQuery插件\n如果每次都需要用一定的时间去开发类似的代码，那么可以考虑将代码变成插件。它能够使你的代码有更好的重用性，并且能够有效组织代码。创建插件的代码如下：\n```javascript\n(function($){\n    $.fn.pulgName = function(){\n        //code\n        return this;\n    }\n})(jQuery)\n```\n### 五、合理利用HTML的data属性\nHTML5的data属性可以帮助我们插入数据，特别是前后端的数据交换。jQuery的data()方法可以自动得到数据。例子：\n```html\n<div id=\"d1\" data-role=\"page\" data-last-value=\"43\" data-options='{\"name\":\"John\"}'></div>\n```\n读取数据：\n```javascript\n$(\"#d1\").data(\"role\");  //page\n$(\"#d1\").data(\"last-value\");  //43\n$(\"#d1\").data(\"options\").name;  //John\n```\n\n*——总结来自《锋利的jQuery》*","source":"_posts/jQueryPerformanceOptimization.md","raw":"title: jQuery性能优化\ndate: 2015-11-25 10:17:50\ntags: Javascript学习笔记\n---\njQuery已经成为前端开发中重要的类库之一，也是前端开发er的一个利器，了解到如何正确使用jQuery达到最佳性能是一个很重要的事。下面从各个方面来总结一下jQuery性能优化技巧和注意事项。\n<!-- more -->\n### 一、使用合适的选择器\n**$('#id')**\n使用id来定位DOM元素无疑是提高性能的最佳方式，因为这会直接调用本地方法`document.getElementById()`。\n如果这样找不到所需要的元素，可以使用find()方法。`$(\"#content\").find(\"div\");`为了提高性能，建议从最近的id元素开始往下搜索。\n\n**$('p'),$('div'),$('input')**\n标签选择器也不错，因为jQuery是直接调用本地方法`document.getElementsByTagName()`。\n\n**$('.class')**\n对于比较新的浏览器，它支持本地方法`document.getElementsByClassName()`。但是对于ie8及以下版本浏览器，只能通过DOM搜索的方法来实现，这无疑会带来一些性能的影响。建议有选择地使用。\n\n**$(\"[attribute=value]\")**\n对于利用属性来定位DOM元素，本地javascript并没有方法直接实现，大多是使用DOM搜索的方式来达到效果。很多现代浏览器支持querySelectAll()方法，但是不同浏览器的性能还是有区别。总体来说，使用这种方式性能不是非常理想，所以为了获得更好的优化效果，建议尽量避免这种对性能有害的方式。\n\n**$(\":hidden\")**\n和上面利用属性定位DOM元素一样，这种伪选择器也同样没有直接在本地javascript方法中实现，并且jQuery需要搜索每一个元素来定位这个选择器，这将对性能带来比较大的影响，所以建议尽量不要使用。如果非要使用，请先使用ID选择器定位父元素然后再使用该选择器，这样对性能优化有帮助。\n\n- **尽量使用ID选择器**\n- **尽量给选择器指定上下文**\n\n### 二、缓存对象\n其实这是javascript也需要注意的地方\n```javascript\n//bad\n$(\"#light\").bind('click',function(){...});\n$(\"#light\").css('border',\"1px solid red\");\n$(\"#light\").fadeIn(\"slow\");\n\n//good\nvar light = $(\"#light\");\nlight.bind('click',function(){...});\nlight.css('border',\"1px solid red\");\nlight.fadeIn(\"slow\");\n```\n本例中用链式方式将更加简洁，上面只是为了说明缓存变量的重要性。\n```javascript\n//链式\nvar light = $(\"#light\");\nlight.bind('click',function(){...})\n    .css('border',\"1px solid red\")\n    .fadeIn(\"slow\");\n```\n如果打算在其他函数中使用jQuery对象，那么可以把它们缓存到全局环境中。如下代码所示：\n```javascript\nwindow.$my = {\n    head : $('head'),\n    light: $('#light'),\n    light_button: $(\"#light_button\")\n};\nfunction dosomething(){\n    //现在可以引用存储结构并操作它们\n    var script = docuement.creatElement(\"script\");\n    $my.head.append(script);\n    // 当你在函数内部操作时，可以继续将查询存入全局对象中去\n    $my.cool_results = $(\"#some_ul li\");\n    $my.other_results = $(\"#some\");\n    // 全局函数作为一个普通的jquery对象去使用\n    $my.other_results.css(\"border-color\",\"red\");\n}\n```\n记住，永远不要让相同的选择器在你的代码里出现多次。\n\n### 三、事件代理\n每一个JavaScript事件（例如click、mouseover等）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时，这点会很好用。比如,我们要为一个表格绑定这样的行为：点击td后，把背景色设置为红色，代码如下：\n```javascript\n//bad\n$(\"#mytable td\").click(functuon(){\n   $(this).css('background','red');\n});\n```\n假如有100个td元素，在使用以上方式时，绑定了100个事件，这将带来很负面的性能影响。\n```javascript\n//good\n$(\"#mytable\").click(function(e){\n    var $clicked = $(e.target);//e.target 捕捉到触发的目标元素\n    $clicked.css('background','red');\n});\n```\n在这种方式中，只为一个元素绑定了事件，明显优于之前那种。\n在jQuery 1.7中，提供了新的方式on()来帮助我们将整个事件监听封装到一个便利的方法中。\n```javascript\n//good\n$(\"#mytable\").on('click','td',function(e){\n    $(this).css('background','red');\n});\n```\n\n### 四、将你的代码转换为jQuery插件\n如果每次都需要用一定的时间去开发类似的代码，那么可以考虑将代码变成插件。它能够使你的代码有更好的重用性，并且能够有效组织代码。创建插件的代码如下：\n```javascript\n(function($){\n    $.fn.pulgName = function(){\n        //code\n        return this;\n    }\n})(jQuery)\n```\n### 五、合理利用HTML的data属性\nHTML5的data属性可以帮助我们插入数据，特别是前后端的数据交换。jQuery的data()方法可以自动得到数据。例子：\n```html\n<div id=\"d1\" data-role=\"page\" data-last-value=\"43\" data-options='{\"name\":\"John\"}'></div>\n```\n读取数据：\n```javascript\n$(\"#d1\").data(\"role\");  //page\n$(\"#d1\").data(\"last-value\");  //43\n$(\"#d1\").data(\"options\").name;  //John\n```\n\n*——总结来自《锋利的jQuery》*","slug":"jQueryPerformanceOptimization","published":1,"updated":"2016-01-06T13:49:24.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdvzx001ss8rku9rp1pwo"},{"title":"关于jQuery的Deferred对象介绍（译）","date":"2016-03-25T09:28:50.000Z","_content":"\n(趁着毕设要求，翻译了一篇文章，顺便放上来。英文不好翻了2天才翻完，/(ㄒoㄒ)/~~如有错误欢迎指正。)\n原文链接:[An Introduction to jQuery’s Deferred Objects](http://www.sitepoint.com/introduction-jquery-deferred-objects/)\n\n长久以来，javascript的开发者习惯于使用回调函数去执行某些任务。一个常见的例子就是当某些事件比如`click`或者`keypress`执行的时候，通过`addEventListener()`添加回调函数。这样做的好处是，回调函数很简单，让工作能够很方便地完成，不幸的是，当你的网页变得越来越复杂而且你需要执行许多异步请求时，它们变得越来越难以处理。\n\nECMAScript2015引进了一个原生的方法去处理这种情况：promise。如果你不知道什么是promise，你可以读一读这篇文章[An Overview of JavaScript Promises](http://www.sitepoint.com/overview-javascript-promises/)。jQuery推出了它自己风格的promise，就是 __Deferred对象__ 。它在promise被引入ECMAScript之前几年就被引入了jqurey，在这篇文章里，我会讨论一下什么是`Deferred`对象，还有它解决了什么问题。\n\n## 一个简单的历史介绍\n`Deferred`对象在jQuery1.5版本被引入，它能让回调函数成为一个回调队列，继而被链式调用，它还能处理同步或者异步函数的成功或者失败状态。从此以后，它成为了一个课题被讨论和研究，也有一些批评的声音，伴随着批评和它也发生了许多改变。这里有两篇对它的批判性的文章：[You’re Missing the Point of Promises](https://blog.domenic.me/youre-missing-the-point-of-promises/)和[JavaScript Promises and why jQuery implementation is broken](https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/)。\n\n连同[Promise对象](http://api.jquery.com/Types/#Promise),Deferred代表了jQuery对于Promises的实现。在jQuery1.X版本和2.x版本里，deferred对象依附于[the CommonJS Promises/A proposal](http://wiki.commonjs.org/wiki/Promises/A)，这个提案被作为[Promises/A+ proposal](https://promisesaplus.com/)的基础，而原生的promises就是在此基础上建立的。正如前面所提到的，jQuery没有依附于 Promises/A+的原因是它在这之前就已经产生了。\n\n因为jQuery是一个先驱者，还由于向后兼容问题，在原生javascript里使用promise与在jQuery1.x、2.x版本里使用都有一些区别。而且，由于jQuery遵循了一个不同的提案，这个框架和其他实现了promises的框架比如[the Q library](https://github.com/kriskowal/q)是互不兼容的。\n\n在即将到来的 __jQuery 3__ 版本里，改进了与原生的Promises(在ECMAScript 2015被实现的)的兼容性。虽然有些主要的方法（then())还是由于向后兼容的原因和原生的Promises有些差别，但是其使用习惯已经越来越接近规范标准了。\n\n<h2 id=\"callbackJquery\">jQuery中的回调</h2>\n为了理解为什么你需要使用`Deferred`对象，让我们先讨论一个例子。当你使用jQuery的时候，一定经常使用它的ajax方法去处理异步请求。为了理解这个例子，让我们假设你正在开发一个网页并且正在向Github的API发送Ajax请求。你的目标是收到用户的仓库列表，找到最近更新过的仓库，找到第一个名为'README.md'的文件，最终接收到这个文件的内容。基于以上的描述，你每一个Ajax请求可能都会是在上一个步骤完成的时候发送，换句话说，这些请求必须在一个队列中执行。\n\n让我们把这些描述转换为代码（请注意我没有使用真的Github的API），我们得到以下代码：\n```javascript\nvar username = 'testuser';\nvar fileToSearch = 'README.md';\n\n$.getJSON('https://api.github.com/user/' + username + '/repositories', function(repositories) {\n  \n  var lastUpdatedRepository = repositories[0].name;\n\n  $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/files', function(files) {\n    var README = null;\n\n    for (var i = 0; i < files.length; i++) {\n      if (files[i].name.indexOf(fileToSearch) >= 0) {\n        README = files[i].path;\n\n        break;\n      }\n    }\n\n    $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/file/' + README + '/content', function(content) {\n      console.log('The content of the file is: ' + content);\n    });\n  });\n});\n\n```\n正如你在这个例子里看到的，为了达到目的，我们必须嵌套执行Ajax请求。这让我们的代码变得可读性比较差。在我们必须嵌套使用大量的回调，或者需要一个独立的回调函数需要和另一个函数以同步的方式执行时，我们通常称这种情况为“回调地狱”。\n\n为了让这种情况变好一点，你可以将我上面写的匿名函数提取出来命名。然而，这样改变也没啥帮助，我们仍然发现我们身处于回调地狱中。下面，我们就走进`Deferred`对象和`Promise`对象吧。\n\n## Deferred对象和Promise对象\nDeferred对象可以在执行异步操作的时候使用，比如Ajax请求和动画。在jQuery里，`Promise`对象创建于`Deferred`对象或者`jQuery`对象。它拥有`Deferred`对象下的方法，如：`always()`,`done()`,`fail()`,`state()`,和`then()`。我会在下面介绍这些方法。\n\n如果你是来自原生javascript世界的，你可能会对这两个对象的存在感到很困惑。为什么我们要有两个对象（`Deferred`和`Promise`），而原生Javascript只有一个（`Promise`)？为了解释他们的不同和他们的用例，我在我的书中对他们进行了类比[jQuery in Action, Third Edition](https://www.manning.com/books/jquery-in-action-third-edition)。\n\n一个使用`Deferred`对象的典型情况是，如果你正在编写一个函数去处理异步操作，并且可能会返回一个值（返回一个错误或者不返回值也行）。在这种情况下，你的函数是值的“生产者”，而且你希望阻止用户去改变`Deferred`的状态。当你是这个函数的消费者时，你就要使用`promise`。\n\n为了阐明这个观点，让我们假设你希望实现一个基于promise的 `timeout()`方法(下面是这个[例子的代码](#creatingapromisebasedsettimeoutfunction)。你负责写这个函数，但是必须等到获得一个时间的数字（在这个等待的情况下没有值返回），这让你成为一个“生产者”。你这个函数的“消费者”不需要关心去resolve它或者reject它，“消费者”只需要能够在Deferred执行完成后、失败后、或者进程中添加函数。另外，你想要确保你的“消费者”不能resolve或reject这个Deferred对象。为了达到这个目标，你需要在你创建的`timeoout()`函数中返回`Deferred`的`promise`对象，而不是`Deferred`对象本身。这样做之后，你能确保除了你的`timeout()`函数以外，没有人能够调用`resolve()`和`reject()`方法。\n\n你可以在[StackOverflow question](http://stackoverflow.com/questions/17308172/deferred-versus-promise)了解更多关于jQuery的Deferred对象和Promise对象的区别。\n\n现在你知道这些对象是什么了，让我们来了解一下这些方法的作用。\n\n## Deferred对象的方法\n`Deferred`对象非常灵活，提供了很多方法满足你的需求。它可以被创建为`jQuery.Deferred()`，方法如下：\n```javascript\nvar deferred = jQuery.Deferred();\n```\n或者，你也可以用`$`创建：\n```javascript\nvar deferred = $.Deferred();\n```\n一旦创建，这个`Deferred`对象就暴露了一些方法，除了那些不赞成使用的和被移除的方法，它暴露的方法有：\n\n- `always(callbacks[, callbacks, ..., callbacks]):` 在无论Deferred对象resolved还是rejected的时候都会执行。\n- `done(callbacks[, callbacks, ..., callbacks]):` 当Deferred对象resolved的时候执行。\n- `fail(callbacks[, callbacks, ..., callbacks]):` 当Deferred对象rejected的时候执行。\n- `notify([argument, ..., argument]):` 根据给定的 args参数 调用Deferred对象上进行中的回调 （progressCallbacks）。\n- `notifyWith(context[, argument, ..., argument]):` 根据给定的上下文（context）和args递延调用Deferred对象上进行中的回调（progressCallbacks ）。\n- `progress(callbacks[, callbacks, ..., callbacks])`:当Deferred（延迟）对象生成进度通知时，调用添加处理程序。\n- `promise([target]):` Return a Deferred‘s Promise object.\n- `reject([argument, ..., argument]):` 拒绝Deferred（延迟）对象，并根据给定的args参数调用任何失败回调函数（failCallbacks）。\n- `rejectWith(context[, argument, ..., argument]): `拒绝Deferred（延迟）对象，并根据给定的 context和args参数调用任何失败回调函数（failCallbacks）。\n- `resolve([argument, ..., argument]):` 解决Deferred（延迟）对象，并根据给定的args参数调用任何完成回调函数（doneCallbacks）。\n- `resolveWith(context[, argument, ..., argument]):` 解决Deferred（延迟）对象，并根据给定的 context和args参数调用任何完成回调函数（doneCallbacks）。\n- `state():`确定一个Deferred（延迟）对象的当前状态。\n- `then(resolvedCallback[, rejectedCallback[, progressCallback]]):` 当Deferred（延迟）对象解决，拒绝或仍在进行中时，调用添加处理程序。\n\n通过这些方法的描述，让我们能够更明显地了解到jQuery文档中的术语和ECMAScript标准里的区别。在ECMAScript标准里，一个promise对象被称作resolved是在他完成或者被拒绝的时候。然而，在jQuery文档里，resolved描述的只是在ECMAScript中的完成状态。\n\nDeferred提供了大量的方法，在本篇文章中不能全部介绍到。不过，在下面的内容中，我会展示一些`Deferred`对象和`Promise`对象的使用的例子。首先，我来会用Deferred对象重写一下在[jQuery中的回调](#callbackJquery)中的那段代码，然后我会把“生产者和消费者”的比喻再解释一下。\n\n## 用Deferred对象完成Ajax请求队列\n在这个章节我会展示怎么用Deferred对象和它的一些方法去提高[jQuery中的回调](#callbackJquery)里的那段代码的可读性，在开始探索之前，我们必须要明白我们需要用到哪些方法。\n\n根据我们的需求和上面列出的方法列表，很明显我们可以用`done()`或者`then()`方法去管理成功的状态。由于你们大多数可能已经习惯于使用Javascript的`Promise`对象，在这个例子中，我会选择使用`then()`方法。在这两个方法最重要的一个区别是`then()`方法能够\n将接收到的值作为参数传递给其他在后面调用的`then()`、`done()`、`fail()`或`progress()`方法。\n\n最后的代码：\n```javascript\nvar username = 'testuser';\nvar fileToSearch = 'README.md';\n\n$.getJSON('https://api.github.com/user/' + username + '/repositories')\n    .then(function(repositories) {\n        return repositories[0].name;\n    })\n    .then(function(lastUpdatedRepository) {\n        return $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/files');\n    })\n    .then(function(files) {\n        var README = null;\n\n        for (var i = 0; i < files.length; i++) {\n            if (files[i].name.indexOf(fileToSearch) >= 0) {\n                README = files[i].path;\n\n                break;\n            }\n        }\n\n        return README;\n    })\n    .then(function(README) {\n        return $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/file/' + README + '/content');\n    })\n    .then(function(content) {\n        console.log(content);\n    });\n```\n\n正如你看到的，这段代码比之前的可读性好了很多，因为我们能把每一个步骤拆开看，它们都同一级，没有嵌套。\n\n<h2 id=\"creatingapromisebasedsettimeoutfunction\">创造一个基于Promise的setTimeout函数</h2>\n你也许知道，`setTimeout()`能在指定的时间后执行回调函数。它的两个元素（回调函数和时间）都应该作为参数被提供。让我们假设你想要1秒后在控制台打印一段信息。使用`setTimeout()`，你可以达到这个目的：\n\n```javascript\nsetTimeout(\n  function() {\n    console.log('I waited for 1 second!');\n  },\n  1000\n);\n```\n\n正如你所见，第一个参数是一个想要被执行的函数，第二个是多少需要等待的毫秒数。这个函数一向很有用，但是如果你想用通过`Deferred`队列实现呢？\n\n在下面我会告诉你怎么用jQuery提供的`Promise`对象完成一个基于promise的`setTimeout()`函数。\n\n最后的代码：\n```javascript\nfunction timeout(milliseconds) {\n    // Create a new Deferred object\n    var deferred = $.Deferred();\n\n    // Resolve the Deferred after the amount of time specified by milliseconds\n    setTimeout(deferred.resolve, milliseconds);\n\n    // Return the Deferred's Promise object\n    return deferred.promise();\n}\n\ntimeout(1000).then(function() {\n    console.log('I waited for 1 second!');\n});\n```\n我定义了一个`timeout()`函数，包裹了javaScript的原生`setTimeout()`方法。在`timeout()`方法里我创建了一个新的`Deferred`对象去管理异步任务，在`milliseconds`时间后`deferred`对象被设置为resolve状态。在这种情况下，`timeout()`函数是这个值的生产者，所以它创建了`Deferred`对象还返回了`Promise`对象。通过这样，我能确保这个函数的调用者（消费者）不能够resolve或者reject这个`Deferred`对象。事实上，这个调用者只能添加函数去执行，和使用`done()`,`faile()`等方法。\n\n## jQuery 1.x/2.x 与 jQuery 3的区别\n在第一个例子里，我们创建了一段代码去查找一个名为\"README.md\"的文件，但是我们没有处理这个文件没有被找到的情况。这种情况应该被称作失败的情况，当失败发送时，我们可能需要去打断这个队列直接结束。如果这样做的话它会很自然的抛出一个异常，取到这个异常后被fail()这个方法执行，就像你在js里面用的catch()方法一样。\n\n遵循Promises/A和Promises/A+的库（比如jQuery3.x），抛出的异常是被转换为rejection然后调用错误回调函数，比如`fail()`，被捕获的异常会作为参数传递进去。\n\n在jQuery1.x和2.x版本中，未被捕获的异常会终止程序的执行，这些版本下允许抛出的异常冒泡，通常是达到`window.onerror`。如果没有定义函数去处理这个异常，这个异常信息会在控制台显示，而且会中断代码执行。\n\n为了更好的理解他们不同的地方，让我们看看这个例子：\n```javascript\nvar deferred = $.Deferred();\ndeferred\n  .then(function() {\n    throw new Error('An error message');\n  })\n  .then(\n    function() {\n      console.log('First success function');\n    },\n    function() {\n      console.log('First failure function');\n    }\n  )\n  .then(\n    function() {\n      console.log('Second success function');\n    },\n    function() {\n      console.log('Second failure function');\n    }\n  );\n\ndeferred.resolve();\n\n```\n在jQuery3.x版本中，会打印信息\"First failure function\"和\"Second success function\"到控制台。原因就和我上面说的一样，一个抛出的异常会被转变为`rejection`，然后错误处理函数会在这时候被调用。而且，一旦异常被管理到（在这个例子中传递给了第二个`then()`），接下来的成功回调函数会被调用（本例中的第三个`then()`）。\n\n在jQuery1.x和2.x版本中，只有第一个函数（抛出异常的函数）会执行，然后你会看到在控制台输出了\"Uncaught Error: An error message\"。\n\n__jQuery 1.x/2.x__\n<iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/nozege/embed?js,console\" src=\"http://jsbin.com/nozege/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe>\n__jQuery3__\n<iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/kifazi/embed?js,console\" src=\"http://jsbin.com/kifazi/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe>\n\n为了进一步提高它与ECMAScript 2015的兼容性，jQuery3也给`Deferred`和`Promise`对象添加了一个`catch()`方法。它是被定义来处理`Deferred`对象`rejected`或者 它的`Promise`对象处于rejected的情况：\n```javascript\ndeferred.catch(rejectedCallback)\n```\n这个方法只是`then(null,rejectedCallback)`的简写形式。\n\n## 总结\n在这篇文章里，我向你介绍了jQuery对于promises的实现方式。Promises让你不用很麻烦地让异步函数并行起来，也不用在回调函数里嵌套回调函数再嵌套回调函数……\n\n除此之外，我也介绍了jQuery3怎么提升它和原生promise的兼容性。尽管老版本的jQuery和ECMAScript 2015的还有比较明显的不同，`Deferred`对象仍然是一个令人难以置信的强大的工具。作为一个专业的开发者，随着项目难度的增加，你会发现你会经常用到它。\n","source":"_posts/introduction-jquery-deferred-objects.md","raw":"title: 关于jQuery的Deferred对象介绍（译）\ndate: 2016-03-25 17:28:50\ntags: web前端知识\n---\n\n(趁着毕设要求，翻译了一篇文章，顺便放上来。英文不好翻了2天才翻完，/(ㄒoㄒ)/~~如有错误欢迎指正。)\n原文链接:[An Introduction to jQuery’s Deferred Objects](http://www.sitepoint.com/introduction-jquery-deferred-objects/)\n\n长久以来，javascript的开发者习惯于使用回调函数去执行某些任务。一个常见的例子就是当某些事件比如`click`或者`keypress`执行的时候，通过`addEventListener()`添加回调函数。这样做的好处是，回调函数很简单，让工作能够很方便地完成，不幸的是，当你的网页变得越来越复杂而且你需要执行许多异步请求时，它们变得越来越难以处理。\n\nECMAScript2015引进了一个原生的方法去处理这种情况：promise。如果你不知道什么是promise，你可以读一读这篇文章[An Overview of JavaScript Promises](http://www.sitepoint.com/overview-javascript-promises/)。jQuery推出了它自己风格的promise，就是 __Deferred对象__ 。它在promise被引入ECMAScript之前几年就被引入了jqurey，在这篇文章里，我会讨论一下什么是`Deferred`对象，还有它解决了什么问题。\n\n## 一个简单的历史介绍\n`Deferred`对象在jQuery1.5版本被引入，它能让回调函数成为一个回调队列，继而被链式调用，它还能处理同步或者异步函数的成功或者失败状态。从此以后，它成为了一个课题被讨论和研究，也有一些批评的声音，伴随着批评和它也发生了许多改变。这里有两篇对它的批判性的文章：[You’re Missing the Point of Promises](https://blog.domenic.me/youre-missing-the-point-of-promises/)和[JavaScript Promises and why jQuery implementation is broken](https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/)。\n\n连同[Promise对象](http://api.jquery.com/Types/#Promise),Deferred代表了jQuery对于Promises的实现。在jQuery1.X版本和2.x版本里，deferred对象依附于[the CommonJS Promises/A proposal](http://wiki.commonjs.org/wiki/Promises/A)，这个提案被作为[Promises/A+ proposal](https://promisesaplus.com/)的基础，而原生的promises就是在此基础上建立的。正如前面所提到的，jQuery没有依附于 Promises/A+的原因是它在这之前就已经产生了。\n\n因为jQuery是一个先驱者，还由于向后兼容问题，在原生javascript里使用promise与在jQuery1.x、2.x版本里使用都有一些区别。而且，由于jQuery遵循了一个不同的提案，这个框架和其他实现了promises的框架比如[the Q library](https://github.com/kriskowal/q)是互不兼容的。\n\n在即将到来的 __jQuery 3__ 版本里，改进了与原生的Promises(在ECMAScript 2015被实现的)的兼容性。虽然有些主要的方法（then())还是由于向后兼容的原因和原生的Promises有些差别，但是其使用习惯已经越来越接近规范标准了。\n\n<h2 id=\"callbackJquery\">jQuery中的回调</h2>\n为了理解为什么你需要使用`Deferred`对象，让我们先讨论一个例子。当你使用jQuery的时候，一定经常使用它的ajax方法去处理异步请求。为了理解这个例子，让我们假设你正在开发一个网页并且正在向Github的API发送Ajax请求。你的目标是收到用户的仓库列表，找到最近更新过的仓库，找到第一个名为'README.md'的文件，最终接收到这个文件的内容。基于以上的描述，你每一个Ajax请求可能都会是在上一个步骤完成的时候发送，换句话说，这些请求必须在一个队列中执行。\n\n让我们把这些描述转换为代码（请注意我没有使用真的Github的API），我们得到以下代码：\n```javascript\nvar username = 'testuser';\nvar fileToSearch = 'README.md';\n\n$.getJSON('https://api.github.com/user/' + username + '/repositories', function(repositories) {\n  \n  var lastUpdatedRepository = repositories[0].name;\n\n  $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/files', function(files) {\n    var README = null;\n\n    for (var i = 0; i < files.length; i++) {\n      if (files[i].name.indexOf(fileToSearch) >= 0) {\n        README = files[i].path;\n\n        break;\n      }\n    }\n\n    $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/file/' + README + '/content', function(content) {\n      console.log('The content of the file is: ' + content);\n    });\n  });\n});\n\n```\n正如你在这个例子里看到的，为了达到目的，我们必须嵌套执行Ajax请求。这让我们的代码变得可读性比较差。在我们必须嵌套使用大量的回调，或者需要一个独立的回调函数需要和另一个函数以同步的方式执行时，我们通常称这种情况为“回调地狱”。\n\n为了让这种情况变好一点，你可以将我上面写的匿名函数提取出来命名。然而，这样改变也没啥帮助，我们仍然发现我们身处于回调地狱中。下面，我们就走进`Deferred`对象和`Promise`对象吧。\n\n## Deferred对象和Promise对象\nDeferred对象可以在执行异步操作的时候使用，比如Ajax请求和动画。在jQuery里，`Promise`对象创建于`Deferred`对象或者`jQuery`对象。它拥有`Deferred`对象下的方法，如：`always()`,`done()`,`fail()`,`state()`,和`then()`。我会在下面介绍这些方法。\n\n如果你是来自原生javascript世界的，你可能会对这两个对象的存在感到很困惑。为什么我们要有两个对象（`Deferred`和`Promise`），而原生Javascript只有一个（`Promise`)？为了解释他们的不同和他们的用例，我在我的书中对他们进行了类比[jQuery in Action, Third Edition](https://www.manning.com/books/jquery-in-action-third-edition)。\n\n一个使用`Deferred`对象的典型情况是，如果你正在编写一个函数去处理异步操作，并且可能会返回一个值（返回一个错误或者不返回值也行）。在这种情况下，你的函数是值的“生产者”，而且你希望阻止用户去改变`Deferred`的状态。当你是这个函数的消费者时，你就要使用`promise`。\n\n为了阐明这个观点，让我们假设你希望实现一个基于promise的 `timeout()`方法(下面是这个[例子的代码](#creatingapromisebasedsettimeoutfunction)。你负责写这个函数，但是必须等到获得一个时间的数字（在这个等待的情况下没有值返回），这让你成为一个“生产者”。你这个函数的“消费者”不需要关心去resolve它或者reject它，“消费者”只需要能够在Deferred执行完成后、失败后、或者进程中添加函数。另外，你想要确保你的“消费者”不能resolve或reject这个Deferred对象。为了达到这个目标，你需要在你创建的`timeoout()`函数中返回`Deferred`的`promise`对象，而不是`Deferred`对象本身。这样做之后，你能确保除了你的`timeout()`函数以外，没有人能够调用`resolve()`和`reject()`方法。\n\n你可以在[StackOverflow question](http://stackoverflow.com/questions/17308172/deferred-versus-promise)了解更多关于jQuery的Deferred对象和Promise对象的区别。\n\n现在你知道这些对象是什么了，让我们来了解一下这些方法的作用。\n\n## Deferred对象的方法\n`Deferred`对象非常灵活，提供了很多方法满足你的需求。它可以被创建为`jQuery.Deferred()`，方法如下：\n```javascript\nvar deferred = jQuery.Deferred();\n```\n或者，你也可以用`$`创建：\n```javascript\nvar deferred = $.Deferred();\n```\n一旦创建，这个`Deferred`对象就暴露了一些方法，除了那些不赞成使用的和被移除的方法，它暴露的方法有：\n\n- `always(callbacks[, callbacks, ..., callbacks]):` 在无论Deferred对象resolved还是rejected的时候都会执行。\n- `done(callbacks[, callbacks, ..., callbacks]):` 当Deferred对象resolved的时候执行。\n- `fail(callbacks[, callbacks, ..., callbacks]):` 当Deferred对象rejected的时候执行。\n- `notify([argument, ..., argument]):` 根据给定的 args参数 调用Deferred对象上进行中的回调 （progressCallbacks）。\n- `notifyWith(context[, argument, ..., argument]):` 根据给定的上下文（context）和args递延调用Deferred对象上进行中的回调（progressCallbacks ）。\n- `progress(callbacks[, callbacks, ..., callbacks])`:当Deferred（延迟）对象生成进度通知时，调用添加处理程序。\n- `promise([target]):` Return a Deferred‘s Promise object.\n- `reject([argument, ..., argument]):` 拒绝Deferred（延迟）对象，并根据给定的args参数调用任何失败回调函数（failCallbacks）。\n- `rejectWith(context[, argument, ..., argument]): `拒绝Deferred（延迟）对象，并根据给定的 context和args参数调用任何失败回调函数（failCallbacks）。\n- `resolve([argument, ..., argument]):` 解决Deferred（延迟）对象，并根据给定的args参数调用任何完成回调函数（doneCallbacks）。\n- `resolveWith(context[, argument, ..., argument]):` 解决Deferred（延迟）对象，并根据给定的 context和args参数调用任何完成回调函数（doneCallbacks）。\n- `state():`确定一个Deferred（延迟）对象的当前状态。\n- `then(resolvedCallback[, rejectedCallback[, progressCallback]]):` 当Deferred（延迟）对象解决，拒绝或仍在进行中时，调用添加处理程序。\n\n通过这些方法的描述，让我们能够更明显地了解到jQuery文档中的术语和ECMAScript标准里的区别。在ECMAScript标准里，一个promise对象被称作resolved是在他完成或者被拒绝的时候。然而，在jQuery文档里，resolved描述的只是在ECMAScript中的完成状态。\n\nDeferred提供了大量的方法，在本篇文章中不能全部介绍到。不过，在下面的内容中，我会展示一些`Deferred`对象和`Promise`对象的使用的例子。首先，我来会用Deferred对象重写一下在[jQuery中的回调](#callbackJquery)中的那段代码，然后我会把“生产者和消费者”的比喻再解释一下。\n\n## 用Deferred对象完成Ajax请求队列\n在这个章节我会展示怎么用Deferred对象和它的一些方法去提高[jQuery中的回调](#callbackJquery)里的那段代码的可读性，在开始探索之前，我们必须要明白我们需要用到哪些方法。\n\n根据我们的需求和上面列出的方法列表，很明显我们可以用`done()`或者`then()`方法去管理成功的状态。由于你们大多数可能已经习惯于使用Javascript的`Promise`对象，在这个例子中，我会选择使用`then()`方法。在这两个方法最重要的一个区别是`then()`方法能够\n将接收到的值作为参数传递给其他在后面调用的`then()`、`done()`、`fail()`或`progress()`方法。\n\n最后的代码：\n```javascript\nvar username = 'testuser';\nvar fileToSearch = 'README.md';\n\n$.getJSON('https://api.github.com/user/' + username + '/repositories')\n    .then(function(repositories) {\n        return repositories[0].name;\n    })\n    .then(function(lastUpdatedRepository) {\n        return $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/files');\n    })\n    .then(function(files) {\n        var README = null;\n\n        for (var i = 0; i < files.length; i++) {\n            if (files[i].name.indexOf(fileToSearch) >= 0) {\n                README = files[i].path;\n\n                break;\n            }\n        }\n\n        return README;\n    })\n    .then(function(README) {\n        return $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/file/' + README + '/content');\n    })\n    .then(function(content) {\n        console.log(content);\n    });\n```\n\n正如你看到的，这段代码比之前的可读性好了很多，因为我们能把每一个步骤拆开看，它们都同一级，没有嵌套。\n\n<h2 id=\"creatingapromisebasedsettimeoutfunction\">创造一个基于Promise的setTimeout函数</h2>\n你也许知道，`setTimeout()`能在指定的时间后执行回调函数。它的两个元素（回调函数和时间）都应该作为参数被提供。让我们假设你想要1秒后在控制台打印一段信息。使用`setTimeout()`，你可以达到这个目的：\n\n```javascript\nsetTimeout(\n  function() {\n    console.log('I waited for 1 second!');\n  },\n  1000\n);\n```\n\n正如你所见，第一个参数是一个想要被执行的函数，第二个是多少需要等待的毫秒数。这个函数一向很有用，但是如果你想用通过`Deferred`队列实现呢？\n\n在下面我会告诉你怎么用jQuery提供的`Promise`对象完成一个基于promise的`setTimeout()`函数。\n\n最后的代码：\n```javascript\nfunction timeout(milliseconds) {\n    // Create a new Deferred object\n    var deferred = $.Deferred();\n\n    // Resolve the Deferred after the amount of time specified by milliseconds\n    setTimeout(deferred.resolve, milliseconds);\n\n    // Return the Deferred's Promise object\n    return deferred.promise();\n}\n\ntimeout(1000).then(function() {\n    console.log('I waited for 1 second!');\n});\n```\n我定义了一个`timeout()`函数，包裹了javaScript的原生`setTimeout()`方法。在`timeout()`方法里我创建了一个新的`Deferred`对象去管理异步任务，在`milliseconds`时间后`deferred`对象被设置为resolve状态。在这种情况下，`timeout()`函数是这个值的生产者，所以它创建了`Deferred`对象还返回了`Promise`对象。通过这样，我能确保这个函数的调用者（消费者）不能够resolve或者reject这个`Deferred`对象。事实上，这个调用者只能添加函数去执行，和使用`done()`,`faile()`等方法。\n\n## jQuery 1.x/2.x 与 jQuery 3的区别\n在第一个例子里，我们创建了一段代码去查找一个名为\"README.md\"的文件，但是我们没有处理这个文件没有被找到的情况。这种情况应该被称作失败的情况，当失败发送时，我们可能需要去打断这个队列直接结束。如果这样做的话它会很自然的抛出一个异常，取到这个异常后被fail()这个方法执行，就像你在js里面用的catch()方法一样。\n\n遵循Promises/A和Promises/A+的库（比如jQuery3.x），抛出的异常是被转换为rejection然后调用错误回调函数，比如`fail()`，被捕获的异常会作为参数传递进去。\n\n在jQuery1.x和2.x版本中，未被捕获的异常会终止程序的执行，这些版本下允许抛出的异常冒泡，通常是达到`window.onerror`。如果没有定义函数去处理这个异常，这个异常信息会在控制台显示，而且会中断代码执行。\n\n为了更好的理解他们不同的地方，让我们看看这个例子：\n```javascript\nvar deferred = $.Deferred();\ndeferred\n  .then(function() {\n    throw new Error('An error message');\n  })\n  .then(\n    function() {\n      console.log('First success function');\n    },\n    function() {\n      console.log('First failure function');\n    }\n  )\n  .then(\n    function() {\n      console.log('Second success function');\n    },\n    function() {\n      console.log('Second failure function');\n    }\n  );\n\ndeferred.resolve();\n\n```\n在jQuery3.x版本中，会打印信息\"First failure function\"和\"Second success function\"到控制台。原因就和我上面说的一样，一个抛出的异常会被转变为`rejection`，然后错误处理函数会在这时候被调用。而且，一旦异常被管理到（在这个例子中传递给了第二个`then()`），接下来的成功回调函数会被调用（本例中的第三个`then()`）。\n\n在jQuery1.x和2.x版本中，只有第一个函数（抛出异常的函数）会执行，然后你会看到在控制台输出了\"Uncaught Error: An error message\"。\n\n__jQuery 1.x/2.x__\n<iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/nozege/embed?js,console\" src=\"http://jsbin.com/nozege/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe>\n__jQuery3__\n<iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/kifazi/embed?js,console\" src=\"http://jsbin.com/kifazi/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe>\n\n为了进一步提高它与ECMAScript 2015的兼容性，jQuery3也给`Deferred`和`Promise`对象添加了一个`catch()`方法。它是被定义来处理`Deferred`对象`rejected`或者 它的`Promise`对象处于rejected的情况：\n```javascript\ndeferred.catch(rejectedCallback)\n```\n这个方法只是`then(null,rejectedCallback)`的简写形式。\n\n## 总结\n在这篇文章里，我向你介绍了jQuery对于promises的实现方式。Promises让你不用很麻烦地让异步函数并行起来，也不用在回调函数里嵌套回调函数再嵌套回调函数……\n\n除此之外，我也介绍了jQuery3怎么提升它和原生promise的兼容性。尽管老版本的jQuery和ECMAScript 2015的还有比较明显的不同，`Deferred`对象仍然是一个令人难以置信的强大的工具。作为一个专业的开发者，随着项目难度的增加，你会发现你会经常用到它。\n","slug":"introduction-jquery-deferred-objects","published":1,"updated":"2016-07-04T07:09:21.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdw01001us8rkygih0xmd"},{"title":"Less is more","date":"2015-11-09T02:17:50.000Z","_content":"\n工作中为了模块化，我们会采用less进行开发。所以充分了解less的使用方法可以使开发变得更加有效率。\n<!-- more -->\n\n>LESS是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS的赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。\n\n>LESS可以在多种语言、环境中使用，包括浏览器端、桌面客户端、服务端。\n\n下面介绍一下less的用法（更详细内容见[官方文档](http://www.1024i.com/demo/less/document.html)）：\n\n#### 一、LESS注释：\n1. /\\* 注释内容 \\*/ \n这种注释方法编译后，注释内容会保留到css文件内容中。\n\n2. //注释内容 \n这种注释方法编译后，注释内容不会保留到css文件中。\n\n#### 二、变量：\n我们可以像js一样为css定义变量并重复使用它。\n语法：@变量名:值;\nLESS源码：\n\n    @color: #4D926F;\n\n    #header {\n        color: @color;\n    }\n    h2 {\n        color: @color;\n    }\n编译后的css:\n\n    #header {\n        color: #4D926F;\n    }\n    h2 {\n        color: #4D926F;\n    }\n\n#### 三、混合\n混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以**带参数**地调用，就像使用函数一样。\n\nLESS源码：\n\n    .rounded-corners (@radius: 5px) {//带了默认值，如果调用时未传参数，则默认此值\n        -webkit-border-radius: @radius;\n        -moz-border-radius: @radius;\n        -ms-border-radius: @radius;\n        -o-border-radius: @radius;\n        border-radius: @radius;\n    }\n\n    #header {\n        .rounded-corners;\n    }\n    #footer {\n        .rounded-corners(10px);//传了参数 改变了@radius的值\n    }\n\n编译后的CSS：\n\n    #header {\n        -webkit-border-radius: 5px;\n        -moz-border-radius: 5px;\n        -ms-border-radius: 5px;\n        -o-border-radius: 5px;\n        border-radius: 5px;\n    }\n    #footer {\n        -webkit-border-radius: 10px;\n        -moz-border-radius: 10px;\n        -ms-border-radius: 10px;\n        -o-border-radius: 10px;\n        border-radius: 10px;\n    }\n\n#### 嵌套\n我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。\n\nLESS源码：\n\n    #header {\n        h1 {\n            font-size: 26px;\n            font-weight: bold;\n        }\n        p {\n            font-size: 12px;\n            a {\n                text-decoration: none;\n                &:hover {\n                    border-width: 1px\n                }\n            }\n        }\n    }\n\n编译后的CSS：\n\n    #header h1 {\n        font-size: 26px;\n        font-weight: bold;\n    }\n    #header p {\n        font-size: 12px;\n    }\n    #header p a {\n        text-decoration: none;\n    }\n    #header p a:hover {\n        border-width: 1px;\n    }\n\n但是我更建议定义类名来调用，不建议用标签或者多层嵌套。","source":"_posts/Less is more.md","raw":"title: Less is more\ndate: 2015-11-09 10:17:50\ntags: css学习心得\n---\n\n工作中为了模块化，我们会采用less进行开发。所以充分了解less的使用方法可以使开发变得更加有效率。\n<!-- more -->\n\n>LESS是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS的赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。\n\n>LESS可以在多种语言、环境中使用，包括浏览器端、桌面客户端、服务端。\n\n下面介绍一下less的用法（更详细内容见[官方文档](http://www.1024i.com/demo/less/document.html)）：\n\n#### 一、LESS注释：\n1. /\\* 注释内容 \\*/ \n这种注释方法编译后，注释内容会保留到css文件内容中。\n\n2. //注释内容 \n这种注释方法编译后，注释内容不会保留到css文件中。\n\n#### 二、变量：\n我们可以像js一样为css定义变量并重复使用它。\n语法：@变量名:值;\nLESS源码：\n\n    @color: #4D926F;\n\n    #header {\n        color: @color;\n    }\n    h2 {\n        color: @color;\n    }\n编译后的css:\n\n    #header {\n        color: #4D926F;\n    }\n    h2 {\n        color: #4D926F;\n    }\n\n#### 三、混合\n混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以**带参数**地调用，就像使用函数一样。\n\nLESS源码：\n\n    .rounded-corners (@radius: 5px) {//带了默认值，如果调用时未传参数，则默认此值\n        -webkit-border-radius: @radius;\n        -moz-border-radius: @radius;\n        -ms-border-radius: @radius;\n        -o-border-radius: @radius;\n        border-radius: @radius;\n    }\n\n    #header {\n        .rounded-corners;\n    }\n    #footer {\n        .rounded-corners(10px);//传了参数 改变了@radius的值\n    }\n\n编译后的CSS：\n\n    #header {\n        -webkit-border-radius: 5px;\n        -moz-border-radius: 5px;\n        -ms-border-radius: 5px;\n        -o-border-radius: 5px;\n        border-radius: 5px;\n    }\n    #footer {\n        -webkit-border-radius: 10px;\n        -moz-border-radius: 10px;\n        -ms-border-radius: 10px;\n        -o-border-radius: 10px;\n        border-radius: 10px;\n    }\n\n#### 嵌套\n我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。\n\nLESS源码：\n\n    #header {\n        h1 {\n            font-size: 26px;\n            font-weight: bold;\n        }\n        p {\n            font-size: 12px;\n            a {\n                text-decoration: none;\n                &:hover {\n                    border-width: 1px\n                }\n            }\n        }\n    }\n\n编译后的CSS：\n\n    #header h1 {\n        font-size: 26px;\n        font-weight: bold;\n    }\n    #header p {\n        font-size: 12px;\n    }\n    #header p a {\n        text-decoration: none;\n    }\n    #header p a:hover {\n        border-width: 1px;\n    }\n\n但是我更建议定义类名来调用，不建议用标签或者多层嵌套。","slug":"Less is more","published":1,"updated":"2016-01-06T13:49:38.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdw04001ws8rkuzh3lb8l"},{"title":"JavaScript实践","date":"2015-09-30T02:17:50.000Z","_content":"---\n### 命名\n\n代码是给人(别人或者1个星期后的 自己)阅读和修改的 \n\n給变量和函数一个简单易懂的名字 \n\n可维护性++\n\n** 以功能命名,而不是表现  isOverSeven() × VS isLegalAge() √ **\n\n    // 不好的命名\n    aaaa  \n    x1  \n    f  \n    hengxian  \n    createNewUserIfTheInputIsValida\n    te\n   避免全局变量\n\n> 我们无法拥有代码的控制权\n\n* 不易维护 \n* 牵一发而动全身 \n* 易被覆盖,修改,而你还不知道\n\n\n     // Bad\n    var currentColor;\n    var colorMap = {\n        red: '红色',\n        green: '绿色',\n        yellow: '黄色'\n    };\n    \n    function init() {\n        currentColor = 'red';\n    }\n        \n\n    // Common\n    (function () {\n        var currentColor;\n        \n        var colorMap = {\n            red: '红色',\n            green: '绿色',\n            yellow: '黄色'\n        };\n        \n        function init () {\n            currentColor = 'red';\n        }\n    })();\n    \n    // Good\n    var colorManager = function () {  \n    var currentColor;  \n    var colorMap  =  {           \n        red: '红色',           \n        green: '绿色',           \n        yellow: '黄色' \n    };  \n\n        return  { \n            init: function () {                   \n                currentColor  =  'red'          \n            } \n        } \n    }();\n    \n---\n### 正确的注释\n\n注释也是代码的一部分 \n\n错误的注释,相比没有注释,更可怕 \n\n介绍背景、介绍使用方式、介绍注意事项,不要重复代码的意思\n\n    //  已登陆的用户,有  name  和  age  两个属性  \n    var loginedUser = {           \n        name:  '',           \n        age:  10  \n    };\n    /*  \n        *  统一登录方法  \n        *  在需要登录的地方调用       \n        *  如果已经登陆,会立即执行回调       \n        *  否则,会显示登录窗口,登录完成后执行回 调  \n        *  todo:登录窗口的  UI  优化  \n    */  \n    function login(cb) {  \n    }\n\n---\n### 简短标记\n\n简短标记让代码更简单易读\n\n    // Bad\n    var user = new Object;\n    user.name = 'bajiefe';\n    user.age = 20;\n    \n    // Good\n    var user = {\n        name: 'bajiefe',\n        age: 20\n    };\n    \n    // Bad\n    var userList = new Array;\n    userList[0] = 'bajiefe';\n    userList[1] = 'bajierd';\n    \n    // Good\n    var userList = ['bajiefe', 'bajierd'];\n    \n    \n    // Bad\n    var age;\n    if(val) {\n        age = val;\n    } else {\n        age = 10;\n    }\n    \n    // Good\n    var age = val || 10;\n    \n    \n    // Bad\n    var direction;\n    \n    if(val) {\n        direction = 1;\n    } else {\n        direction = -1;\n    }\n    \n    // Good\n    var direction = val ? 1 : -1;\n---\n### 减少DOM 操作\n\n通过 className 来控制 DOM 样式\n\n    // Bad\n    userInput.style.cssText = 'color: red; border: 1px  solid  red;'  \n    \n    // Good\n    userInput.className  =  ‘error;’\n\ndom 节点修改好后再插入 dom  tree\n    \n    // Bad\n    function addAnchor(parentElement, anchorText, anchorClass) {\n        var element = document.createElement('a');\n        parentElement.appendChild(element);\n        element.innerHTML = anchorText;\n        element.className = anchorClass;\n    }\n    \n    // Good\n    var element = document.createElement('a');\n    element.innerHTML = anchorText;\n    element.className = anchorClass;\n    parentElement.appendChild(element);\n\n通过文档片段创建 DOM\n    \n    document.createDocumentFragment();\n    \n    function addAnchors(element) {\n        var anchor;\n        var fragment = document.createDocumentFragment();\n    \n        for(var i = 0; i < 10; i++) {\n            anchor = document.createElement('a');\n            anchor.innerHTML = 'test';\n            fragment.appendChild(anchor);\n        }\n    \n        element.appendChild(fragment);\n    }\n\n通过事件代理绑定事件\n\n---\n### 自动分号插入\n\n当不清楚写不写分号时,写上\n\n    var tester = function() {\n    \n    }\n    \n    (function() {\n        console.log(tester);\n    })()\n    \n    var a = 123\n\n---\n### Debug\nGoogle 开发者工具","source":"_posts/JavaScript实践.md","raw":"title: JavaScript实践\ndate: 2015-09-30 10:17:50\ntag: Javascript学习笔记\n---\n---\n### 命名\n\n代码是给人(别人或者1个星期后的 自己)阅读和修改的 \n\n給变量和函数一个简单易懂的名字 \n\n可维护性++\n\n** 以功能命名,而不是表现  isOverSeven() × VS isLegalAge() √ **\n\n    // 不好的命名\n    aaaa  \n    x1  \n    f  \n    hengxian  \n    createNewUserIfTheInputIsValida\n    te\n   避免全局变量\n\n> 我们无法拥有代码的控制权\n\n* 不易维护 \n* 牵一发而动全身 \n* 易被覆盖,修改,而你还不知道\n\n\n     // Bad\n    var currentColor;\n    var colorMap = {\n        red: '红色',\n        green: '绿色',\n        yellow: '黄色'\n    };\n    \n    function init() {\n        currentColor = 'red';\n    }\n        \n\n    // Common\n    (function () {\n        var currentColor;\n        \n        var colorMap = {\n            red: '红色',\n            green: '绿色',\n            yellow: '黄色'\n        };\n        \n        function init () {\n            currentColor = 'red';\n        }\n    })();\n    \n    // Good\n    var colorManager = function () {  \n    var currentColor;  \n    var colorMap  =  {           \n        red: '红色',           \n        green: '绿色',           \n        yellow: '黄色' \n    };  \n\n        return  { \n            init: function () {                   \n                currentColor  =  'red'          \n            } \n        } \n    }();\n    \n---\n### 正确的注释\n\n注释也是代码的一部分 \n\n错误的注释,相比没有注释,更可怕 \n\n介绍背景、介绍使用方式、介绍注意事项,不要重复代码的意思\n\n    //  已登陆的用户,有  name  和  age  两个属性  \n    var loginedUser = {           \n        name:  '',           \n        age:  10  \n    };\n    /*  \n        *  统一登录方法  \n        *  在需要登录的地方调用       \n        *  如果已经登陆,会立即执行回调       \n        *  否则,会显示登录窗口,登录完成后执行回 调  \n        *  todo:登录窗口的  UI  优化  \n    */  \n    function login(cb) {  \n    }\n\n---\n### 简短标记\n\n简短标记让代码更简单易读\n\n    // Bad\n    var user = new Object;\n    user.name = 'bajiefe';\n    user.age = 20;\n    \n    // Good\n    var user = {\n        name: 'bajiefe',\n        age: 20\n    };\n    \n    // Bad\n    var userList = new Array;\n    userList[0] = 'bajiefe';\n    userList[1] = 'bajierd';\n    \n    // Good\n    var userList = ['bajiefe', 'bajierd'];\n    \n    \n    // Bad\n    var age;\n    if(val) {\n        age = val;\n    } else {\n        age = 10;\n    }\n    \n    // Good\n    var age = val || 10;\n    \n    \n    // Bad\n    var direction;\n    \n    if(val) {\n        direction = 1;\n    } else {\n        direction = -1;\n    }\n    \n    // Good\n    var direction = val ? 1 : -1;\n---\n### 减少DOM 操作\n\n通过 className 来控制 DOM 样式\n\n    // Bad\n    userInput.style.cssText = 'color: red; border: 1px  solid  red;'  \n    \n    // Good\n    userInput.className  =  ‘error;’\n\ndom 节点修改好后再插入 dom  tree\n    \n    // Bad\n    function addAnchor(parentElement, anchorText, anchorClass) {\n        var element = document.createElement('a');\n        parentElement.appendChild(element);\n        element.innerHTML = anchorText;\n        element.className = anchorClass;\n    }\n    \n    // Good\n    var element = document.createElement('a');\n    element.innerHTML = anchorText;\n    element.className = anchorClass;\n    parentElement.appendChild(element);\n\n通过文档片段创建 DOM\n    \n    document.createDocumentFragment();\n    \n    function addAnchors(element) {\n        var anchor;\n        var fragment = document.createDocumentFragment();\n    \n        for(var i = 0; i < 10; i++) {\n            anchor = document.createElement('a');\n            anchor.innerHTML = 'test';\n            fragment.appendChild(anchor);\n        }\n    \n        element.appendChild(fragment);\n    }\n\n通过事件代理绑定事件\n\n---\n### 自动分号插入\n\n当不清楚写不写分号时,写上\n\n    var tester = function() {\n    \n    }\n    \n    (function() {\n        console.log(tester);\n    })()\n    \n    var a = 123\n\n---\n### Debug\nGoogle 开发者工具","slug":"JavaScript实践","published":1,"updated":"2016-01-06T13:49:13.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdw0c001ys8rk6h02ksj1"},{"title":"js中文输入法字符串截断问题解决","date":"2016-01-27T06:06:50.000Z","_content":"最近遇到了一个需求：一个输入框最大输入字数为7个字，用户输入超出7个字时，显示警告提示，并且阻止用户输入。\n\n用input propertychange事件可以监听到用户的输入，在英文或者数字输入状态是没有问题的。但是在中文输入法输入情况下，不同浏览器有不同的表现。有的浏览器会在输入拼音时就会进入判断，如果拼音就已经超过7个字符，就不能再继续输入。\n如下：\n```html\n<input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">\n        var test = $('#test');\n        test.on('input propertychange', function() {\n            var value = $(this).val();\n            console.log('当前输入：'+value);\n            if(value.length>7){\n                $(this).val(value.substring(0,7));\n                $('.warn').show()\n            }else{\n                $('.warn').hide();\n            }\n        })\n    </script>\n```\n<textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">var test = $('#test');test.on('input propertychange', function(){var value = $(this).val();console.log('当前输入：'+value);if(value.length>7){$(this).val(value.substring(0,7));$('.warn').show()}else{$('.warn').hide();}})</script><body></textarea>\n\n<input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n运行以上代码可以发现，比如我想输入“报价方案”时，如果打全拼根本无法打出来就被阻止了。在网上找了解决方案之后，发现了一些以前没听过的事件。\n\n>#### 复合事件\n复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理IME的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计的。\n       （1）compositionstart：在IME的文本复合系统打开时触发，表示要开始输入了。\n（2）compositionupdate：在向输入字段中插入新字符时触发。\n（3）compositionend：在IME的文本复合系统关闭时触发，表示返回正常键盘的输入状态。\n\n用这个事件，我们可以实现中文输入法截断的问题了。如下：\n\n```html\n    <input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">\n        var test = $('#test');\n        test.on('input propertychange change', function() {\n            if($(this).prop('comStart')) return;    // 中文输入过程中不截断\n            var value = $(this).val();\n            console.log('当前输入：'+value);\n            if(value.length>7){\n                $(this).val(value.substring(0,7));\n                $('.warn').show()\n            }else{\n                $('.warn').hide();\n            }\n        }).on('compositionstart', function(){\n            $(this).prop('comStart', true);\n            console.log('中文输入：开始');\n        }).on('compositionend', function(){\n            $(this).prop('comStart', false);\n            console.log('中文输入：结束');\n        });\n    </script>\n```\n<textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span><script type=\"text/javascript\">var test = $('#test');test.on('input propertychange change', function(){if($(this).prop('comStart')) return;var value = $(this).val();console.log('当前输入：'+value);if(value.length>7){$(this).val(value.substring(0,7));$('.warn').show()}else{$('.warn').hide();}}).on('compositionstart', function(){$(this).prop('comStart', true);console.log('中文输入：开始');}).on('compositionend', function(){$(this).prop('comStart', false);console.log('中文输入：结束');});</script><body></textarea>\n\n<input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n![完美](http://i4.tietuku.com/e52018b653051022.jpg)\n\n","source":"_posts/ChineseInputMethods.md","raw":"title: js中文输入法字符串截断问题解决\ndate: 2016-01-27 14:06:50\ntags: Javascript学习笔记\n\n---\n最近遇到了一个需求：一个输入框最大输入字数为7个字，用户输入超出7个字时，显示警告提示，并且阻止用户输入。\n\n用input propertychange事件可以监听到用户的输入，在英文或者数字输入状态是没有问题的。但是在中文输入法输入情况下，不同浏览器有不同的表现。有的浏览器会在输入拼音时就会进入判断，如果拼音就已经超过7个字符，就不能再继续输入。\n如下：\n```html\n<input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">\n        var test = $('#test');\n        test.on('input propertychange', function() {\n            var value = $(this).val();\n            console.log('当前输入：'+value);\n            if(value.length>7){\n                $(this).val(value.substring(0,7));\n                $('.warn').show()\n            }else{\n                $('.warn').hide();\n            }\n        })\n    </script>\n```\n<textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">var test = $('#test');test.on('input propertychange', function(){var value = $(this).val();console.log('当前输入：'+value);if(value.length>7){$(this).val(value.substring(0,7));$('.warn').show()}else{$('.warn').hide();}})</script><body></textarea>\n\n<input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n运行以上代码可以发现，比如我想输入“报价方案”时，如果打全拼根本无法打出来就被阻止了。在网上找了解决方案之后，发现了一些以前没听过的事件。\n\n>#### 复合事件\n复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理IME的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计的。\n       （1）compositionstart：在IME的文本复合系统打开时触发，表示要开始输入了。\n（2）compositionupdate：在向输入字段中插入新字符时触发。\n（3）compositionend：在IME的文本复合系统关闭时触发，表示返回正常键盘的输入状态。\n\n用这个事件，我们可以实现中文输入法截断的问题了。如下：\n\n```html\n    <input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">\n        var test = $('#test');\n        test.on('input propertychange change', function() {\n            if($(this).prop('comStart')) return;    // 中文输入过程中不截断\n            var value = $(this).val();\n            console.log('当前输入：'+value);\n            if(value.length>7){\n                $(this).val(value.substring(0,7));\n                $('.warn').show()\n            }else{\n                $('.warn').hide();\n            }\n        }).on('compositionstart', function(){\n            $(this).prop('comStart', true);\n            console.log('中文输入：开始');\n        }).on('compositionend', function(){\n            $(this).prop('comStart', false);\n            console.log('中文输入：结束');\n        });\n    </script>\n```\n<textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span><script type=\"text/javascript\">var test = $('#test');test.on('input propertychange change', function(){if($(this).prop('comStart')) return;var value = $(this).val();console.log('当前输入：'+value);if(value.length>7){$(this).val(value.substring(0,7));$('.warn').show()}else{$('.warn').hide();}}).on('compositionstart', function(){$(this).prop('comStart', true);console.log('中文输入：开始');}).on('compositionend', function(){$(this).prop('comStart', false);console.log('中文输入：结束');});</script><body></textarea>\n\n<input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n![完美](http://i4.tietuku.com/e52018b653051022.jpg)\n\n","slug":"ChineseInputMethods","published":1,"updated":"2016-07-04T07:09:21.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdw0g0020s8rkq4nkb0xp"},{"title":"2016年计划（目标）","date":"2016-02-17T02:17:50.000Z","_content":"农历新年也已经过完了，我也该给自己打打鸡血，制定一个2016年的目标了。\n<!-- more -->\n2015年，充满转折和幸运的一年。从运营转前端，也离开学校在外实习了大半年，去过杭州2个月，互联网环境很好的一个城市，但还是发现自己更爱起伏不平的山城和麻辣火锅。后来回到重庆，幸运地进入了猪八戒，也幸运地认识了一些志同道合的小伙伴和一些前辈大神。\n\n为了能够有一个美好的2016年，我制定了以下目标激励自己：\n\n1. 无特殊情况，每天晚上睡前做半个小时以上运动\n2. 无特殊情况，每天晚上睡前看半个小时以上书，看完书单上的书。\n3. 拿驾照\n4. 完成毕业设计期间学习，达成学习目标（另待细定）\n5. 存钱毕业旅行\n6. 存钱买mac pro\n7. 会做一桌好吃的菜\n\n我感觉这几个目标（除了拿驾照）对拖延癌懒癌月光族的我来说都好难..(ノ_<)\n我每个月末都来回顾总结一下目标的完成情况吧。加油。","source":"_posts/2016年计划（目标）.md","raw":"title: 2016年计划（目标）\ndate: 2016-02-17 10:17:50\ntags: 生活琐事\n---\n农历新年也已经过完了，我也该给自己打打鸡血，制定一个2016年的目标了。\n<!-- more -->\n2015年，充满转折和幸运的一年。从运营转前端，也离开学校在外实习了大半年，去过杭州2个月，互联网环境很好的一个城市，但还是发现自己更爱起伏不平的山城和麻辣火锅。后来回到重庆，幸运地进入了猪八戒，也幸运地认识了一些志同道合的小伙伴和一些前辈大神。\n\n为了能够有一个美好的2016年，我制定了以下目标激励自己：\n\n1. 无特殊情况，每天晚上睡前做半个小时以上运动\n2. 无特殊情况，每天晚上睡前看半个小时以上书，看完书单上的书。\n3. 拿驾照\n4. 完成毕业设计期间学习，达成学习目标（另待细定）\n5. 存钱毕业旅行\n6. 存钱买mac pro\n7. 会做一桌好吃的菜\n\n我感觉这几个目标（除了拿驾照）对拖延癌懒癌月光族的我来说都好难..(ノ_<)\n我每个月末都来回顾总结一下目标的完成情况吧。加油。","slug":"2016年计划（目标）","published":1,"updated":"2016-07-04T07:09:21.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq7qdw0i0022s8rkjrbm1ckx"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciq7qdvwj0001s8rkrtdwe1cq","tag_id":"ciq7qdvwp0002s8rkixoqmo67","_id":"ciq7qdvws0003s8rkqb8jyb0t"},{"post_id":"ciq7qdvwu0004s8rkqrh76qll","tag_id":"ciq7qdvww0005s8rk1vioapge","_id":"ciq7qdvww0006s8rkascgj84z"},{"post_id":"ciq7qdvwx0007s8rk532y651h","tag_id":"ciq7qdvwz0008s8rk0czrsqcu","_id":"ciq7qdvwz0009s8rkxyn0jez6"},{"post_id":"ciq7qdvx1000as8rk8ehc1p16","tag_id":"ciq7qdvx2000bs8rk2lfnnsdk","_id":"ciq7qdvx3000cs8rkx053f9qp"},{"post_id":"ciq7qdvx4000ds8rk78h8o35n","tag_id":"ciq7qdvwz0008s8rk0czrsqcu","_id":"ciq7qdvx5000es8rkw1zvkqwj"},{"post_id":"ciq7qdvx7000fs8rk3lhtm8tn","tag_id":"ciq7qdvx8000gs8rkujqpn6n8","_id":"ciq7qdvx9000hs8rks07tex7p"},{"post_id":"ciq7qdvxb000is8rkqm3cxkdy","tag_id":"ciq7qdvx8000gs8rkujqpn6n8","_id":"ciq7qdvxc000js8rk5x7yk1ps"},{"post_id":"ciq7qdvxd000ks8rkehlom12y","tag_id":"ciq7qdvx8000gs8rkujqpn6n8","_id":"ciq7qdvxf000ls8rkd0gf45iz"},{"post_id":"ciq7qdvxh000ms8rk91ncd6td","tag_id":"ciq7qdvx8000gs8rkujqpn6n8","_id":"ciq7qdvxi000ns8rklq4uxqpv"},{"post_id":"ciq7qdvxj000os8rk5wwu5mnf","tag_id":"ciq7qdvx8000gs8rkujqpn6n8","_id":"ciq7qdvxl000ps8rk5pfxy46w"},{"post_id":"ciq7qdvxp000qs8rko5k2dutv","tag_id":"ciq7qdvx8000gs8rkujqpn6n8","_id":"ciq7qdvxq000rs8rkpjtikp02"},{"post_id":"ciq7qdvxs000ss8rkn08okcc8","tag_id":"ciq7qdvx8000gs8rkujqpn6n8","_id":"ciq7qdvxt000ts8rk9qbbk5dm"},{"post_id":"ciq7qdvxv000us8rkbt4mbl7w","tag_id":"ciq7qdvwz0008s8rk0czrsqcu","_id":"ciq7qdvxx000vs8rk7mhzp4ux"},{"post_id":"ciq7qdvy0000ws8rk9ipzy9id","tag_id":"ciq7qdvy1000xs8rkpfchjyrc","_id":"ciq7qdvy3000ys8rkk4rn5hz9"},{"post_id":"ciq7qdvyf000zs8rkc8dwlkyd","tag_id":"ciq7qdvx2000bs8rk2lfnnsdk","_id":"ciq7qdvyi0010s8rkul2f2ky8"},{"post_id":"ciq7qdvyj0011s8rka1bbdzfr","tag_id":"ciq7qdvx2000bs8rk2lfnnsdk","_id":"ciq7qdvyl0012s8rkpc7mnmer"},{"post_id":"ciq7qdvym0013s8rk0775bmad","tag_id":"ciq7qdvwz0008s8rk0czrsqcu","_id":"ciq7qdvyn0014s8rkz98hkxys"},{"post_id":"ciq7qdvyo0015s8rkc9nabp4v","tag_id":"ciq7qdvyq0016s8rkos05gxd7","_id":"ciq7qdvyq0017s8rkm24sylro"},{"post_id":"ciq7qdvyr0018s8rk3k6iah6s","tag_id":"ciq7qdvyq0016s8rkos05gxd7","_id":"ciq7qdvyt0019s8rkbb068pct"},{"post_id":"ciq7qdvyv001as8rkarde1dcx","tag_id":"ciq7qdvyq0016s8rkos05gxd7","_id":"ciq7qdvyw001bs8rkhvki3xrd"},{"post_id":"ciq7qdvyy001cs8rk61kdkws3","tag_id":"ciq7qdvyq0016s8rkos05gxd7","_id":"ciq7qdvyz001ds8rklzb7neiv"},{"post_id":"ciq7qdvz0001es8rk7idwkbec","tag_id":"ciq7qdvyq0016s8rkos05gxd7","_id":"ciq7qdvz2001fs8rk7yyrd2im"},{"post_id":"ciq7qdvz3001gs8rkw82ryaq2","tag_id":"ciq7qdvyq0016s8rkos05gxd7","_id":"ciq7qdvz5001hs8rkntsdox7c"},{"post_id":"ciq7qdvz7001is8rkx28flfbd","tag_id":"ciq7qdvyq0016s8rkos05gxd7","_id":"ciq7qdvz8001js8rklmiyxg53"},{"post_id":"ciq7qdvza001ks8rkz5i90ypz","tag_id":"ciq7qdvyq0016s8rkos05gxd7","_id":"ciq7qdvzf001ls8rk3hy2y1tm"},{"post_id":"ciq7qdvzh001ms8rkn1nc77oe","tag_id":"ciq7qdvyq0016s8rkos05gxd7","_id":"ciq7qdvzk001ns8rkq259k1bx"},{"post_id":"ciq7qdvzm001os8rkbul3ogtd","tag_id":"ciq7qdvyq0016s8rkos05gxd7","_id":"ciq7qdvzs001ps8rk13ydx5xj"},{"post_id":"ciq7qdvzu001qs8rkuydhba0m","tag_id":"ciq7qdvyq0016s8rkos05gxd7","_id":"ciq7qdvzv001rs8rkn4nquds1"},{"post_id":"ciq7qdvzx001ss8rku9rp1pwo","tag_id":"ciq7qdvwz0008s8rk0czrsqcu","_id":"ciq7qdvzy001ts8rkce8z06ed"},{"post_id":"ciq7qdw01001us8rkygih0xmd","tag_id":"ciq7qdvx2000bs8rk2lfnnsdk","_id":"ciq7qdw03001vs8rkyksdgfzu"},{"post_id":"ciq7qdw04001ws8rkuzh3lb8l","tag_id":"ciq7qdvy1000xs8rkpfchjyrc","_id":"ciq7qdw06001xs8rkwslsl3ki"},{"post_id":"ciq7qdw0c001ys8rk6h02ksj1","tag_id":"ciq7qdvwz0008s8rk0czrsqcu","_id":"ciq7qdw0e001zs8rkgp8fichs"},{"post_id":"ciq7qdw0g0020s8rkq4nkb0xp","tag_id":"ciq7qdvwz0008s8rk0czrsqcu","_id":"ciq7qdw0h0021s8rkbs9ff76q"},{"post_id":"ciq7qdw0i0022s8rkjrbm1ckx","tag_id":"ciq7qdw0j0023s8rku38crg7c","_id":"ciq7qdw0k0024s8rk1soo43w6"}],"Tag":[{"name":"矫情不是病","_id":"ciq7qdvwp0002s8rkixoqmo67"},{"name":"二次元","_id":"ciq7qdvww0005s8rk1vioapge"},{"name":"Javascript学习笔记","_id":"ciq7qdvwz0008s8rk0czrsqcu"},{"name":"web前端知识","_id":"ciq7qdvx2000bs8rk2lfnnsdk"},{"name":"学习日报","_id":"ciq7qdvx8000gs8rkujqpn6n8"},{"name":"css学习心得","_id":"ciq7qdvy1000xs8rkpfchjyrc"},{"name":"node.js学习笔记","_id":"ciq7qdvyq0016s8rkos05gxd7"},{"name":"生活琐事","_id":"ciq7qdw0j0023s8rku38crg7c"}]}}