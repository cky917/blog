{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/mabao-theme/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"source/images/1.png","path":"images/1.png","modified":1,"renderable":0},{"_id":"themes/mabao-theme/source/css/normalize.css","path":"css/normalize.css","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/css/screen.css","path":"css/screen.css","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/fonts/icons.ttf","path":"fonts/icons.ttf","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/fonts/icons.woff","path":"fonts/icons.woff","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/fonts/icons.eot","path":"fonts/icons.eot","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/3.png","path":"img/3.png","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/2.png","path":"img/2.png","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/5.png","path":"img/5.png","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/icons-demo-nav.png","path":"img/icons-demo-nav.png","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/6.jpg","path":"img/6.jpg","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/img-bg.jpg","path":"img/img-bg.jpg","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/mogu.png","path":"img/mogu.png","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/js/jquery.fitvids.js","path":"js/jquery.fitvids.js","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/js/index.js","path":"js/index.js","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/js/menu.js","path":"js/menu.js","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/js/underscore-min.js","path":"js/underscore-min.js","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/fonts/icons.svg","path":"fonts/icons.svg","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/1.png","path":"img/1.png","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/4.png","path":"img/4.png","modified":1,"renderable":1},{"_id":"themes/mabao-theme/source/img/icons-demo-nav.svg","path":"img/icons-demo-nav.svg","modified":1,"renderable":1},{"_id":"source/images/QQ20170411-194256@2x.png","path":"images/QQ20170411-194256@2x.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"341a1bd24be6da36f01d2e5438abcb47b7b7d5b5","modified":1474560651000},{"_id":"source/.DS_Store","hash":"d1659a65fdd018dd5438ea45f260cf934f62d655","modified":1488360008000},{"_id":"themes/mabao-theme/README.md","hash":"6fd796e7fb3d1063a1f1ea105718665c8b90d3af","modified":1474560651000},{"_id":"themes/mabao-theme/LICENSE","hash":"829c901a3c1fcada6ba7b35115d2bc9b17d35d6d","modified":1474560651000},{"_id":"themes/mabao-theme/.DS_Store","hash":"6433979259fa87ee92c5a20e3a8c66b7a3915ef4","modified":1474560651000},{"_id":"themes/mabao-theme/_config.yml","hash":"08fc54957aae4fcb6b2b891de82326a0697323ab","modified":1497235332000},{"_id":"source/_posts/Less is more.md","hash":"0df23546c5e01c2f9fe21bf0bec3d416b5a0ab20","modified":1474560752000},{"_id":"source/_posts/JavaScript实践.md","hash":"54e0ff8c333e218002e558e1b8d6147a81a2e153","modified":1474560651000},{"_id":"source/_posts/ChineseInputMethods.md","hash":"7e7810b33ed5122051f849e64f2c0476deae1fda","modified":1488963346000},{"_id":"source/_posts/2016年计划（目标）.md","hash":"de48a18efb6e662f10083f49a689a50d2bde9503","modified":1479795384000},{"_id":"source/_posts/jQueryPerformanceOptimization.md","hash":"4209845675cb815e69412d90e7ef03c1c1f1512f","modified":1474560651000},{"_id":"source/_posts/debounce-and-throttle.md","hash":"a1354075bc6d51a50f022c82e2bf763c711ba642","modified":1489115689000},{"_id":"source/_posts/mocha.md","hash":"5e6090f1347a787ba8d7fea158cccc3fcf921e7a","modified":1484143705000},{"_id":"source/_posts/introduction-jquery-deferred-objects.md","hash":"66e1c76dab380e5b0c069462595bebf85994d13b","modified":1474560651000},{"_id":"source/_posts/nodeJsStudy10.md","hash":"174b93947189d1eb490cdc1f4b6bb730306d9655","modified":1474560651000},{"_id":"source/_posts/nodeJsStudy11.md","hash":"e512298603250f29783a07054c21b8415bdbd981","modified":1474560651000},{"_id":"source/_posts/nodeJsStudy1.md","hash":"471af7aa84c7a18daa40274a16d4bf3123c768e9","modified":1474560651000},{"_id":"source/_posts/my2016and2017.md","hash":"1b8cb9fb91839d800ee697779b3fb4bb496bce07","modified":1488333671000},{"_id":"source/_posts/nodeJsStudy3.md","hash":"2b677db6e5e8a7937bbba1474e94312de2f69985","modified":1474560651000},{"_id":"source/_posts/nodeJsStudy4.md","hash":"4d8f1e874ca012a21f068cf4bd1644cbe892d7be","modified":1474560651000},{"_id":"source/_posts/nodeJsStudy2.md","hash":"4be22b81684508fb5b6b792eb23d191f66fabdc8","modified":1474560651000},{"_id":"source/_posts/nodeJsStudy8.md","hash":"f1d58f0ba11eb47373744872fa0bc3ec5feebe74","modified":1474560651000},{"_id":"source/_posts/nodeJsStudy6.md","hash":"611a75f2b12c1422e64d509459767cf814f918bd","modified":1474560651000},{"_id":"source/_posts/nodeJsStudy7.md","hash":"452b657617bd2e98e53018eebe63f42a3de0286c","modified":1474560651000},{"_id":"source/_posts/nodeJsStudy9.md","hash":"85a9853f6aedc38d2951162b3dca3de6d5c10b7a","modified":1474560651000},{"_id":"source/_posts/nodeJsStudy5.md","hash":"63f8d879cfb0b35e955cca4ea08c2916ac8ac13b","modified":1474560651000},{"_id":"source/_posts/postMessage-api.md","hash":"d20e6c341ef4e970d7c37ff99d368bd599e201dc","modified":1502879952000},{"_id":"source/_posts/pm2-node-service.md","hash":"7bb1e370b5bc2f07efb9516bc07618b295c8675f","modified":1486190250000},{"_id":"source/_posts/wxPachong.md","hash":"780de35cb6b51475f7193d9541ffe63ce2ba82a1","modified":1494557755000},{"_id":"source/_posts/webpack.md","hash":"df595bd6499e19b126cd1eb9e709d269847049e6","modified":1502209623000},{"_id":"source/_posts/reading-notes-Of-ECMAScript6.md","hash":"aedcfe82c2a9a5fe05a177639bfc9daad06fbaa4","modified":1484539182000},{"_id":"source/_posts/前端知识收集.md","hash":"f7106d4e76aa6d9eebcfc3949fb0d006e72b877b","modified":1474560651000},{"_id":"source/_posts/各种居中布局的css实现方法.md","hash":"60b614027f9669677d972e28584987537f1bfbf6","modified":1474560651000},{"_id":"source/_posts/不是只有“if else”.md","hash":"bf7f9c69c02c146ae70ce129a66a82612357e369","modified":1474560651000},{"_id":"source/_posts/利用fiddler进行前端调试.md","hash":"c1d5294c14a76bf5d65f75ac7dc36889ed6464dd","modified":1474560651000},{"_id":"source/_posts/数组的常用方法.md","hash":"34587a669581c282771c60233caee282ecc0319b","modified":1474560651000},{"_id":"source/_posts/浏览器的重绘与重排.md","hash":"815e86c776555a6a02427374ead7bd0a811aa7dd","modified":1474560651000},{"_id":"source/_posts/用js原生实现Ajax的get和post.md","hash":"cc41584607b964d41461ed0dbef408f2e9ec95c4","modified":1474560651000},{"_id":"source/_posts/好玩的cookie.md","hash":"a4da58d8cf2e6d801d1afcf14bff64e8bc50d0aa","modified":1474560651000},{"_id":"source/_posts/请问，你也是一只蘑菇吗.md","hash":"182a738f056261a75e6cbaae8d4be2790c4a9637","modified":1474560651000},{"_id":"source/_posts/请问您今天要来点兔子吗.md","hash":"d10ff4b6d759951d583b39247d2571fb9b0c36f8","modified":1474560651000},{"_id":"source/my-project/index.md","hash":"edd1b8220ab0837cc8c3e60668128ec70942795a","modified":1497235500000},{"_id":"source/about-me/index.md","hash":"a620beddb38d9d62570d09b92678708805c1e32a","modified":1474560651000},{"_id":"themes/mabao-theme/layout/archive.ejs","hash":"1704d02907207de6d4b6207bd9debf926740d82d","modified":1474560651000},{"_id":"themes/mabao-theme/layout/category.ejs","hash":"1704d02907207de6d4b6207bd9debf926740d82d","modified":1474560651000},{"_id":"themes/mabao-theme/layout/index.ejs","hash":"eaf7e49f416afce6685e36a24a65a01bb3fe9ae7","modified":1474560651000},{"_id":"themes/mabao-theme/layout/page.ejs","hash":"13a176d843e7d44921e2705203011f0fcb46fcda","modified":1474560651000},{"_id":"themes/mabao-theme/layout/layout.ejs","hash":"6166baed38ba72ec56198452f25db2244f471117","modified":1484129378000},{"_id":"themes/mabao-theme/layout/post.ejs","hash":"29b2b6725cc9569514e625b47a6b14d61b4c47a3","modified":1484128875000},{"_id":"themes/mabao-theme/layout/tag.ejs","hash":"1c08b8753d87aa44e8993baf5ad923e8d0957e82","modified":1474560651000},{"_id":"themes/mabao-theme/source/favicon.ico","hash":"b5e3d38751ecdf6b22037db5224e43e9186d78de","modified":1474560651000},{"_id":"source/images/1.png","hash":"4567294489a8899fa9f84e25e40cdd444b2e9095","modified":1484816529000},{"_id":"themes/mabao-theme/layout/_widget/recent_posts.ejs","hash":"71ef3cb726163e2c2919e06c0726e7b3494b21f4","modified":1474560651000},{"_id":"themes/mabao-theme/layout/_widget/archive.ejs","hash":"c28e42bc3ef16e90319053efac1ca971406591fe","modified":1497235402000},{"_id":"themes/mabao-theme/layout/_widget/category.ejs","hash":"a2ee566e88073b16aa50cfea8313a862a99ce00c","modified":1484127911000},{"_id":"themes/mabao-theme/layout/_widget/tag.ejs","hash":"b84ddcafa59c058718ee04b20bc0439a80a511b3","modified":1474560651000},{"_id":"themes/mabao-theme/layout/_widget/tagcloud.ejs","hash":"411a58c4d10b2a75f4a03cc0437c7b9878a7b4a6","modified":1474560651000},{"_id":"themes/mabao-theme/layout/casper/after_all.ejs","hash":"29d55bffdaf3debfdd1e4b0ad97975af334158a8","modified":1488883464000},{"_id":"themes/mabao-theme/layout/casper/index.ejs","hash":"d8743543dcdb630052e48f57d45eaaf1f218ce94","modified":1484129342000},{"_id":"themes/mabao-theme/layout/casper/footer.ejs","hash":"df79f821637e003618606039990c7025fb34cfed","modified":1502877048000},{"_id":"themes/mabao-theme/layout/casper/header.ejs","hash":"c7a2e062d2a410e546ec2d7399ff7adc246df712","modified":1474560651000},{"_id":"themes/mabao-theme/layout/casper/head.ejs","hash":"4e6b45bb7424640f3d92ab9c4457003437f5335f","modified":1484277701000},{"_id":"themes/mabao-theme/layout/casper/post.ejs","hash":"ca0f53de01f3009ea842dd09a16e82c56001e7ac","modified":1488963810000},{"_id":"themes/mabao-theme/layout/casper/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1474560651000},{"_id":"themes/mabao-theme/source/css/normalize.css","hash":"2d45c1546b603f967845038c6e34ccf8b6a986b8","modified":1474560651000},{"_id":"themes/mabao-theme/source/css/style.css","hash":"8fa96fc8289d6d4699334580dfcb9ca3d4553f88","modified":1484277419000},{"_id":"themes/mabao-theme/source/css/screen.css","hash":"03aa8ac103657f1f3bd062c74947cbebeb4a8564","modified":1494916949000},{"_id":"themes/mabao-theme/source/fonts/icons.ttf","hash":"2169592997f694ffa05b1d4c23d5a1abf35d3203","modified":1474560651000},{"_id":"themes/mabao-theme/source/fonts/icons.woff","hash":"af538de6ac19d5da1cada203c7451ce32f5daceb","modified":1474560651000},{"_id":"themes/mabao-theme/source/fonts/icons.eot","hash":"e307fc2d61d13bbc3aafc9abd75e727cbebadee1","modified":1474560651000},{"_id":"themes/mabao-theme/source/img/3.png","hash":"9c903cd0002e1edd4d46c866ce74b536dd07d164","modified":1474560651000},{"_id":"themes/mabao-theme/source/img/2.png","hash":"20c48a04db04b142e99e5b5f34a3cdebae6eb40e","modified":1474560651000},{"_id":"themes/mabao-theme/source/img/5.png","hash":"a25863789e27cad0a8dfe66daaed697c0c7ce1f7","modified":1474560651000},{"_id":"themes/mabao-theme/source/img/icons-demo-nav.png","hash":"4508247661f7883fed94386acf61f9b05e324dce","modified":1474560651000},{"_id":"themes/mabao-theme/source/img/6.jpg","hash":"988c4da6a326aea83263534e14e63ff32c9c1981","modified":1474560651000},{"_id":"themes/mabao-theme/source/img/logo.svg","hash":"b18a559dadc4ceb3b96e3cbc5ed704a3da9c39ca","modified":1474560651000},{"_id":"themes/mabao-theme/source/img/logo.png","hash":"158c1cc2dc9d72b5782078d4114adb30649eb9d0","modified":1474560651000},{"_id":"themes/mabao-theme/source/img/img-bg.jpg","hash":"4cf609b11d89b38d2a641a8810dcf6a2bf78a716","modified":1474560651000},{"_id":"themes/mabao-theme/source/img/mogu.png","hash":"74606326921ad39398269cd98f6bd9cba471af8f","modified":1474560651000},{"_id":"themes/mabao-theme/source/js/jquery.fitvids.js","hash":"0d9ee59f102516b1a988490f27ed37440713cc8b","modified":1474560651000},{"_id":"themes/mabao-theme/source/js/index.js","hash":"9bca2a96b38159b83c231982e4758b69ee8aaec3","modified":1488884117000},{"_id":"themes/mabao-theme/source/js/menu.js","hash":"c429f19136ebb7e7fe76001f6589bc5d16d39c1d","modified":1474560651000},{"_id":"themes/mabao-theme/source/js/underscore-min.js","hash":"2a515632e0fd8ffdeb8d94cb25e44cf287feb32f","modified":1427988721000},{"_id":"themes/mabao-theme/source/fonts/icons.svg","hash":"4b8357c608c01f304789e34bfd133081c1fc8b9d","modified":1474560651000},{"_id":"themes/mabao-theme/source/img/1.png","hash":"579ec39681f74bcfaa89889d97cd00a3a8a262d0","modified":1474560651000},{"_id":"themes/mabao-theme/theme-p1.png","hash":"9711fd87f5f814527de230c2f1a51d0fe635d4ce","modified":1474560651000},{"_id":"themes/mabao-theme/layout/casper/post/author.ejs","hash":"d7eb9e85d3bd514cdc03100c4b91f088ad92b539","modified":1474560651000},{"_id":"themes/mabao-theme/layout/casper/post/meta.ejs","hash":"2ebec566f482c288709caa4382642bf36915501f","modified":1474560651000},{"_id":"themes/mabao-theme/layout/casper/post/comments.ejs","hash":"7b196783b1cfb5151f9d25b9b9d7fab785eecfd9","modified":1494916479000},{"_id":"themes/mabao-theme/layout/casper/post/navigation.ejs","hash":"2d9d6d2e53c2e1cc061ef609d03b863388116187","modified":1474560651000},{"_id":"themes/mabao-theme/layout/casper/post/share.ejs","hash":"a248e2477f6437b976b4a73b6312b13f3c80b400","modified":1474560651000},{"_id":"themes/mabao-theme/layout/casper/post/toc.ejs","hash":"4c9c160c5276adcbfb491f7c5e0092142d91bdc5","modified":1484286864000},{"_id":"themes/mabao-theme/source/img/4.png","hash":"bbf39670aaa4abf6cd1e3bdb2abca8b03362b845","modified":1474560651000},{"_id":"themes/mabao-theme/theme.gif","hash":"14df48dfcda94912b8e0d0dd046410d8a30dc51c","modified":1474560651000},{"_id":"themes/mabao-theme/source/img/icons-demo-nav.svg","hash":"59d3af4b2c86a3cf73da4614efe01b1c43333a5a","modified":1474560651000},{"_id":"source/images/QQ20170411-194256@2x.png","hash":"91db55ee07cc8c7fbcb8a08233f6e6fc08607f20","modified":1491910980000},{"_id":"public/my-project/index.html","hash":"7c9b156282a8646a2c87397b49ec530bfbd5b46f","modified":1506589120537},{"_id":"public/about-me/index.html","hash":"961d2956f9f7806011e4751970ac15e1fd48a78c","modified":1506589120542},{"_id":"public/2017/08/14/postMessage-api/index.html","hash":"aa3646cbf5feac3140100ae2922f48b090bd3144","modified":1506589120579},{"_id":"public/2017/08/08/webpack/index.html","hash":"79ea936dd3aa3ba011143b722dab5bfba60ec331","modified":1506589120581},{"_id":"public/2017/05/10/wxPachong/index.html","hash":"db19facf79e660e009d2c1b000e7ef8c5980b2eb","modified":1506589120581},{"_id":"public/2016/12/19/my2016and2017/index.html","hash":"5d80c8581bb614eaad9f4e707bee1dd88830e954","modified":1506589120581},{"_id":"public/2016/02/24/利用fiddler进行前端调试/index.html","hash":"ff34f16706ba8489d83ebd5d0b3bf0c005d2bdd9","modified":1506589120581},{"_id":"public/2016/02/17/2016年计划（目标）/index.html","hash":"2124a37aceaf6b7974a1b05fbc0d6ca628a7536a","modified":1506589120581},{"_id":"public/2016/01/27/ChineseInputMethods/index.html","hash":"b4161b858aebaec747a8e997b667b5c8fcfcead8","modified":1506589120581},{"_id":"public/2016/01/21/前端知识收集/index.html","hash":"e5d7a62c5a152ce2397fe3c2406c672267d73e82","modified":1506589120581},{"_id":"public/2016/01/07/nodeJsStudy11/index.html","hash":"8c288e9745dca4d650f300793b4116b668921cba","modified":1506589120582},{"_id":"public/2016/01/06/nodeJsStudy9/index.html","hash":"7187989585e287950928d97382b0a49a578e91e8","modified":1506589120582},{"_id":"public/2015/12/02/nodeJsStudy2/index.html","hash":"97bffacd96866024eb85fc7d36f3b5abeb6efbec","modified":1506589120582},{"_id":"public/2015/12/01/nodeJsStudy1/index.html","hash":"fcec095e7917f41ec200989dd062a0d7c394425e","modified":1506589120582},{"_id":"public/2015/11/09/Less is more/index.html","hash":"d77d21557a52424fea1d45689d4f3ce497a612c2","modified":1506589120582},{"_id":"public/2015/11/06/请问您今天要来点兔子吗/index.html","hash":"0575fc56fd61885edba28faa77ab9e044eca2964","modified":1506589120582},{"_id":"public/2015/10/28/请问，你也是一只蘑菇吗/index.html","hash":"97e0a9b8913242a1454cf96487045a31d403d875","modified":1506589120582},{"_id":"public/2015/09/30/JavaScript实践/index.html","hash":"8e42b934c4ca8e4aebe7e0ac3f83ef11061894e3","modified":1506589120582},{"_id":"public/2015/09/23/浏览器的重绘与重排/index.html","hash":"c1d39af5e2857d3289b2c9eae344962beabe9c12","modified":1506589120582},{"_id":"public/2015/08/18/用js原生实现Ajax的get和post/index.html","hash":"f5201680b3bc6f6cb91b291989bd2da76d38a3ff","modified":1506589120582},{"_id":"public/2015/07/25/好玩的cookie/index.html","hash":"cad5d21c5634a1c26db853dedbd6c5e988eafaa1","modified":1506589120582},{"_id":"public/archives/page/2/index.html","hash":"2b1d51aa27e6a8e48c5bbf580144b5eb6cc0b73d","modified":1506589120582},{"_id":"public/archives/page/3/index.html","hash":"297d99fa9a1cc197606069969b18ae0641c2d328","modified":1506589120582},{"_id":"public/archives/page/4/index.html","hash":"ca127a8da1018146b97c7198229d33887aa7441f","modified":1506589120582},{"_id":"public/archives/2015/index.html","hash":"d08aed2d3fe6932199406060d57195f081fb903c","modified":1506589120582},{"_id":"public/archives/2015/page/2/index.html","hash":"d61228d8564a5259b4d9578061df60a9cd318903","modified":1506589120582},{"_id":"public/archives/2015/07/index.html","hash":"206629b264938782e2af1244de822b230d814c49","modified":1506589120582},{"_id":"public/archives/2015/08/index.html","hash":"a38175ecd694afd36d85b9f2beba4a2696a9955c","modified":1506589120583},{"_id":"public/archives/2015/09/index.html","hash":"bbb44bf93f146f233a1d4378a058d0ffd4cdb69c","modified":1506589120583},{"_id":"public/archives/2015/10/index.html","hash":"69002fa421a600706670a4d839ff02e7aa444ffc","modified":1506589120583},{"_id":"public/archives/2015/11/index.html","hash":"886297827a165bac2e21bcbb21f4222d48712c58","modified":1506589120583},{"_id":"public/archives/2015/12/index.html","hash":"54fd4cc3611f8ef307617292a6ceb41401b165cb","modified":1506589120583},{"_id":"public/archives/2016/index.html","hash":"89ba538afcf19a57912ac7b08e67b121d305e7c7","modified":1506589120583},{"_id":"public/archives/2016/page/2/index.html","hash":"9e0e3f811664aa48e4e3947a9ae32d785c8478a7","modified":1506589120583},{"_id":"public/archives/2016/01/index.html","hash":"2c268482c66e41a2eacddb7868c5cc3f870d1b2e","modified":1506589120583},{"_id":"public/archives/2016/02/index.html","hash":"3756bb2bcdd427de30904cfa26738d0546a17bae","modified":1506589120583},{"_id":"public/archives/2016/03/index.html","hash":"a907ceb385d91ee04a8576176c28bcaf17e7b9fb","modified":1506589120583},{"_id":"public/archives/2016/12/index.html","hash":"e157262b75fa0707e2b81fb5a5a6d98f2ec1afb6","modified":1506589120583},{"_id":"public/archives/2017/index.html","hash":"1b7b08bce6e66dc7228293f80b12d9f0fe28e64d","modified":1506589120583},{"_id":"public/archives/2017/01/index.html","hash":"4bc07c146af1a4fff3b5d62abe83a2345916ab89","modified":1506589120583},{"_id":"public/archives/2017/03/index.html","hash":"c78d6fd060b66884f3217b6669c033db5b080ee0","modified":1506589120584},{"_id":"public/archives/2017/05/index.html","hash":"c49e000395d0164c981a38871077e1a7d0aae40f","modified":1506589120584},{"_id":"public/archives/2017/08/index.html","hash":"2c053de3c3eeebaca5282ac6d1ddd605322b7902","modified":1506589120584},{"_id":"public/index.html","hash":"2bca072c622a6106755d73496c6881618e77dcad","modified":1506589120584},{"_id":"public/page/2/index.html","hash":"30763fad8eceb94a9a89ee71f1ce791381e56cf4","modified":1506589120584},{"_id":"public/2017/03/07/debounce-and-throttle/index.html","hash":"50cadbaf10a0cb0e3c76acb57e191164a6f149a9","modified":1506589120584},{"_id":"public/2017/01/19/pm2-node-service/index.html","hash":"d240545c34218830169e5d3afc55158128f0af93","modified":1506589120584},{"_id":"public/2017/01/11/reading-notes-Of-ECMAScript6/index.html","hash":"40533e272800addd740677023c97826e4d8efe70","modified":1506589120584},{"_id":"public/2017/01/06/mocha/index.html","hash":"e5946de15e46d9e78dd870678933cb521cd9cf2c","modified":1506589120584},{"_id":"public/2016/03/25/introduction-jquery-deferred-objects/index.html","hash":"fc4219d9c89a48036e6fdafee9cf220b916c044f","modified":1506589120584},{"_id":"public/2016/01/06/nodeJsStudy10/index.html","hash":"c5eff4802517c83e17572aae51954f0ffa39af32","modified":1506589120584},{"_id":"public/2016/01/06/nodeJsStudy8/index.html","hash":"9b3fe9a7d46ae2318c989a299657e5f17a3977b4","modified":1506589120584},{"_id":"public/2016/01/06/nodeJsStudy7/index.html","hash":"553f0d365498fc75097c2d6c91a2a134012246cc","modified":1506589120584},{"_id":"public/2016/01/04/nodeJsStudy6/index.html","hash":"ed3767ff057ce67345526ff21bfab253212be5d1","modified":1506589120584},{"_id":"public/2016/01/04/nodeJsStudy5/index.html","hash":"6639cc32f12fe71eac4ae2a1ec47a852768f2128","modified":1506589120584},{"_id":"public/2015/12/11/nodeJsStudy4/index.html","hash":"785d83dc7495dd1a82f07bb4c482cfd3701172fa","modified":1506589120584},{"_id":"public/2015/12/03/nodeJsStudy3/index.html","hash":"131ef2f54f0cc184e970f447b010349a56bb4b98","modified":1506589120584},{"_id":"public/2015/11/25/jQueryPerformanceOptimization/index.html","hash":"35d7101d6d17c9d04ff9cf60c335c7bf24739869","modified":1506589120584},{"_id":"public/2015/11/20/各种居中布局的css实现方法/index.html","hash":"8e5edcd982e81442fb65ea51db1376ac840a6ae5","modified":1506589120584},{"_id":"public/2015/11/20/不是只有“if else”/index.html","hash":"bdbeb63a3e70c1084d1b6df1c8b31e864510260f","modified":1506589120585},{"_id":"public/2015/11/20/数组的常用方法/index.html","hash":"4a9b42dedb0b6cf70289c8c09d8e6c5987edea8a","modified":1506589120585},{"_id":"public/archives/index.html","hash":"f92481bdc62868f127ff04443cbd98a67365ca72","modified":1506589120585},{"_id":"public/page/3/index.html","hash":"101bb10f18db662b82cb8bdd447c3e350f439754","modified":1506589120613},{"_id":"public/page/4/index.html","hash":"bc1af527fbc57949488630a3928d250d38cec8b5","modified":1506589120613},{"_id":"public/tags/css学习心得/index.html","hash":"675f90b903d93813515d52342855c91f8aa1ca40","modified":1506589120613},{"_id":"public/tags/Javascript学习笔记/index.html","hash":"a74367416c9bffc56df34281eb59316e448316c1","modified":1506589120613},{"_id":"public/tags/生活琐事/index.html","hash":"16692a5ad1a7a24e23d891f1258f261c07336200","modified":1506589120614},{"_id":"public/tags/web前端知识/index.html","hash":"e9265af371c14649d4d4ed6a3beea431a27e46f7","modified":1506589120614},{"_id":"public/tags/node-js学习笔记/index.html","hash":"7d2f0d8fdf71814ab06baa1185b2133898ccd6a2","modified":1506589120614},{"_id":"public/tags/node-js学习笔记/page/2/index.html","hash":"a291606e41c3ec7fec375b380d07c0e4cc24b324","modified":1506589120614},{"_id":"public/tags/读书笔记/index.html","hash":"71cde9cba35dac3aea52d4284ff75bd98e5f4123","modified":1506589120614},{"_id":"public/tags/矫情不是病/index.html","hash":"11d2966bec5c18da7d14bb8bd90823562eb3c12b","modified":1506589120614},{"_id":"public/tags/二次元/index.html","hash":"56bd706717442fec62a2e08f549d5ce82b2ff0d0","modified":1506589120614},{"_id":"public/CNAME","hash":"341a1bd24be6da36f01d2e5438abcb47b7b7d5b5","modified":1506589120616},{"_id":"public/favicon.ico","hash":"b5e3d38751ecdf6b22037db5224e43e9186d78de","modified":1506589120616},{"_id":"public/fonts/icons.ttf","hash":"2169592997f694ffa05b1d4c23d5a1abf35d3203","modified":1506589120616},{"_id":"public/img/3.png","hash":"9c903cd0002e1edd4d46c866ce74b536dd07d164","modified":1506589120616},{"_id":"public/fonts/icons.woff","hash":"af538de6ac19d5da1cada203c7451ce32f5daceb","modified":1506589120616},{"_id":"public/fonts/icons.eot","hash":"e307fc2d61d13bbc3aafc9abd75e727cbebadee1","modified":1506589120616},{"_id":"public/img/2.png","hash":"20c48a04db04b142e99e5b5f34a3cdebae6eb40e","modified":1506589120616},{"_id":"public/img/5.png","hash":"a25863789e27cad0a8dfe66daaed697c0c7ce1f7","modified":1506589120616},{"_id":"public/img/icons-demo-nav.png","hash":"4508247661f7883fed94386acf61f9b05e324dce","modified":1506589120616},{"_id":"public/img/6.jpg","hash":"988c4da6a326aea83263534e14e63ff32c9c1981","modified":1506589120616},{"_id":"public/img/logo.png","hash":"158c1cc2dc9d72b5782078d4114adb30649eb9d0","modified":1506589120616},{"_id":"public/img/img-bg.jpg","hash":"4cf609b11d89b38d2a641a8810dcf6a2bf78a716","modified":1506589120617},{"_id":"public/img/logo.svg","hash":"b18a559dadc4ceb3b96e3cbc5ed704a3da9c39ca","modified":1506589120617},{"_id":"public/img/mogu.png","hash":"74606326921ad39398269cd98f6bd9cba471af8f","modified":1506589120617},{"_id":"public/images/1.png","hash":"4567294489a8899fa9f84e25e40cdd444b2e9095","modified":1506589120619},{"_id":"public/img/1.png","hash":"579ec39681f74bcfaa89889d97cd00a3a8a262d0","modified":1506589120619},{"_id":"public/js/jquery.fitvids.js","hash":"0d9ee59f102516b1a988490f27ed37440713cc8b","modified":1506589120627},{"_id":"public/js/index.js","hash":"9bca2a96b38159b83c231982e4758b69ee8aaec3","modified":1506589120627},{"_id":"public/js/menu.js","hash":"c429f19136ebb7e7fe76001f6589bc5d16d39c1d","modified":1506589120631},{"_id":"public/js/underscore-min.js","hash":"2a515632e0fd8ffdeb8d94cb25e44cf287feb32f","modified":1506589120631},{"_id":"public/fonts/icons.svg","hash":"4b8357c608c01f304789e34bfd133081c1fc8b9d","modified":1506589120631},{"_id":"public/css/style.css","hash":"8fa96fc8289d6d4699334580dfcb9ca3d4553f88","modified":1506589120639},{"_id":"public/css/normalize.css","hash":"2d45c1546b603f967845038c6e34ccf8b6a986b8","modified":1506589120639},{"_id":"public/css/screen.css","hash":"03aa8ac103657f1f3bd062c74947cbebeb4a8564","modified":1506589120639},{"_id":"public/img/4.png","hash":"bbf39670aaa4abf6cd1e3bdb2abca8b03362b845","modified":1506589120639},{"_id":"public/img/icons-demo-nav.svg","hash":"59d3af4b2c86a3cf73da4614efe01b1c43333a5a","modified":1506589120649},{"_id":"public/images/QQ20170411-194256@2x.png","hash":"91db55ee07cc8c7fbcb8a08233f6e6fc08607f20","modified":1506589120653}],"Category":[],"Data":[],"Page":[{"_content":"微信爬虫--前端文章阅读：[http://read.chenkeyi.com/](http://read.chenkeyi.com/)","source":"my-project/index.md","raw":"微信爬虫--前端文章阅读：[http://read.chenkeyi.com/](http://read.chenkeyi.com/)","date":"2017-06-12T02:45:00.000Z","updated":"2017-06-12T02:45:00.000Z","path":"my-project/index.html","title":"","comments":1,"layout":"page","_id":"cj8489ew20001er2z1rzj4wd0","content":"<p>微信爬虫–前端文章阅读：<a href=\"http://read.chenkeyi.com/\" target=\"_blank\" rel=\"external\">http://read.chenkeyi.com/</a></p>\n","excerpt":"","more":"<p>微信爬虫–前端文章阅读：<a href=\"http://read.chenkeyi.com/\">http://read.chenkeyi.com/</a></p>\n"},{"title":"关于我","_content":"![照骗](https://avatars2.githubusercontent.com/u/12221080?v=3&s=230)\n    \n\n陈柯伊 93年的重庆妹子 2016年大学毕业\n喜欢互联网 喜欢前端\n用了一个大学的时间完成了从2b文青到（伪）技术宅（女）的转变\n现于重庆猪八戒网络有限公司从事前端开发工作\n\n业余爱好：动漫 LOL  \n微博：@陈柯伊伊伊伊_\n邮箱：chen_keyi@foxmail.com","source":"about-me/index.md","raw":"title: 关于我\n---\n![照骗](https://avatars2.githubusercontent.com/u/12221080?v=3&s=230)\n    \n\n陈柯伊 93年的重庆妹子 2016年大学毕业\n喜欢互联网 喜欢前端\n用了一个大学的时间完成了从2b文青到（伪）技术宅（女）的转变\n现于重庆猪八戒网络有限公司从事前端开发工作\n\n业余爱好：动漫 LOL  \n微博：@陈柯伊伊伊伊_\n邮箱：chen_keyi@foxmail.com","date":"2016-09-22T16:10:51.000Z","updated":"2016-09-22T16:10:51.000Z","path":"about-me/index.html","comments":1,"layout":"page","_id":"cj8489ew60003er2zjgu7t2a3","content":"<p><img src=\"https://avatars2.githubusercontent.com/u/12221080?v=3&amp;s=230\" alt=\"照骗\"></p>\n<p>陈柯伊 93年的重庆妹子 2016年大学毕业<br>喜欢互联网 喜欢前端<br>用了一个大学的时间完成了从2b文青到（伪）技术宅（女）的转变<br>现于重庆猪八戒网络有限公司从事前端开发工作</p>\n<p>业余爱好：动漫 LOL<br>微博：@陈柯伊伊伊伊_<br>邮箱：chen_keyi@foxmail.com</p>\n","excerpt":"","more":"<p><img src=\"https://avatars2.githubusercontent.com/u/12221080?v=3&amp;s=230\" alt=\"照骗\"></p>\n<p>陈柯伊 93年的重庆妹子 2016年大学毕业<br>喜欢互联网 喜欢前端<br>用了一个大学的时间完成了从2b文青到（伪）技术宅（女）的转变<br>现于重庆猪八戒网络有限公司从事前端开发工作</p>\n<p>业余爱好：动漫 LOL<br>微博：@陈柯伊伊伊伊_<br>邮箱：chen_keyi@foxmail.com</p>\n"}],"Post":[{"title":"Less is more","date":"2015-11-09T02:17:50.000Z","_content":"\n工作中为了模块化，我们会采用less进行开发。所以充分了解less的使用方法可以使开发变得更加有效率。\n<!-- more -->\n\n>LESS是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS的赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。\n\n>LESS可以在多种语言、环境中使用，包括浏览器端、桌面客户端、服务端。\n\n下面介绍一下less的用法（更详细内容见[官方文档](http://www.1024i.com/demo/less/document.html)）：\n\n#### 一、LESS注释：\n1. /\\* 注释内容 \\*/ \n\n这种注释方法编译后，注释内容会保留到css文件内容中。\n\n2. //注释内容 \n这种注释方法编译后，注释内容不会保留到css文件中。\n\n#### 二、变量：\n我们可以像js一样为css定义变量并重复使用它。\n语法：@变量名:值;\nLESS源码：\n\n    @color: #4D926F;\n\n    #header {\n        color: @color;\n    }\n    h2 {\n        color: @color;\n    }\n编译后的css:\n\n    #header {\n        color: #4D926F;\n    }\n    h2 {\n        color: #4D926F;\n    }\n\n#### 三、混合\n混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以**带参数**地调用，就像使用函数一样。\n\nLESS源码：\n\n    .rounded-corners (@radius: 5px) {//带了默认值，如果调用时未传参数，则默认此值\n        -webkit-border-radius: @radius;\n        -moz-border-radius: @radius;\n        -ms-border-radius: @radius;\n        -o-border-radius: @radius;\n        border-radius: @radius;\n    }\n\n    #header {\n        .rounded-corners;\n    }\n    #footer {\n        .rounded-corners(10px);//传了参数 改变了@radius的值\n    }\n\n编译后的CSS：\n\n    #header {\n        -webkit-border-radius: 5px;\n        -moz-border-radius: 5px;\n        -ms-border-radius: 5px;\n        -o-border-radius: 5px;\n        border-radius: 5px;\n    }\n    #footer {\n        -webkit-border-radius: 10px;\n        -moz-border-radius: 10px;\n        -ms-border-radius: 10px;\n        -o-border-radius: 10px;\n        border-radius: 10px;\n    }\n\n#### 嵌套\n我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。\n\nLESS源码：\n\n    #header {\n        h1 {\n            font-size: 26px;\n            font-weight: bold;\n        }\n        p {\n            font-size: 12px;\n            a {\n                text-decoration: none;\n                &:hover {\n                    border-width: 1px\n                }\n            }\n        }\n    }\n\n编译后的CSS：\n\n    #header h1 {\n        font-size: 26px;\n        font-weight: bold;\n    }\n    #header p {\n        font-size: 12px;\n    }\n    #header p a {\n        text-decoration: none;\n    }\n    #header p a:hover {\n        border-width: 1px;\n    }\n\n但是我更建议定义类名来调用，不建议用标签或者多层嵌套。","source":"_posts/Less is more.md","raw":"title: Less is more\ndate: 2015-11-09 10:17:50\ntags: css学习心得\n---\n\n工作中为了模块化，我们会采用less进行开发。所以充分了解less的使用方法可以使开发变得更加有效率。\n<!-- more -->\n\n>LESS是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS的赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。\n\n>LESS可以在多种语言、环境中使用，包括浏览器端、桌面客户端、服务端。\n\n下面介绍一下less的用法（更详细内容见[官方文档](http://www.1024i.com/demo/less/document.html)）：\n\n#### 一、LESS注释：\n1. /\\* 注释内容 \\*/ \n\n这种注释方法编译后，注释内容会保留到css文件内容中。\n\n2. //注释内容 \n这种注释方法编译后，注释内容不会保留到css文件中。\n\n#### 二、变量：\n我们可以像js一样为css定义变量并重复使用它。\n语法：@变量名:值;\nLESS源码：\n\n    @color: #4D926F;\n\n    #header {\n        color: @color;\n    }\n    h2 {\n        color: @color;\n    }\n编译后的css:\n\n    #header {\n        color: #4D926F;\n    }\n    h2 {\n        color: #4D926F;\n    }\n\n#### 三、混合\n混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以**带参数**地调用，就像使用函数一样。\n\nLESS源码：\n\n    .rounded-corners (@radius: 5px) {//带了默认值，如果调用时未传参数，则默认此值\n        -webkit-border-radius: @radius;\n        -moz-border-radius: @radius;\n        -ms-border-radius: @radius;\n        -o-border-radius: @radius;\n        border-radius: @radius;\n    }\n\n    #header {\n        .rounded-corners;\n    }\n    #footer {\n        .rounded-corners(10px);//传了参数 改变了@radius的值\n    }\n\n编译后的CSS：\n\n    #header {\n        -webkit-border-radius: 5px;\n        -moz-border-radius: 5px;\n        -ms-border-radius: 5px;\n        -o-border-radius: 5px;\n        border-radius: 5px;\n    }\n    #footer {\n        -webkit-border-radius: 10px;\n        -moz-border-radius: 10px;\n        -ms-border-radius: 10px;\n        -o-border-radius: 10px;\n        border-radius: 10px;\n    }\n\n#### 嵌套\n我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。\n\nLESS源码：\n\n    #header {\n        h1 {\n            font-size: 26px;\n            font-weight: bold;\n        }\n        p {\n            font-size: 12px;\n            a {\n                text-decoration: none;\n                &:hover {\n                    border-width: 1px\n                }\n            }\n        }\n    }\n\n编译后的CSS：\n\n    #header h1 {\n        font-size: 26px;\n        font-weight: bold;\n    }\n    #header p {\n        font-size: 12px;\n    }\n    #header p a {\n        text-decoration: none;\n    }\n    #header p a:hover {\n        border-width: 1px;\n    }\n\n但是我更建议定义类名来调用，不建议用标签或者多层嵌套。","slug":"Less is more","published":1,"updated":"2016-09-22T16:12:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489evx0000er2z08b4pr2a","content":"<p>工作中为了模块化，我们会采用less进行开发。所以充分了解less的使用方法可以使开发变得更加有效率。<br><a id=\"more\"></a></p>\n<blockquote>\n<p>LESS是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS的赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。</p>\n<p>LESS可以在多种语言、环境中使用，包括浏览器端、桌面客户端、服务端。</p>\n</blockquote>\n<p>下面介绍一下less的用法（更详细内容见<a href=\"http://www.1024i.com/demo/less/document.html\" target=\"_blank\" rel=\"external\">官方文档</a>）：</p>\n<h4 id=\"一、LESS注释：\">一、LESS注释：</h4><ol>\n<li>/* 注释内容 */ </li>\n</ol>\n<p>这种注释方法编译后，注释内容会保留到css文件内容中。</p>\n<ol>\n<li>//注释内容<br>这种注释方法编译后，注释内容不会保留到css文件中。</li>\n</ol>\n<h4 id=\"二、变量：\">二、变量：</h4><p>我们可以像js一样为css定义变量并重复使用它。<br>语法：@变量名:值;<br>LESS源码：</p>\n<pre><code><span class=\"variable\">@color:</span> <span class=\"hexcolor\">#4D926F</span>;\n\n<span class=\"id\">#header</span> {\n    <span class=\"attribute\">color</span>: <span class=\"variable\">@color</span>;\n}\n<span class=\"tag\">h2</span> {\n    <span class=\"attribute\">color</span>: <span class=\"variable\">@color</span>;\n}\n</code></pre><p>编译后的css:</p>\n<pre><code><span class=\"id\">#header</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">color</span>:<span class=\"value\"> <span class=\"hexcolor\">#4D926F</span></span></span>;\n}</span>\n<span class=\"tag\">h2</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">color</span>:<span class=\"value\"> <span class=\"hexcolor\">#4D926F</span></span></span>;\n}</span>\n</code></pre><h4 id=\"三、混合\">三、混合</h4><p>混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以<strong>带参数</strong>地调用，就像使用函数一样。</p>\n<p>LESS源码：</p>\n<pre><code><span class=\"class\">.rounded-corners</span> (<span class=\"variable\">@radius</span>: <span class=\"number\">5px</span>) {<span class=\"comment\">//带了默认值，如果调用时未传参数，则默认此值</span>\n    <span class=\"attribute\">-webkit-border-radius</span>: <span class=\"variable\">@radius</span>;\n    <span class=\"attribute\">-moz-border-radius</span>: <span class=\"variable\">@radius</span>;\n    <span class=\"attribute\">-ms-border-radius</span>: <span class=\"variable\">@radius</span>;\n    <span class=\"attribute\">-o-border-radius</span>: <span class=\"variable\">@radius</span>;\n    <span class=\"attribute\">border-radius</span>: <span class=\"variable\">@radius</span>;\n}\n\n<span class=\"id\">#header</span> {\n    <span class=\"class\">.rounded-corners</span>;\n}\n<span class=\"id\">#footer</span> {\n    <span class=\"class\">.rounded-corners</span>(<span class=\"number\">10px</span>);<span class=\"comment\">//传了参数 改变了@radius的值</span>\n}\n</code></pre><p>编译后的CSS：</p>\n<pre><code><span class=\"id\">#header</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">-webkit-border-radius</span>:<span class=\"value\"> <span class=\"number\">5px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-moz-border-radius</span>:<span class=\"value\"> <span class=\"number\">5px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-ms-border-radius</span>:<span class=\"value\"> <span class=\"number\">5px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-o-border-radius</span>:<span class=\"value\"> <span class=\"number\">5px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">border-radius</span>:<span class=\"value\"> <span class=\"number\">5px</span></span></span>;\n}</span>\n<span class=\"id\">#footer</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">-webkit-border-radius</span>:<span class=\"value\"> <span class=\"number\">10px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-moz-border-radius</span>:<span class=\"value\"> <span class=\"number\">10px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-ms-border-radius</span>:<span class=\"value\"> <span class=\"number\">10px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-o-border-radius</span>:<span class=\"value\"> <span class=\"number\">10px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">border-radius</span>:<span class=\"value\"> <span class=\"number\">10px</span></span></span>;\n}</span>\n</code></pre><h4 id=\"嵌套\">嵌套</h4><p>我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。</p>\n<p>LESS源码：</p>\n<pre><code><span class=\"id\">#header</span> {\n    <span class=\"tag\">h1</span> {\n        <span class=\"attribute\">font-size</span>: <span class=\"number\">26px</span>;\n        <span class=\"attribute\">font-weight</span>: bold;\n    }\n    <span class=\"tag\">p</span> {\n        <span class=\"attribute\">font-size</span>: <span class=\"number\">12px</span>;\n        <span class=\"tag\">a</span> {\n            <span class=\"attribute\">text-decoration</span>: none;\n            <span class=\"keyword\">&amp;</span><span class=\"pseudo\">:hover</span> {\n                <span class=\"attribute\">border-width</span>: <span class=\"number\">1px</span>\n            }\n        }\n    }\n}\n</code></pre><p>编译后的CSS：</p>\n<pre><code><span class=\"id\">#header</span> <span class=\"tag\">h1</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">font-size</span>:<span class=\"value\"> <span class=\"number\">26px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">font-weight</span>:<span class=\"value\"> bold</span></span>;\n}</span>\n<span class=\"id\">#header</span> <span class=\"tag\">p</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">font-size</span>:<span class=\"value\"> <span class=\"number\">12px</span></span></span>;\n}</span>\n<span class=\"id\">#header</span> <span class=\"tag\">p</span> <span class=\"tag\">a</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">text-decoration</span>:<span class=\"value\"> none</span></span>;\n}</span>\n<span class=\"id\">#header</span> <span class=\"tag\">p</span> <span class=\"rule\"><span class=\"attribute\">a</span>:<span class=\"value\">hover {\n    border-width: <span class=\"number\">1px</span></span></span>;\n}\n</code></pre><p>但是我更建议定义类名来调用，不建议用标签或者多层嵌套。</p>\n","excerpt":"<p>工作中为了模块化，我们会采用less进行开发。所以充分了解less的使用方法可以使开发变得更加有效率。<br>","more":"</p>\n<blockquote>\n<p>LESS是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS的赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。</p>\n<p>LESS可以在多种语言、环境中使用，包括浏览器端、桌面客户端、服务端。</p>\n</blockquote>\n<p>下面介绍一下less的用法（更详细内容见<a href=\"http://www.1024i.com/demo/less/document.html\">官方文档</a>）：</p>\n<h4 id=\"一、LESS注释：\">一、LESS注释：</h4><ol>\n<li>/* 注释内容 */ </li>\n</ol>\n<p>这种注释方法编译后，注释内容会保留到css文件内容中。</p>\n<ol>\n<li>//注释内容<br>这种注释方法编译后，注释内容不会保留到css文件中。</li>\n</ol>\n<h4 id=\"二、变量：\">二、变量：</h4><p>我们可以像js一样为css定义变量并重复使用它。<br>语法：@变量名:值;<br>LESS源码：</p>\n<pre><code><span class=\"variable\">@color:</span> <span class=\"hexcolor\">#4D926F</span>;\n\n<span class=\"id\">#header</span> {\n    <span class=\"attribute\">color</span>: <span class=\"variable\">@color</span>;\n}\n<span class=\"tag\">h2</span> {\n    <span class=\"attribute\">color</span>: <span class=\"variable\">@color</span>;\n}\n</code></pre><p>编译后的css:</p>\n<pre><code><span class=\"id\">#header</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">color</span>:<span class=\"value\"> <span class=\"hexcolor\">#4D926F</span></span></span>;\n}</span>\n<span class=\"tag\">h2</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">color</span>:<span class=\"value\"> <span class=\"hexcolor\">#4D926F</span></span></span>;\n}</span>\n</code></pre><h4 id=\"三、混合\">三、混合</h4><p>混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以<strong>带参数</strong>地调用，就像使用函数一样。</p>\n<p>LESS源码：</p>\n<pre><code><span class=\"class\">.rounded-corners</span> (<span class=\"variable\">@radius</span>: <span class=\"number\">5px</span>) {<span class=\"comment\">//带了默认值，如果调用时未传参数，则默认此值</span>\n    <span class=\"attribute\">-webkit-border-radius</span>: <span class=\"variable\">@radius</span>;\n    <span class=\"attribute\">-moz-border-radius</span>: <span class=\"variable\">@radius</span>;\n    <span class=\"attribute\">-ms-border-radius</span>: <span class=\"variable\">@radius</span>;\n    <span class=\"attribute\">-o-border-radius</span>: <span class=\"variable\">@radius</span>;\n    <span class=\"attribute\">border-radius</span>: <span class=\"variable\">@radius</span>;\n}\n\n<span class=\"id\">#header</span> {\n    <span class=\"class\">.rounded-corners</span>;\n}\n<span class=\"id\">#footer</span> {\n    <span class=\"class\">.rounded-corners</span>(<span class=\"number\">10px</span>);<span class=\"comment\">//传了参数 改变了@radius的值</span>\n}\n</code></pre><p>编译后的CSS：</p>\n<pre><code><span class=\"id\">#header</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">-webkit-border-radius</span>:<span class=\"value\"> <span class=\"number\">5px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-moz-border-radius</span>:<span class=\"value\"> <span class=\"number\">5px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-ms-border-radius</span>:<span class=\"value\"> <span class=\"number\">5px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-o-border-radius</span>:<span class=\"value\"> <span class=\"number\">5px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">border-radius</span>:<span class=\"value\"> <span class=\"number\">5px</span></span></span>;\n}</span>\n<span class=\"id\">#footer</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">-webkit-border-radius</span>:<span class=\"value\"> <span class=\"number\">10px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-moz-border-radius</span>:<span class=\"value\"> <span class=\"number\">10px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-ms-border-radius</span>:<span class=\"value\"> <span class=\"number\">10px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">-o-border-radius</span>:<span class=\"value\"> <span class=\"number\">10px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">border-radius</span>:<span class=\"value\"> <span class=\"number\">10px</span></span></span>;\n}</span>\n</code></pre><h4 id=\"嵌套\">嵌套</h4><p>我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。</p>\n<p>LESS源码：</p>\n<pre><code><span class=\"id\">#header</span> {\n    <span class=\"tag\">h1</span> {\n        <span class=\"attribute\">font-size</span>: <span class=\"number\">26px</span>;\n        <span class=\"attribute\">font-weight</span>: bold;\n    }\n    <span class=\"tag\">p</span> {\n        <span class=\"attribute\">font-size</span>: <span class=\"number\">12px</span>;\n        <span class=\"tag\">a</span> {\n            <span class=\"attribute\">text-decoration</span>: none;\n            <span class=\"keyword\">&amp;</span><span class=\"pseudo\">:hover</span> {\n                <span class=\"attribute\">border-width</span>: <span class=\"number\">1px</span>\n            }\n        }\n    }\n}\n</code></pre><p>编译后的CSS：</p>\n<pre><code><span class=\"id\">#header</span> <span class=\"tag\">h1</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">font-size</span>:<span class=\"value\"> <span class=\"number\">26px</span></span></span>;\n    <span class=\"rule\"><span class=\"attribute\">font-weight</span>:<span class=\"value\"> bold</span></span>;\n}</span>\n<span class=\"id\">#header</span> <span class=\"tag\">p</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">font-size</span>:<span class=\"value\"> <span class=\"number\">12px</span></span></span>;\n}</span>\n<span class=\"id\">#header</span> <span class=\"tag\">p</span> <span class=\"tag\">a</span> <span class=\"rules\">{\n    <span class=\"rule\"><span class=\"attribute\">text-decoration</span>:<span class=\"value\"> none</span></span>;\n}</span>\n<span class=\"id\">#header</span> <span class=\"tag\">p</span> <span class=\"rule\"><span class=\"attribute\">a</span>:<span class=\"value\">hover {\n    border-width: <span class=\"number\">1px</span></span></span>;\n}\n</code></pre><p>但是我更建议定义类名来调用，不建议用标签或者多层嵌套。</p>"},{"title":"JavaScript实践","date":"2015-09-30T02:17:50.000Z","_content":"---\n### 命名\n\n代码是给人(别人或者1个星期后的 自己)阅读和修改的 \n\n給变量和函数一个简单易懂的名字 \n\n可维护性++\n\n** 以功能命名,而不是表现  isOverSeven() × VS isLegalAge() √ **\n\n    // 不好的命名\n    aaaa  \n    x1  \n    f  \n    hengxian  \n    createNewUserIfTheInputIsValida\n    te\n   避免全局变量\n\n> 我们无法拥有代码的控制权\n\n* 不易维护 \n* 牵一发而动全身 \n* 易被覆盖,修改,而你还不知道\n\n\n     // Bad\n    var currentColor;\n    var colorMap = {\n        red: '红色',\n        green: '绿色',\n        yellow: '黄色'\n    };\n    \n    function init() {\n        currentColor = 'red';\n    }\n        \n\n    // Common\n    (function () {\n        var currentColor;\n        \n        var colorMap = {\n            red: '红色',\n            green: '绿色',\n            yellow: '黄色'\n        };\n        \n        function init () {\n            currentColor = 'red';\n        }\n    })();\n    \n    // Good\n    var colorManager = function () {  \n    var currentColor;  \n    var colorMap  =  {           \n        red: '红色',           \n        green: '绿色',           \n        yellow: '黄色' \n    };  \n\n        return  { \n            init: function () {                   \n                currentColor  =  'red'          \n            } \n        } \n    }();\n    \n---\n### 正确的注释\n\n注释也是代码的一部分 \n\n错误的注释,相比没有注释,更可怕 \n\n介绍背景、介绍使用方式、介绍注意事项,不要重复代码的意思\n\n    //  已登陆的用户,有  name  和  age  两个属性  \n    var loginedUser = {           \n        name:  '',           \n        age:  10  \n    };\n    /*  \n        *  统一登录方法  \n        *  在需要登录的地方调用       \n        *  如果已经登陆,会立即执行回调       \n        *  否则,会显示登录窗口,登录完成后执行回 调  \n        *  todo:登录窗口的  UI  优化  \n    */  \n    function login(cb) {  \n    }\n\n---\n### 简短标记\n\n简短标记让代码更简单易读\n\n    // Bad\n    var user = new Object;\n    user.name = 'bajiefe';\n    user.age = 20;\n    \n    // Good\n    var user = {\n        name: 'bajiefe',\n        age: 20\n    };\n    \n    // Bad\n    var userList = new Array;\n    userList[0] = 'bajiefe';\n    userList[1] = 'bajierd';\n    \n    // Good\n    var userList = ['bajiefe', 'bajierd'];\n    \n    \n    // Bad\n    var age;\n    if(val) {\n        age = val;\n    } else {\n        age = 10;\n    }\n    \n    // Good\n    var age = val || 10;\n    \n    \n    // Bad\n    var direction;\n    \n    if(val) {\n        direction = 1;\n    } else {\n        direction = -1;\n    }\n    \n    // Good\n    var direction = val ? 1 : -1;\n---\n### 减少DOM 操作\n\n通过 className 来控制 DOM 样式\n\n    // Bad\n    userInput.style.cssText = 'color: red; border: 1px  solid  red;'  \n    \n    // Good\n    userInput.className  =  ‘error;’\n\ndom 节点修改好后再插入 dom  tree\n    \n    // Bad\n    function addAnchor(parentElement, anchorText, anchorClass) {\n        var element = document.createElement('a');\n        parentElement.appendChild(element);\n        element.innerHTML = anchorText;\n        element.className = anchorClass;\n    }\n    \n    // Good\n    var element = document.createElement('a');\n    element.innerHTML = anchorText;\n    element.className = anchorClass;\n    parentElement.appendChild(element);\n\n通过文档片段创建 DOM\n    \n    document.createDocumentFragment();\n    \n    function addAnchors(element) {\n        var anchor;\n        var fragment = document.createDocumentFragment();\n    \n        for(var i = 0; i < 10; i++) {\n            anchor = document.createElement('a');\n            anchor.innerHTML = 'test';\n            fragment.appendChild(anchor);\n        }\n    \n        element.appendChild(fragment);\n    }\n\n通过事件代理绑定事件\n\n---\n### 自动分号插入\n\n当不清楚写不写分号时,写上\n\n    var tester = function() {\n    \n    }\n    \n    (function() {\n        console.log(tester);\n    })()\n    \n    var a = 123\n\n---\n### Debug\nGoogle 开发者工具","source":"_posts/JavaScript实践.md","raw":"title: JavaScript实践\ndate: 2015-09-30 10:17:50\ntag: Javascript学习笔记\n---\n---\n### 命名\n\n代码是给人(别人或者1个星期后的 自己)阅读和修改的 \n\n給变量和函数一个简单易懂的名字 \n\n可维护性++\n\n** 以功能命名,而不是表现  isOverSeven() × VS isLegalAge() √ **\n\n    // 不好的命名\n    aaaa  \n    x1  \n    f  \n    hengxian  \n    createNewUserIfTheInputIsValida\n    te\n   避免全局变量\n\n> 我们无法拥有代码的控制权\n\n* 不易维护 \n* 牵一发而动全身 \n* 易被覆盖,修改,而你还不知道\n\n\n     // Bad\n    var currentColor;\n    var colorMap = {\n        red: '红色',\n        green: '绿色',\n        yellow: '黄色'\n    };\n    \n    function init() {\n        currentColor = 'red';\n    }\n        \n\n    // Common\n    (function () {\n        var currentColor;\n        \n        var colorMap = {\n            red: '红色',\n            green: '绿色',\n            yellow: '黄色'\n        };\n        \n        function init () {\n            currentColor = 'red';\n        }\n    })();\n    \n    // Good\n    var colorManager = function () {  \n    var currentColor;  \n    var colorMap  =  {           \n        red: '红色',           \n        green: '绿色',           \n        yellow: '黄色' \n    };  \n\n        return  { \n            init: function () {                   \n                currentColor  =  'red'          \n            } \n        } \n    }();\n    \n---\n### 正确的注释\n\n注释也是代码的一部分 \n\n错误的注释,相比没有注释,更可怕 \n\n介绍背景、介绍使用方式、介绍注意事项,不要重复代码的意思\n\n    //  已登陆的用户,有  name  和  age  两个属性  \n    var loginedUser = {           \n        name:  '',           \n        age:  10  \n    };\n    /*  \n        *  统一登录方法  \n        *  在需要登录的地方调用       \n        *  如果已经登陆,会立即执行回调       \n        *  否则,会显示登录窗口,登录完成后执行回 调  \n        *  todo:登录窗口的  UI  优化  \n    */  \n    function login(cb) {  \n    }\n\n---\n### 简短标记\n\n简短标记让代码更简单易读\n\n    // Bad\n    var user = new Object;\n    user.name = 'bajiefe';\n    user.age = 20;\n    \n    // Good\n    var user = {\n        name: 'bajiefe',\n        age: 20\n    };\n    \n    // Bad\n    var userList = new Array;\n    userList[0] = 'bajiefe';\n    userList[1] = 'bajierd';\n    \n    // Good\n    var userList = ['bajiefe', 'bajierd'];\n    \n    \n    // Bad\n    var age;\n    if(val) {\n        age = val;\n    } else {\n        age = 10;\n    }\n    \n    // Good\n    var age = val || 10;\n    \n    \n    // Bad\n    var direction;\n    \n    if(val) {\n        direction = 1;\n    } else {\n        direction = -1;\n    }\n    \n    // Good\n    var direction = val ? 1 : -1;\n---\n### 减少DOM 操作\n\n通过 className 来控制 DOM 样式\n\n    // Bad\n    userInput.style.cssText = 'color: red; border: 1px  solid  red;'  \n    \n    // Good\n    userInput.className  =  ‘error;’\n\ndom 节点修改好后再插入 dom  tree\n    \n    // Bad\n    function addAnchor(parentElement, anchorText, anchorClass) {\n        var element = document.createElement('a');\n        parentElement.appendChild(element);\n        element.innerHTML = anchorText;\n        element.className = anchorClass;\n    }\n    \n    // Good\n    var element = document.createElement('a');\n    element.innerHTML = anchorText;\n    element.className = anchorClass;\n    parentElement.appendChild(element);\n\n通过文档片段创建 DOM\n    \n    document.createDocumentFragment();\n    \n    function addAnchors(element) {\n        var anchor;\n        var fragment = document.createDocumentFragment();\n    \n        for(var i = 0; i < 10; i++) {\n            anchor = document.createElement('a');\n            anchor.innerHTML = 'test';\n            fragment.appendChild(anchor);\n        }\n    \n        element.appendChild(fragment);\n    }\n\n通过事件代理绑定事件\n\n---\n### 自动分号插入\n\n当不清楚写不写分号时,写上\n\n    var tester = function() {\n    \n    }\n    \n    (function() {\n        console.log(tester);\n    })()\n    \n    var a = 123\n\n---\n### Debug\nGoogle 开发者工具","slug":"JavaScript实践","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ew40002er2zovnihxbg","content":"<hr>\n<h3 id=\"命名\">命名</h3><p>代码是给人(别人或者1个星期后的 自己)阅读和修改的 </p>\n<p>給变量和函数一个简单易懂的名字 </p>\n<p>可维护性++</p>\n<p><strong> 以功能命名,而不是表现  isOverSeven() × VS isLegalAge() √ </strong></p>\n<pre><code><span class=\"comment\">// 不好的命名</span>\naaaa  \nx1  \nf  \nhengxian  \ncreateNewUserIfTheInputIsValida\n<span class=\"keyword\">te</span>\n</code></pre><p>   避免全局变量</p>\n<blockquote>\n<p>我们无法拥有代码的控制权</p>\n</blockquote>\n<ul>\n<li>不易维护 </li>\n<li>牵一发而动全身 </li>\n<li>易被覆盖,修改,而你还不知道</li>\n</ul>\n<pre><code> <span class=\"comment\">// Bad</span>\n<span class=\"keyword\">var</span> currentColor;\n<span class=\"keyword\">var</span> colorMap = {\n    red: <span class=\"string\">'红色'</span>,\n    green: <span class=\"string\">'绿色'</span>,\n    yellow: <span class=\"string\">'黄色'</span>\n};\n\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>) </span>{\n    currentColor = <span class=\"string\">'red'</span>;\n}\n\n\n<span class=\"comment\">// Common</span>\n(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">var</span> currentColor;\n\n    <span class=\"keyword\">var</span> colorMap = {\n        red: <span class=\"string\">'红色'</span>,\n        green: <span class=\"string\">'绿色'</span>,\n        yellow: <span class=\"string\">'黄色'</span>\n    };\n\n    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span> (<span class=\"params\"></span>) </span>{\n        currentColor = <span class=\"string\">'red'</span>;\n    }\n})();\n\n<span class=\"comment\">// Good</span>\n<span class=\"keyword\">var</span> colorManager = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{  \n<span class=\"keyword\">var</span> currentColor;  \n<span class=\"keyword\">var</span> colorMap  =  {           \n    red: <span class=\"string\">'红色'</span>,           \n    green: <span class=\"string\">'绿色'</span>,           \n    yellow: <span class=\"string\">'黄色'</span> \n};  \n\n    <span class=\"keyword\">return</span>  { \n        init: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{                   \n            currentColor  =  <span class=\"string\">'red'</span>          \n        } \n    } \n}();\n</code></pre><hr>\n<h3 id=\"正确的注释\">正确的注释</h3><p>注释也是代码的一部分 </p>\n<p>错误的注释,相比没有注释,更可怕 </p>\n<p>介绍背景、介绍使用方式、介绍注意事项,不要重复代码的意思</p>\n<pre><code><span class=\"comment\">//  已登陆的用户,有  name  和  age  两个属性  </span>\n<span class=\"keyword\">var</span> loginedUser = {           \n    name:  <span class=\"string\">''</span>,           \n    age:  <span class=\"number\">10</span>  \n};\n<span class=\"comment\">/*  \n    *  统一登录方法  \n    *  在需要登录的地方调用       \n    *  如果已经登陆,会立即执行回调       \n    *  否则,会显示登录窗口,登录完成后执行回 调  \n    *  todo:登录窗口的  UI  优化  \n*/</span>  \n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">login</span><span class=\"params\">(cb)</span> </span>{  \n}\n</code></pre><hr>\n<h3 id=\"简短标记\">简短标记</h3><p>简短标记让代码更简单易读</p>\n<pre><code><span class=\"comment\">// Bad</span>\n<span class=\"keyword\">var</span> user = <span class=\"keyword\">new</span> <span class=\"type\">Object</span>;\nuser.name = <span class=\"symbol\">'bajief</span>e';\nuser.age = <span class=\"number\">20</span>;\n\n<span class=\"comment\">// Good</span>\n<span class=\"keyword\">var</span> user = {\n    name: <span class=\"symbol\">'bajief</span>e',\n    age: <span class=\"number\">20</span>\n};\n\n<span class=\"comment\">// Bad</span>\n<span class=\"keyword\">var</span> userList = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>;\nuserList[<span class=\"number\">0</span>] = <span class=\"symbol\">'bajief</span>e';\nuserList[<span class=\"number\">1</span>] = <span class=\"symbol\">'bajier</span>d';\n\n<span class=\"comment\">// Good</span>\n<span class=\"keyword\">var</span> userList = [<span class=\"symbol\">'bajief</span>e', <span class=\"symbol\">'bajier</span>d'];\n\n\n<span class=\"comment\">// Bad</span>\n<span class=\"keyword\">var</span> age;\n<span class=\"keyword\">if</span>(<span class=\"function\"><span class=\"keyword\">val</span>) {</span>\n    age = <span class=\"function\"><span class=\"keyword\">val</span>;</span>\n} <span class=\"keyword\">else</span> {\n    age = <span class=\"number\">10</span>;\n}\n\n<span class=\"comment\">// Good</span>\n<span class=\"keyword\">var</span> age = <span class=\"function\"><span class=\"keyword\">val</span> <span class=\"title\">||</span> 10;</span>\n\n\n<span class=\"comment\">// Bad</span>\n<span class=\"keyword\">var</span> direction;\n\n<span class=\"keyword\">if</span>(<span class=\"function\"><span class=\"keyword\">val</span>) {</span>\n    direction = <span class=\"number\">1</span>;\n} <span class=\"keyword\">else</span> {\n    direction = -<span class=\"number\">1</span>;\n}\n\n<span class=\"comment\">// Good</span>\n<span class=\"keyword\">var</span> direction = <span class=\"function\"><span class=\"keyword\">val</span> <span class=\"title\">?</span> 1 :</span> -<span class=\"number\">1</span>;\n</code></pre><hr>\n<h3 id=\"减少DOM_操作\">减少DOM 操作</h3><p>通过 className 来控制 DOM 样式</p>\n<pre><code><span class=\"comment\">// Bad</span>\nuserInput.style.cssText = <span class=\"string\">'color: red; border: 1px  solid  red;'</span>  \n\n<span class=\"comment\">// Good</span>\nuserInput.className  =  ‘<span class=\"keyword\">error</span>;’\n</code></pre><p>dom 节点修改好后再插入 dom  tree</p>\n<pre><code>// Bad\nfunction addAnchor(parentElement, <span class=\"built_in\">anchor</span>Text, <span class=\"built_in\">anchor</span>Class) {\n    var element = document.createElement('a');\n    parentElement.appendChild(element);\n    element.innerHTML = <span class=\"built_in\">anchor</span>Text;\n    element.className = <span class=\"built_in\">anchor</span>Class;\n}\n\n// Good\nvar element = document.createElement('a');\nelement.innerHTML = <span class=\"built_in\">anchor</span>Text;\nelement.className = <span class=\"built_in\">anchor</span>Class;\nparentElement.appendChild(element);\n</code></pre><p>通过文档片段创建 DOM</p>\n<pre><code><span class=\"built_in\">document</span>.createDocumentFragment();\n\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addAnchors</span>(<span class=\"params\">element</span>) </span>{\n    <span class=\"keyword\">var</span> anchor;\n    <span class=\"keyword\">var</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();\n\n    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) {\n        anchor = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'a'</span>);\n        anchor.innerHTML = <span class=\"string\">'test'</span>;\n        fragment.appendChild(anchor);\n    }\n\n    element.appendChild(fragment);\n}\n</code></pre><p>通过事件代理绑定事件</p>\n<hr>\n<h3 id=\"自动分号插入\">自动分号插入</h3><p>当不清楚写不写分号时,写上</p>\n<pre><code><span class=\"keyword\">var</span> tester = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n\n}\n\n(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"built_in\">console</span>.log(tester);\n})()\n\n<span class=\"keyword\">var</span> a = <span class=\"number\">123</span>\n</code></pre><hr>\n<h3 id=\"Debug\">Debug</h3><p>Google 开发者工具</p>\n","excerpt":"","more":"<hr>\n<h3 id=\"命名\">命名</h3><p>代码是给人(别人或者1个星期后的 自己)阅读和修改的 </p>\n<p>給变量和函数一个简单易懂的名字 </p>\n<p>可维护性++</p>\n<p><strong> 以功能命名,而不是表现  isOverSeven() × VS isLegalAge() √ </strong></p>\n<pre><code><span class=\"comment\">// 不好的命名</span>\naaaa  \nx1  \nf  \nhengxian  \ncreateNewUserIfTheInputIsValida\n<span class=\"keyword\">te</span>\n</code></pre><p>   避免全局变量</p>\n<blockquote>\n<p>我们无法拥有代码的控制权</p>\n</blockquote>\n<ul>\n<li>不易维护 </li>\n<li>牵一发而动全身 </li>\n<li>易被覆盖,修改,而你还不知道</li>\n</ul>\n<pre><code> <span class=\"comment\">// Bad</span>\n<span class=\"keyword\">var</span> currentColor;\n<span class=\"keyword\">var</span> colorMap = {\n    red: <span class=\"string\">'红色'</span>,\n    green: <span class=\"string\">'绿色'</span>,\n    yellow: <span class=\"string\">'黄色'</span>\n};\n\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>) </span>{\n    currentColor = <span class=\"string\">'red'</span>;\n}\n\n\n<span class=\"comment\">// Common</span>\n(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"keyword\">var</span> currentColor;\n\n    <span class=\"keyword\">var</span> colorMap = {\n        red: <span class=\"string\">'红色'</span>,\n        green: <span class=\"string\">'绿色'</span>,\n        yellow: <span class=\"string\">'黄色'</span>\n    };\n\n    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span> (<span class=\"params\"></span>) </span>{\n        currentColor = <span class=\"string\">'red'</span>;\n    }\n})();\n\n<span class=\"comment\">// Good</span>\n<span class=\"keyword\">var</span> colorManager = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{  \n<span class=\"keyword\">var</span> currentColor;  \n<span class=\"keyword\">var</span> colorMap  =  {           \n    red: <span class=\"string\">'红色'</span>,           \n    green: <span class=\"string\">'绿色'</span>,           \n    yellow: <span class=\"string\">'黄色'</span> \n};  \n\n    <span class=\"keyword\">return</span>  { \n        init: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{                   \n            currentColor  =  <span class=\"string\">'red'</span>          \n        } \n    } \n}();\n</code></pre><hr>\n<h3 id=\"正确的注释\">正确的注释</h3><p>注释也是代码的一部分 </p>\n<p>错误的注释,相比没有注释,更可怕 </p>\n<p>介绍背景、介绍使用方式、介绍注意事项,不要重复代码的意思</p>\n<pre><code><span class=\"comment\">//  已登陆的用户,有  name  和  age  两个属性  </span>\n<span class=\"keyword\">var</span> loginedUser = {           \n    name:  <span class=\"string\">''</span>,           \n    age:  <span class=\"number\">10</span>  \n};\n<span class=\"comment\">/*  \n    *  统一登录方法  \n    *  在需要登录的地方调用       \n    *  如果已经登陆,会立即执行回调       \n    *  否则,会显示登录窗口,登录完成后执行回 调  \n    *  todo:登录窗口的  UI  优化  \n*/</span>  \n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">login</span><span class=\"params\">(cb)</span> </span>{  \n}\n</code></pre><hr>\n<h3 id=\"简短标记\">简短标记</h3><p>简短标记让代码更简单易读</p>\n<pre><code><span class=\"comment\">// Bad</span>\n<span class=\"keyword\">var</span> user = <span class=\"keyword\">new</span> <span class=\"type\">Object</span>;\nuser.name = <span class=\"symbol\">'bajief</span>e';\nuser.age = <span class=\"number\">20</span>;\n\n<span class=\"comment\">// Good</span>\n<span class=\"keyword\">var</span> user = {\n    name: <span class=\"symbol\">'bajief</span>e',\n    age: <span class=\"number\">20</span>\n};\n\n<span class=\"comment\">// Bad</span>\n<span class=\"keyword\">var</span> userList = <span class=\"keyword\">new</span> <span class=\"type\">Array</span>;\nuserList[<span class=\"number\">0</span>] = <span class=\"symbol\">'bajief</span>e';\nuserList[<span class=\"number\">1</span>] = <span class=\"symbol\">'bajier</span>d';\n\n<span class=\"comment\">// Good</span>\n<span class=\"keyword\">var</span> userList = [<span class=\"symbol\">'bajief</span>e', <span class=\"symbol\">'bajier</span>d'];\n\n\n<span class=\"comment\">// Bad</span>\n<span class=\"keyword\">var</span> age;\n<span class=\"keyword\">if</span>(<span class=\"function\"><span class=\"keyword\">val</span>) {</span>\n    age = <span class=\"function\"><span class=\"keyword\">val</span>;</span>\n} <span class=\"keyword\">else</span> {\n    age = <span class=\"number\">10</span>;\n}\n\n<span class=\"comment\">// Good</span>\n<span class=\"keyword\">var</span> age = <span class=\"function\"><span class=\"keyword\">val</span> <span class=\"title\">||</span> 10;</span>\n\n\n<span class=\"comment\">// Bad</span>\n<span class=\"keyword\">var</span> direction;\n\n<span class=\"keyword\">if</span>(<span class=\"function\"><span class=\"keyword\">val</span>) {</span>\n    direction = <span class=\"number\">1</span>;\n} <span class=\"keyword\">else</span> {\n    direction = -<span class=\"number\">1</span>;\n}\n\n<span class=\"comment\">// Good</span>\n<span class=\"keyword\">var</span> direction = <span class=\"function\"><span class=\"keyword\">val</span> <span class=\"title\">?</span> 1 :</span> -<span class=\"number\">1</span>;\n</code></pre><hr>\n<h3 id=\"减少DOM_操作\">减少DOM 操作</h3><p>通过 className 来控制 DOM 样式</p>\n<pre><code><span class=\"comment\">// Bad</span>\nuserInput.style.cssText = <span class=\"string\">'color: red; border: 1px  solid  red;'</span>  \n\n<span class=\"comment\">// Good</span>\nuserInput.className  =  ‘<span class=\"keyword\">error</span>;’\n</code></pre><p>dom 节点修改好后再插入 dom  tree</p>\n<pre><code>// Bad\nfunction addAnchor(parentElement, <span class=\"built_in\">anchor</span>Text, <span class=\"built_in\">anchor</span>Class) {\n    var element = document.createElement('a');\n    parentElement.appendChild(element);\n    element.innerHTML = <span class=\"built_in\">anchor</span>Text;\n    element.className = <span class=\"built_in\">anchor</span>Class;\n}\n\n// Good\nvar element = document.createElement('a');\nelement.innerHTML = <span class=\"built_in\">anchor</span>Text;\nelement.className = <span class=\"built_in\">anchor</span>Class;\nparentElement.appendChild(element);\n</code></pre><p>通过文档片段创建 DOM</p>\n<pre><code><span class=\"built_in\">document</span>.createDocumentFragment();\n\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addAnchors</span>(<span class=\"params\">element</span>) </span>{\n    <span class=\"keyword\">var</span> anchor;\n    <span class=\"keyword\">var</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();\n\n    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) {\n        anchor = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'a'</span>);\n        anchor.innerHTML = <span class=\"string\">'test'</span>;\n        fragment.appendChild(anchor);\n    }\n\n    element.appendChild(fragment);\n}\n</code></pre><p>通过事件代理绑定事件</p>\n<hr>\n<h3 id=\"自动分号插入\">自动分号插入</h3><p>当不清楚写不写分号时,写上</p>\n<pre><code><span class=\"keyword\">var</span> tester = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n\n}\n\n(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"built_in\">console</span>.log(tester);\n})()\n\n<span class=\"keyword\">var</span> a = <span class=\"number\">123</span>\n</code></pre><hr>\n<h3 id=\"Debug\">Debug</h3><p>Google 开发者工具</p>\n"},{"title":"js中文输入法字符串截断问题解决","date":"2016-01-27T06:06:50.000Z","_content":"最近遇到了一个需求：一个输入框最大输入字数为7个字，用户输入超出7个字时，显示警告提示，并且阻止用户输入。\n\n用input propertychange事件可以监听到用户的输入，在英文或者数字输入状态是没有问题的。但是在中文输入法输入情况下，不同浏览器有不同的表现。有的浏览器会在输入拼音时就会进入判断，如果拼音就已经超过7个字符，就不能再继续输入。\n如下：\n```html\n<input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">\n        var test = $('#test');\n        test.on('input propertychange', function() {\n            var value = $(this).val();\n            console.log('当前输入：'+value);\n            if(value.length>7){\n                $(this).val(value.substring(0,7));\n                $('.warn').show()\n            }else{\n                $('.warn').hide();\n            }\n        })\n    </script>\n```\n<textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">var test = $('#test');test.on('input propertychange', function(){var value = $(this).val();console.log('当前输入：'+value);if(value.length>7){$(this).val(value.substring(0,7));$('.warn').show()}else{$('.warn').hide();}})</script><body></textarea>\n\n<input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n运行以上代码可以发现，比如我想输入“报价方案”时，如果打全拼根本无法打出来就被阻止了。在网上找了解决方案之后，发现了一些以前没听过的事件。\n\n>#### 复合事件\n复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理IME的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计的。\n       （1）compositionstart：在IME的文本复合系统打开时触发，表示要开始输入了。\n（2）compositionupdate：在向输入字段中插入新字符时触发。\n（3）compositionend：在IME的文本复合系统关闭时触发，表示返回正常键盘的输入状态。\n\n用这个事件，我们可以实现中文输入法截断的问题了。如下：\n\n```html\n    <input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">\n        var test = $('#test');\n        test.on('input propertychange change', function() {\n            if($(this).prop('comStart')) return;    // 中文输入过程中不截断\n            var value = $(this).val();\n            console.log('当前输入：'+value);\n            if(value.length>7){\n                $(this).val(value.substring(0,7));\n                $('.warn').show()\n            }else{\n                $('.warn').hide();\n            }\n        }).on('compositionstart', function(){\n            $(this).prop('comStart', true);\n            console.log('中文输入：开始');\n        }).on('compositionend', function(){\n            $(this).prop('comStart', false);\n            console.log('中文输入：结束');\n        });\n    </script>\n```\n<textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span><script type=\"text/javascript\">var test = $('#test');test.on('input propertychange change', function(){if($(this).prop('comStart')) return;var value = $(this).val();console.log('当前输入：'+value);if(value.length>7){$(this).val(value.substring(0,7));$('.warn').show()}else{$('.warn').hide();}}).on('compositionstart', function(){$(this).prop('comStart', true);console.log('中文输入：开始');}).on('compositionend', function(){$(this).prop('comStart', false);console.log('中文输入：结束');});</script></body></textarea>\n\n<input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n![完美](http://i4.tietuku.com/e52018b653051022.jpg)\n\n","source":"_posts/ChineseInputMethods.md","raw":"title: js中文输入法字符串截断问题解决\ndate: 2016-01-27 14:06:50\ntags: Javascript学习笔记\n\n---\n最近遇到了一个需求：一个输入框最大输入字数为7个字，用户输入超出7个字时，显示警告提示，并且阻止用户输入。\n\n用input propertychange事件可以监听到用户的输入，在英文或者数字输入状态是没有问题的。但是在中文输入法输入情况下，不同浏览器有不同的表现。有的浏览器会在输入拼音时就会进入判断，如果拼音就已经超过7个字符，就不能再继续输入。\n如下：\n```html\n<input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">\n        var test = $('#test');\n        test.on('input propertychange', function() {\n            var value = $(this).val();\n            console.log('当前输入：'+value);\n            if(value.length>7){\n                $(this).val(value.substring(0,7));\n                $('.warn').show()\n            }else{\n                $('.warn').hide();\n            }\n        })\n    </script>\n```\n<textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">var test = $('#test');test.on('input propertychange', function(){var value = $(this).val();console.log('当前输入：'+value);if(value.length>7){$(this).val(value.substring(0,7));$('.warn').show()}else{$('.warn').hide();}})</script><body></textarea>\n\n<input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n运行以上代码可以发现，比如我想输入“报价方案”时，如果打全拼根本无法打出来就被阻止了。在网上找了解决方案之后，发现了一些以前没听过的事件。\n\n>#### 复合事件\n复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理IME的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计的。\n       （1）compositionstart：在IME的文本复合系统打开时触发，表示要开始输入了。\n（2）compositionupdate：在向输入字段中插入新字符时触发。\n（3）compositionend：在IME的文本复合系统关闭时触发，表示返回正常键盘的输入状态。\n\n用这个事件，我们可以实现中文输入法截断的问题了。如下：\n\n```html\n    <input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span>\n    <script type=\"text/javascript\">\n        var test = $('#test');\n        test.on('input propertychange change', function() {\n            if($(this).prop('comStart')) return;    // 中文输入过程中不截断\n            var value = $(this).val();\n            console.log('当前输入：'+value);\n            if(value.length>7){\n                $(this).val(value.substring(0,7));\n                $('.warn').show()\n            }else{\n                $('.warn').hide();\n            }\n        }).on('compositionstart', function(){\n            $(this).prop('comStart', true);\n            console.log('中文输入：开始');\n        }).on('compositionend', function(){\n            $(this).prop('comStart', false);\n            console.log('中文输入：结束');\n        });\n    </script>\n```\n<textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span><script type=\"text/javascript\">var test = $('#test');test.on('input propertychange change', function(){if($(this).prop('comStart')) return;var value = $(this).val();console.log('当前输入：'+value);if(value.length>7){$(this).val(value.substring(0,7));$('.warn').show()}else{$('.warn').hide();}}).on('compositionstart', function(){$(this).prop('comStart', true);console.log('中文输入：开始');}).on('compositionend', function(){$(this).prop('comStart', false);console.log('中文输入：结束');});</script></body></textarea>\n\n<input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n![完美](http://i4.tietuku.com/e52018b653051022.jpg)\n\n","slug":"ChineseInputMethods","published":1,"updated":"2017-03-08T08:55:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ewd0005er2zs4ww69kt","content":"<p>最近遇到了一个需求：一个输入框最大输入字数为7个字，用户输入超出7个字时，显示警告提示，并且阻止用户输入。</p>\n<p>用input propertychange事件可以监听到用户的输入，在英文或者数字输入状态是没有问题的。但是在中文输入法输入情况下，不同浏览器有不同的表现。有的浏览器会在输入拼音时就会进入判断，如果拼音就已经超过7个字符，就不能再继续输入。<br>如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"warn\"</span>&gt;</span>不能输入超过7个字<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">        var test = $('#test');</div><div class=\"line\">        test.on('input propertychange', function() &#123;</div><div class=\"line\">            var value = $(this).val();</div><div class=\"line\">            console.log('当前输入：'+value);</div><div class=\"line\">            if(value.length&gt;7)&#123;</div><div class=\"line\">                $(this).val(value.substring(0,7));</div><div class=\"line\">                $('.warn').show()</div><div class=\"line\">            &#125;else&#123;</div><div class=\"line\">                $('.warn').hide();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"><span class=\"warn\">不能输入超过7个字</span><br>    <script type=\"text/javascript\">var test = $(‘#test’);test.on(‘input propertychange’, function(){var value = $(this).val();console.log(‘当前输入：’+value);if(value.length&gt;7){$(this).val(value.substring(0,7));$(‘.warn’).show()}else{$(‘.warn’).hide();}})</script><body></body></body></textarea>\n\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"><br></p>\n<p>运行以上代码可以发现，比如我想输入“报价方案”时，如果打全拼根本无法打出来就被阻止了。在网上找了解决方案之后，发现了一些以前没听过的事件。</p>\n<blockquote>\n<h4 id=\"复合事件\">复合事件</h4><p>复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理IME的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计的。<br>       （1）compositionstart：在IME的文本复合系统打开时触发，表示要开始输入了。<br>（2）compositionupdate：在向输入字段中插入新字符时触发。<br>（3）compositionend：在IME的文本复合系统关闭时触发，表示返回正常键盘的输入状态。</p>\n</blockquote>\n<p>用这个事件，我们可以实现中文输入法截断的问题了。如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"warn\"</span>&gt;</span>不能输入超过7个字<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">    var test = $('#test');</div><div class=\"line\">    test.on('input propertychange change', function() &#123;</div><div class=\"line\">        if($(this).prop('comStart')) return;    // 中文输入过程中不截断</div><div class=\"line\">        var value = $(this).val();</div><div class=\"line\">        console.log('当前输入：'+value);</div><div class=\"line\">        if(value.length&gt;7)&#123;</div><div class=\"line\">            $(this).val(value.substring(0,7));</div><div class=\"line\">            $('.warn').show()</div><div class=\"line\">        &#125;else&#123;</div><div class=\"line\">            $('.warn').hide();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).on('compositionstart', function()&#123;</div><div class=\"line\">        $(this).prop('comStart', true);</div><div class=\"line\">        console.log('中文输入：开始');</div><div class=\"line\">    &#125;).on('compositionend', function()&#123;</div><div class=\"line\">        $(this).prop('comStart', false);</div><div class=\"line\">        console.log('中文输入：结束');</div><div class=\"line\">    &#125;);</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"><span class=\"warn\">不能输入超过7个字</span><script type=\"text/javascript\">var test = $(‘#test’);test.on(‘input propertychange change’, function(){if($(this).prop(‘comStart’)) return;var value = $(this).val();console.log(‘当前输入：’+value);if(value.length&gt;7){$(this).val(value.substring(0,7));$(‘.warn’).show()}else{$(‘.warn’).hide();}}).on(‘compositionstart’, function(){$(this).prop(‘comStart’, true);console.log(‘中文输入：开始’);}).on(‘compositionend’, function(){$(this).prop(‘comStart’, false);console.log(‘中文输入：结束’);});</script></body></textarea>\n\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"><br></p>\n<p><img src=\"http://i4.tietuku.com/e52018b653051022.jpg\" alt=\"完美\"></p>\n","excerpt":"","more":"<p>最近遇到了一个需求：一个输入框最大输入字数为7个字，用户输入超出7个字时，显示警告提示，并且阻止用户输入。</p>\n<p>用input propertychange事件可以监听到用户的输入，在英文或者数字输入状态是没有问题的。但是在中文输入法输入情况下，不同浏览器有不同的表现。有的浏览器会在输入拼音时就会进入判断，如果拼音就已经超过7个字符，就不能再继续输入。<br>如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"warn\"</span>&gt;</span>不能输入超过7个字<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></div><div class=\"line\">        var test = $('#test');</div><div class=\"line\">        test.on('input propertychange', function() &#123;</div><div class=\"line\">            var value = $(this).val();</div><div class=\"line\">            console.log('当前输入：'+value);</div><div class=\"line\">            if(value.length&gt;7)&#123;</div><div class=\"line\">                $(this).val(value.substring(0,7));</div><div class=\"line\">                $('.warn').show()</div><div class=\"line\">            &#125;else&#123;</div><div class=\"line\">                $('.warn').hide();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span><br>    <script type=\"text/javascript\">var test = $(‘#test’);test.on(‘input propertychange’, function(){var value = $(this).val();console.log(‘当前输入：’+value);if(value.length&gt;7){$(this).val(value.substring(0,7));$(‘.warn’).show()}else{$(‘.warn’).hide();}})</script><body></textarea>\n\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/></p>\n<p>运行以上代码可以发现，比如我想输入“报价方案”时，如果打全拼根本无法打出来就被阻止了。在网上找了解决方案之后，发现了一些以前没听过的事件。</p>\n<blockquote>\n<h4 id=\"复合事件\">复合事件</h4><p>复合事件（composition event）是DOM3级事件中新添加的一类事件，用于处理IME的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计的。<br>       （1）compositionstart：在IME的文本复合系统打开时触发，表示要开始输入了。<br>（2）compositionupdate：在向输入字段中插入新字符时触发。<br>（3）compositionend：在IME的文本复合系统关闭时触发，表示返回正常键盘的输入状态。</p>\n</blockquote>\n<p>用这个事件，我们可以实现中文输入法截断的问题了。如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"warn\"</span>&gt;</span>不能输入超过7个字<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></div><div class=\"line\">    var test = $('#test');</div><div class=\"line\">    test.on('input propertychange change', function() &#123;</div><div class=\"line\">        if($(this).prop('comStart')) return;    // 中文输入过程中不截断</div><div class=\"line\">        var value = $(this).val();</div><div class=\"line\">        console.log('当前输入：'+value);</div><div class=\"line\">        if(value.length&gt;7)&#123;</div><div class=\"line\">            $(this).val(value.substring(0,7));</div><div class=\"line\">            $('.warn').show()</div><div class=\"line\">        &#125;else&#123;</div><div class=\"line\">            $('.warn').hide();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).on('compositionstart', function()&#123;</div><div class=\"line\">        $(this).prop('comStart', true);</div><div class=\"line\">        console.log('中文输入：开始');</div><div class=\"line\">    &#125;).on('compositionend', function()&#123;</div><div class=\"line\">        $(this).prop('comStart', false);</div><div class=\"line\">        console.log('中文输入：结束');</div><div class=\"line\">    &#125;);</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js\"></script><style type=\"text/css\">.warn{display: none;color: #f00;}</style><body><input id=\"test\"/><span class=\"warn\">不能输入超过7个字</span><script type=\"text/javascript\">var test = $(‘#test’);test.on(‘input propertychange change’, function(){if($(this).prop(‘comStart’)) return;var value = $(this).val();console.log(‘当前输入：’+value);if(value.length&gt;7){$(this).val(value.substring(0,7));$(‘.warn’).show()}else{$(‘.warn’).hide();}}).on(‘compositionstart’, function(){$(this).prop(‘comStart’, true);console.log(‘中文输入：开始’);}).on(‘compositionend’, function(){$(this).prop(‘comStart’, false);console.log(‘中文输入：结束’);});</script></body></textarea>\n\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/></p>\n<p><img src=\"http://i4.tietuku.com/e52018b653051022.jpg\" alt=\"完美\"></p>\n"},{"title":"2016年计划（目标）","date":"2016-02-17T02:17:50.000Z","_content":"农历新年也已经过完了，我也该给自己打打鸡血，制定一个2016年的目标了。\n<!-- more -->\n2015年，充满转折和幸运的一年。从运营转前端，也离开学校在外实习了大半年，去过杭州2个月，互联网环境很好的一个城市，但还是发现自己更爱起伏不平的山城和麻辣火锅。后来回到重庆，幸运地进入了猪八戒，也幸运地认识了一些志同道合的小伙伴和一些前辈大神。\n\n为了能够有一个美好的2016年，我制定了以下目标激励自己：\n\n1. 无特殊情况，每天晚上睡前做半个小时以上运动 \n2. 无特殊情况，每天晚上睡前看半个小时以上书，看完书单上的书。\n3. 拿驾照 (已完成)\n4. 完成毕业设计期间学习，达成学习目标（部分完成）\n5. 存钱毕业旅行 (已完成)\n6. 存钱买mac pro\n7. 会做一桌好吃的菜 \n\n我感觉这几个目标（除了拿驾照）对拖延癌懒癌月光族的我来说都好难..(ノ_<)\n我每个月末都来回顾总结一下目标的完成情况吧。加油。\n\n┄┅┄┅┄┅┄┅┄┅┄┅┅＊     2016.07.04 更新分割线         ＊┄┅┄┅┄┅┄┅┄┅┄┅┄┅\n\n啊~~ 我又回来更新了！\n4月份之后就暂停实习回去浪了一个月，然后搞毕业设计答辩一个月，毕业聚餐又浪了一个月。今天又回公司开始正式工作了~\n趁着还没有开始做需求的时候，回顾一下之前定的计划吧。\n\n#1和#2计划在这几个月里已经扑街，这3个月太浪了=.= 运动和学习计划重新启动ing。\n\n#3驾照已经顺利拿下，每个科目都是一次通过，江湖上又多了一个传说~ \n\n#4毕业设计用了Node+express+ejs后台，用了leancloud做数据存储，算是加深了一下对node的熟悉程度吧，还是挺有收获的，不过没有完全达到学习的目标，主要还是浪去了- -。\n\n#5毕业旅行去三亚和海口玩了7天左右。\n\n#6还没拿工资，处于吃土阶段，这个之后再看吧。。\n\n#7学习中~ 目前做得比较好吃的菜：榨菜肉丝、土豆焖鸡翅、炒土豆丝、炒白菜、番茄鸡蛋汤…… 还会继续增加。\n","source":"_posts/2016年计划（目标）.md","raw":"title: 2016年计划（目标）\ndate: 2016-02-17 10:17:50\ntags: 生活琐事\n---\n农历新年也已经过完了，我也该给自己打打鸡血，制定一个2016年的目标了。\n<!-- more -->\n2015年，充满转折和幸运的一年。从运营转前端，也离开学校在外实习了大半年，去过杭州2个月，互联网环境很好的一个城市，但还是发现自己更爱起伏不平的山城和麻辣火锅。后来回到重庆，幸运地进入了猪八戒，也幸运地认识了一些志同道合的小伙伴和一些前辈大神。\n\n为了能够有一个美好的2016年，我制定了以下目标激励自己：\n\n1. 无特殊情况，每天晚上睡前做半个小时以上运动 \n2. 无特殊情况，每天晚上睡前看半个小时以上书，看完书单上的书。\n3. 拿驾照 (已完成)\n4. 完成毕业设计期间学习，达成学习目标（部分完成）\n5. 存钱毕业旅行 (已完成)\n6. 存钱买mac pro\n7. 会做一桌好吃的菜 \n\n我感觉这几个目标（除了拿驾照）对拖延癌懒癌月光族的我来说都好难..(ノ_<)\n我每个月末都来回顾总结一下目标的完成情况吧。加油。\n\n┄┅┄┅┄┅┄┅┄┅┄┅┅＊     2016.07.04 更新分割线         ＊┄┅┄┅┄┅┄┅┄┅┄┅┄┅\n\n啊~~ 我又回来更新了！\n4月份之后就暂停实习回去浪了一个月，然后搞毕业设计答辩一个月，毕业聚餐又浪了一个月。今天又回公司开始正式工作了~\n趁着还没有开始做需求的时候，回顾一下之前定的计划吧。\n\n#1和#2计划在这几个月里已经扑街，这3个月太浪了=.= 运动和学习计划重新启动ing。\n\n#3驾照已经顺利拿下，每个科目都是一次通过，江湖上又多了一个传说~ \n\n#4毕业设计用了Node+express+ejs后台，用了leancloud做数据存储，算是加深了一下对node的熟悉程度吧，还是挺有收获的，不过没有完全达到学习的目标，主要还是浪去了- -。\n\n#5毕业旅行去三亚和海口玩了7天左右。\n\n#6还没拿工资，处于吃土阶段，这个之后再看吧。。\n\n#7学习中~ 目前做得比较好吃的菜：榨菜肉丝、土豆焖鸡翅、炒土豆丝、炒白菜、番茄鸡蛋汤…… 还会继续增加。\n","slug":"2016年计划（目标）","published":1,"updated":"2016-11-22T06:16:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ewg0006er2z324dw0xg","content":"<p>农历新年也已经过完了，我也该给自己打打鸡血，制定一个2016年的目标了。<br><a id=\"more\"></a><br>2015年，充满转折和幸运的一年。从运营转前端，也离开学校在外实习了大半年，去过杭州2个月，互联网环境很好的一个城市，但还是发现自己更爱起伏不平的山城和麻辣火锅。后来回到重庆，幸运地进入了猪八戒，也幸运地认识了一些志同道合的小伙伴和一些前辈大神。</p>\n<p>为了能够有一个美好的2016年，我制定了以下目标激励自己：</p>\n<ol>\n<li>无特殊情况，每天晚上睡前做半个小时以上运动 </li>\n<li>无特殊情况，每天晚上睡前看半个小时以上书，看完书单上的书。</li>\n<li>拿驾照 (已完成)</li>\n<li>完成毕业设计期间学习，达成学习目标（部分完成）</li>\n<li>存钱毕业旅行 (已完成)</li>\n<li>存钱买mac pro</li>\n<li>会做一桌好吃的菜 </li>\n</ol>\n<p>我感觉这几个目标（除了拿驾照）对拖延癌懒癌月光族的我来说都好难..(ノ_&lt;)<br>我每个月末都来回顾总结一下目标的完成情况吧。加油。</p>\n<p>┄┅┄┅┄┅┄┅┄┅┄┅┅＊     2016.07.04 更新分割线         ＊┄┅┄┅┄┅┄┅┄┅┄┅┄┅</p>\n<p>啊~~ 我又回来更新了！<br>4月份之后就暂停实习回去浪了一个月，然后搞毕业设计答辩一个月，毕业聚餐又浪了一个月。今天又回公司开始正式工作了~<br>趁着还没有开始做需求的时候，回顾一下之前定的计划吧。</p>\n<p>#1和#2计划在这几个月里已经扑街，这3个月太浪了=.= 运动和学习计划重新启动ing。</p>\n<p>#3驾照已经顺利拿下，每个科目都是一次通过，江湖上又多了一个传说~ </p>\n<p>#4毕业设计用了Node+express+ejs后台，用了leancloud做数据存储，算是加深了一下对node的熟悉程度吧，还是挺有收获的，不过没有完全达到学习的目标，主要还是浪去了- -。</p>\n<p>#5毕业旅行去三亚和海口玩了7天左右。</p>\n<p>#6还没拿工资，处于吃土阶段，这个之后再看吧。。</p>\n<p>#7学习中~ 目前做得比较好吃的菜：榨菜肉丝、土豆焖鸡翅、炒土豆丝、炒白菜、番茄鸡蛋汤…… 还会继续增加。</p>\n","excerpt":"<p>农历新年也已经过完了，我也该给自己打打鸡血，制定一个2016年的目标了。<br>","more":"<br>2015年，充满转折和幸运的一年。从运营转前端，也离开学校在外实习了大半年，去过杭州2个月，互联网环境很好的一个城市，但还是发现自己更爱起伏不平的山城和麻辣火锅。后来回到重庆，幸运地进入了猪八戒，也幸运地认识了一些志同道合的小伙伴和一些前辈大神。</p>\n<p>为了能够有一个美好的2016年，我制定了以下目标激励自己：</p>\n<ol>\n<li>无特殊情况，每天晚上睡前做半个小时以上运动 </li>\n<li>无特殊情况，每天晚上睡前看半个小时以上书，看完书单上的书。</li>\n<li>拿驾照 (已完成)</li>\n<li>完成毕业设计期间学习，达成学习目标（部分完成）</li>\n<li>存钱毕业旅行 (已完成)</li>\n<li>存钱买mac pro</li>\n<li>会做一桌好吃的菜 </li>\n</ol>\n<p>我感觉这几个目标（除了拿驾照）对拖延癌懒癌月光族的我来说都好难..(ノ_&lt;)<br>我每个月末都来回顾总结一下目标的完成情况吧。加油。</p>\n<p>┄┅┄┅┄┅┄┅┄┅┄┅┅＊     2016.07.04 更新分割线         ＊┄┅┄┅┄┅┄┅┄┅┄┅┄┅</p>\n<p>啊~~ 我又回来更新了！<br>4月份之后就暂停实习回去浪了一个月，然后搞毕业设计答辩一个月，毕业聚餐又浪了一个月。今天又回公司开始正式工作了~<br>趁着还没有开始做需求的时候，回顾一下之前定的计划吧。</p>\n<p>#1和#2计划在这几个月里已经扑街，这3个月太浪了=.= 运动和学习计划重新启动ing。</p>\n<p>#3驾照已经顺利拿下，每个科目都是一次通过，江湖上又多了一个传说~ </p>\n<p>#4毕业设计用了Node+express+ejs后台，用了leancloud做数据存储，算是加深了一下对node的熟悉程度吧，还是挺有收获的，不过没有完全达到学习的目标，主要还是浪去了- -。</p>\n<p>#5毕业旅行去三亚和海口玩了7天左右。</p>\n<p>#6还没拿工资，处于吃土阶段，这个之后再看吧。。</p>\n<p>#7学习中~ 目前做得比较好吃的菜：榨菜肉丝、土豆焖鸡翅、炒土豆丝、炒白菜、番茄鸡蛋汤…… 还会继续增加。</p>"},{"title":"jQuery性能优化","date":"2015-11-25T02:17:50.000Z","_content":"jQuery已经成为前端开发中重要的类库之一，也是前端开发er的一个利器，了解到如何正确使用jQuery达到最佳性能是一个很重要的事。下面从各个方面来总结一下jQuery性能优化技巧和注意事项。\n<!-- more -->\n### 一、使用合适的选择器\n**$('#id')**\n使用id来定位DOM元素无疑是提高性能的最佳方式，因为这会直接调用本地方法`document.getElementById()`。\n如果这样找不到所需要的元素，可以使用find()方法。`$(\"#content\").find(\"div\");`为了提高性能，建议从最近的id元素开始往下搜索。\n\n**$('p'),$('div'),$('input')**\n标签选择器也不错，因为jQuery是直接调用本地方法`document.getElementsByTagName()`。\n\n**$('.class')**\n对于比较新的浏览器，它支持本地方法`document.getElementsByClassName()`。但是对于ie8及以下版本浏览器，只能通过DOM搜索的方法来实现，这无疑会带来一些性能的影响。建议有选择地使用。\n\n**$(\"[attribute=value]\")**\n对于利用属性来定位DOM元素，本地javascript并没有方法直接实现，大多是使用DOM搜索的方式来达到效果。很多现代浏览器支持querySelectAll()方法，但是不同浏览器的性能还是有区别。总体来说，使用这种方式性能不是非常理想，所以为了获得更好的优化效果，建议尽量避免这种对性能有害的方式。\n\n**$(\":hidden\")**\n和上面利用属性定位DOM元素一样，这种伪选择器也同样没有直接在本地javascript方法中实现，并且jQuery需要搜索每一个元素来定位这个选择器，这将对性能带来比较大的影响，所以建议尽量不要使用。如果非要使用，请先使用ID选择器定位父元素然后再使用该选择器，这样对性能优化有帮助。\n\n- **尽量使用ID选择器**\n- **尽量给选择器指定上下文**\n\n### 二、缓存对象\n其实这是javascript也需要注意的地方\n```javascript\n//bad\n$(\"#light\").bind('click',function(){...});\n$(\"#light\").css('border',\"1px solid red\");\n$(\"#light\").fadeIn(\"slow\");\n\n//good\nvar light = $(\"#light\");\nlight.bind('click',function(){...});\nlight.css('border',\"1px solid red\");\nlight.fadeIn(\"slow\");\n```\n本例中用链式方式将更加简洁，上面只是为了说明缓存变量的重要性。\n```javascript\n//链式\nvar light = $(\"#light\");\nlight.bind('click',function(){...})\n    .css('border',\"1px solid red\")\n    .fadeIn(\"slow\");\n```\n如果打算在其他函数中使用jQuery对象，那么可以把它们缓存到全局环境中。如下代码所示：\n```javascript\nwindow.$my = {\n    head : $('head'),\n    light: $('#light'),\n    light_button: $(\"#light_button\")\n};\nfunction dosomething(){\n    //现在可以引用存储结构并操作它们\n    var script = docuement.creatElement(\"script\");\n    $my.head.append(script);\n    // 当你在函数内部操作时，可以继续将查询存入全局对象中去\n    $my.cool_results = $(\"#some_ul li\");\n    $my.other_results = $(\"#some\");\n    // 全局函数作为一个普通的jquery对象去使用\n    $my.other_results.css(\"border-color\",\"red\");\n}\n```\n记住，永远不要让相同的选择器在你的代码里出现多次。\n\n### 三、事件代理\n每一个JavaScript事件（例如click、mouseover等）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时，这点会很好用。比如,我们要为一个表格绑定这样的行为：点击td后，把背景色设置为红色，代码如下：\n```javascript\n//bad\n$(\"#mytable td\").click(functuon(){\n   $(this).css('background','red');\n});\n```\n假如有100个td元素，在使用以上方式时，绑定了100个事件，这将带来很负面的性能影响。\n```javascript\n//good\n$(\"#mytable\").click(function(e){\n    var $clicked = $(e.target);//e.target 捕捉到触发的目标元素\n    $clicked.css('background','red');\n});\n```\n在这种方式中，只为一个元素绑定了事件，明显优于之前那种。\n在jQuery 1.7中，提供了新的方式on()来帮助我们将整个事件监听封装到一个便利的方法中。\n```javascript\n//good\n$(\"#mytable\").on('click','td',function(e){\n    $(this).css('background','red');\n});\n```\n\n### 四、将你的代码转换为jQuery插件\n如果每次都需要用一定的时间去开发类似的代码，那么可以考虑将代码变成插件。它能够使你的代码有更好的重用性，并且能够有效组织代码。创建插件的代码如下：\n```javascript\n(function($){\n    $.fn.pulgName = function(){\n        //code\n        return this;\n    }\n})(jQuery)\n```\n### 五、合理利用HTML的data属性\nHTML5的data属性可以帮助我们插入数据，特别是前后端的数据交换。jQuery的data()方法可以自动得到数据。例子：\n```html\n<div id=\"d1\" data-role=\"page\" data-last-value=\"43\" data-options='{\"name\":\"John\"}'></div>\n```\n读取数据：\n```javascript\n$(\"#d1\").data(\"role\");  //page\n$(\"#d1\").data(\"last-value\");  //43\n$(\"#d1\").data(\"options\").name;  //John\n```\n\n*——总结来自《锋利的jQuery》*","source":"_posts/jQueryPerformanceOptimization.md","raw":"title: jQuery性能优化\ndate: 2015-11-25 10:17:50\ntags: Javascript学习笔记\n---\njQuery已经成为前端开发中重要的类库之一，也是前端开发er的一个利器，了解到如何正确使用jQuery达到最佳性能是一个很重要的事。下面从各个方面来总结一下jQuery性能优化技巧和注意事项。\n<!-- more -->\n### 一、使用合适的选择器\n**$('#id')**\n使用id来定位DOM元素无疑是提高性能的最佳方式，因为这会直接调用本地方法`document.getElementById()`。\n如果这样找不到所需要的元素，可以使用find()方法。`$(\"#content\").find(\"div\");`为了提高性能，建议从最近的id元素开始往下搜索。\n\n**$('p'),$('div'),$('input')**\n标签选择器也不错，因为jQuery是直接调用本地方法`document.getElementsByTagName()`。\n\n**$('.class')**\n对于比较新的浏览器，它支持本地方法`document.getElementsByClassName()`。但是对于ie8及以下版本浏览器，只能通过DOM搜索的方法来实现，这无疑会带来一些性能的影响。建议有选择地使用。\n\n**$(\"[attribute=value]\")**\n对于利用属性来定位DOM元素，本地javascript并没有方法直接实现，大多是使用DOM搜索的方式来达到效果。很多现代浏览器支持querySelectAll()方法，但是不同浏览器的性能还是有区别。总体来说，使用这种方式性能不是非常理想，所以为了获得更好的优化效果，建议尽量避免这种对性能有害的方式。\n\n**$(\":hidden\")**\n和上面利用属性定位DOM元素一样，这种伪选择器也同样没有直接在本地javascript方法中实现，并且jQuery需要搜索每一个元素来定位这个选择器，这将对性能带来比较大的影响，所以建议尽量不要使用。如果非要使用，请先使用ID选择器定位父元素然后再使用该选择器，这样对性能优化有帮助。\n\n- **尽量使用ID选择器**\n- **尽量给选择器指定上下文**\n\n### 二、缓存对象\n其实这是javascript也需要注意的地方\n```javascript\n//bad\n$(\"#light\").bind('click',function(){...});\n$(\"#light\").css('border',\"1px solid red\");\n$(\"#light\").fadeIn(\"slow\");\n\n//good\nvar light = $(\"#light\");\nlight.bind('click',function(){...});\nlight.css('border',\"1px solid red\");\nlight.fadeIn(\"slow\");\n```\n本例中用链式方式将更加简洁，上面只是为了说明缓存变量的重要性。\n```javascript\n//链式\nvar light = $(\"#light\");\nlight.bind('click',function(){...})\n    .css('border',\"1px solid red\")\n    .fadeIn(\"slow\");\n```\n如果打算在其他函数中使用jQuery对象，那么可以把它们缓存到全局环境中。如下代码所示：\n```javascript\nwindow.$my = {\n    head : $('head'),\n    light: $('#light'),\n    light_button: $(\"#light_button\")\n};\nfunction dosomething(){\n    //现在可以引用存储结构并操作它们\n    var script = docuement.creatElement(\"script\");\n    $my.head.append(script);\n    // 当你在函数内部操作时，可以继续将查询存入全局对象中去\n    $my.cool_results = $(\"#some_ul li\");\n    $my.other_results = $(\"#some\");\n    // 全局函数作为一个普通的jquery对象去使用\n    $my.other_results.css(\"border-color\",\"red\");\n}\n```\n记住，永远不要让相同的选择器在你的代码里出现多次。\n\n### 三、事件代理\n每一个JavaScript事件（例如click、mouseover等）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时，这点会很好用。比如,我们要为一个表格绑定这样的行为：点击td后，把背景色设置为红色，代码如下：\n```javascript\n//bad\n$(\"#mytable td\").click(functuon(){\n   $(this).css('background','red');\n});\n```\n假如有100个td元素，在使用以上方式时，绑定了100个事件，这将带来很负面的性能影响。\n```javascript\n//good\n$(\"#mytable\").click(function(e){\n    var $clicked = $(e.target);//e.target 捕捉到触发的目标元素\n    $clicked.css('background','red');\n});\n```\n在这种方式中，只为一个元素绑定了事件，明显优于之前那种。\n在jQuery 1.7中，提供了新的方式on()来帮助我们将整个事件监听封装到一个便利的方法中。\n```javascript\n//good\n$(\"#mytable\").on('click','td',function(e){\n    $(this).css('background','red');\n});\n```\n\n### 四、将你的代码转换为jQuery插件\n如果每次都需要用一定的时间去开发类似的代码，那么可以考虑将代码变成插件。它能够使你的代码有更好的重用性，并且能够有效组织代码。创建插件的代码如下：\n```javascript\n(function($){\n    $.fn.pulgName = function(){\n        //code\n        return this;\n    }\n})(jQuery)\n```\n### 五、合理利用HTML的data属性\nHTML5的data属性可以帮助我们插入数据，特别是前后端的数据交换。jQuery的data()方法可以自动得到数据。例子：\n```html\n<div id=\"d1\" data-role=\"page\" data-last-value=\"43\" data-options='{\"name\":\"John\"}'></div>\n```\n读取数据：\n```javascript\n$(\"#d1\").data(\"role\");  //page\n$(\"#d1\").data(\"last-value\");  //43\n$(\"#d1\").data(\"options\").name;  //John\n```\n\n*——总结来自《锋利的jQuery》*","slug":"jQueryPerformanceOptimization","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ewj0007er2zoux7mdh5","content":"<p>jQuery已经成为前端开发中重要的类库之一，也是前端开发er的一个利器，了解到如何正确使用jQuery达到最佳性能是一个很重要的事。下面从各个方面来总结一下jQuery性能优化技巧和注意事项。<br><a id=\"more\"></a></p>\n<h3 id=\"一、使用合适的选择器\">一、使用合适的选择器</h3><p><strong>$(‘#id’)</strong><br>使用id来定位DOM元素无疑是提高性能的最佳方式，因为这会直接调用本地方法<code>document.getElementById()</code>。<br>如果这样找不到所需要的元素，可以使用find()方法。<code>$(&quot;#content&quot;).find(&quot;div&quot;);</code>为了提高性能，建议从最近的id元素开始往下搜索。</p>\n<p><strong>$(‘p’),$(‘div’),$(‘input’)</strong><br>标签选择器也不错，因为jQuery是直接调用本地方法<code>document.getElementsByTagName()</code>。</p>\n<p><strong>$(‘.class’)</strong><br>对于比较新的浏览器，它支持本地方法<code>document.getElementsByClassName()</code>。但是对于ie8及以下版本浏览器，只能通过DOM搜索的方法来实现，这无疑会带来一些性能的影响。建议有选择地使用。</p>\n<p><strong>$(“[attribute=value]”)</strong><br>对于利用属性来定位DOM元素，本地javascript并没有方法直接实现，大多是使用DOM搜索的方式来达到效果。很多现代浏览器支持querySelectAll()方法，但是不同浏览器的性能还是有区别。总体来说，使用这种方式性能不是非常理想，所以为了获得更好的优化效果，建议尽量避免这种对性能有害的方式。</p>\n<p><strong>$(“:hidden”)</strong><br>和上面利用属性定位DOM元素一样，这种伪选择器也同样没有直接在本地javascript方法中实现，并且jQuery需要搜索每一个元素来定位这个选择器，这将对性能带来比较大的影响，所以建议尽量不要使用。如果非要使用，请先使用ID选择器定位父元素然后再使用该选择器，这样对性能优化有帮助。</p>\n<ul>\n<li><strong>尽量使用ID选择器</strong></li>\n<li><strong>尽量给选择器指定上下文</strong></li>\n</ul>\n<h3 id=\"二、缓存对象\">二、缓存对象</h3><p>其实这是javascript也需要注意的地方<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//bad</span></div><div class=\"line\">$(<span class=\"string\">\"#light\"</span>).bind(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);</div><div class=\"line\">$(<span class=\"string\">\"#light\"</span>).css(<span class=\"string\">'border'</span>,<span class=\"string\">\"1px solid red\"</span>);</div><div class=\"line\">$(<span class=\"string\">\"#light\"</span>).fadeIn(<span class=\"string\">\"slow\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//good</span></div><div class=\"line\"><span class=\"keyword\">var</span> light = $(<span class=\"string\">\"#light\"</span>);</div><div class=\"line\">light.bind(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);</div><div class=\"line\">light.css(<span class=\"string\">'border'</span>,<span class=\"string\">\"1px solid red\"</span>);</div><div class=\"line\">light.fadeIn(<span class=\"string\">\"slow\"</span>);</div></pre></td></tr></table></figure></p>\n<p>本例中用链式方式将更加简洁，上面只是为了说明缓存变量的重要性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//链式</span></div><div class=\"line\"><span class=\"keyword\">var</span> light = $(<span class=\"string\">\"#light\"</span>);</div><div class=\"line\">light.bind(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;)</div><div class=\"line\">    .css(<span class=\"string\">'border'</span>,<span class=\"string\">\"1px solid red\"</span>)</div><div class=\"line\">    .fadeIn(<span class=\"string\">\"slow\"</span>);</div></pre></td></tr></table></figure></p>\n<p>如果打算在其他函数中使用jQuery对象，那么可以把它们缓存到全局环境中。如下代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.$my = &#123;</div><div class=\"line\">    <span class=\"attr\">head</span> : $(<span class=\"string\">'head'</span>),</div><div class=\"line\">    <span class=\"attr\">light</span>: $(<span class=\"string\">'#light'</span>),</div><div class=\"line\">    <span class=\"attr\">light_button</span>: $(<span class=\"string\">\"#light_button\"</span>)</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dosomething</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//现在可以引用存储结构并操作它们</span></div><div class=\"line\">    <span class=\"keyword\">var</span> script = docuement.creatElement(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">    $my.head.append(script);</div><div class=\"line\">    <span class=\"comment\">// 当你在函数内部操作时，可以继续将查询存入全局对象中去</span></div><div class=\"line\">    $my.cool_results = $(<span class=\"string\">\"#some_ul li\"</span>);</div><div class=\"line\">    $my.other_results = $(<span class=\"string\">\"#some\"</span>);</div><div class=\"line\">    <span class=\"comment\">// 全局函数作为一个普通的jquery对象去使用</span></div><div class=\"line\">    $my.other_results.css(<span class=\"string\">\"border-color\"</span>,<span class=\"string\">\"red\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>记住，永远不要让相同的选择器在你的代码里出现多次。</p>\n<h3 id=\"三、事件代理\">三、事件代理</h3><p>每一个JavaScript事件（例如click、mouseover等）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时，这点会很好用。比如,我们要为一个表格绑定这样的行为：点击td后，把背景色设置为红色，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//bad</span></div><div class=\"line\">$(<span class=\"string\">\"#mytable td\"</span>).click(functuon()&#123;</div><div class=\"line\">   $(<span class=\"keyword\">this</span>).css(<span class=\"string\">'background'</span>,<span class=\"string\">'red'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>假如有100个td元素，在使用以上方式时，绑定了100个事件，这将带来很负面的性能影响。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//good</span></div><div class=\"line\">$(<span class=\"string\">\"#mytable\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> $clicked = $(e.target);<span class=\"comment\">//e.target 捕捉到触发的目标元素</span></div><div class=\"line\">    $clicked.css(<span class=\"string\">'background'</span>,<span class=\"string\">'red'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>在这种方式中，只为一个元素绑定了事件，明显优于之前那种。<br>在jQuery 1.7中，提供了新的方式on()来帮助我们将整个事件监听封装到一个便利的方法中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//good</span></div><div class=\"line\">$(<span class=\"string\">\"#mytable\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"string\">'td'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    $(<span class=\"keyword\">this</span>).css(<span class=\"string\">'background'</span>,<span class=\"string\">'red'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"四、将你的代码转换为jQuery插件\">四、将你的代码转换为jQuery插件</h3><p>如果每次都需要用一定的时间去开发类似的代码，那么可以考虑将代码变成插件。它能够使你的代码有更好的重用性，并且能够有效组织代码。创建插件的代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$</span>)</span>&#123;</div><div class=\"line\">    $.fn.pulgName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"comment\">//code</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)(jQuery)</div></pre></td></tr></table></figure></p>\n<h3 id=\"五、合理利用HTML的data属性\">五、合理利用HTML的data属性</h3><p>HTML5的data属性可以帮助我们插入数据，特别是前后端的数据交换。jQuery的data()方法可以自动得到数据。例子：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"d1\"</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"page\"</span> <span class=\"attr\">data-last-value</span>=<span class=\"string\">\"43\"</span> <span class=\"attr\">data-options</span>=<span class=\"string\">'&#123;\"name\":\"John\"&#125;'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>读取数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">\"#d1\"</span>).data(<span class=\"string\">\"role\"</span>);  <span class=\"comment\">//page</span></div><div class=\"line\">$(<span class=\"string\">\"#d1\"</span>).data(<span class=\"string\">\"last-value\"</span>);  <span class=\"comment\">//43</span></div><div class=\"line\">$(<span class=\"string\">\"#d1\"</span>).data(<span class=\"string\">\"options\"</span>).name;  <span class=\"comment\">//John</span></div></pre></td></tr></table></figure></p>\n<p><em>——总结来自《锋利的jQuery》</em></p>\n","excerpt":"<p>jQuery已经成为前端开发中重要的类库之一，也是前端开发er的一个利器，了解到如何正确使用jQuery达到最佳性能是一个很重要的事。下面从各个方面来总结一下jQuery性能优化技巧和注意事项。<br>","more":"</p>\n<h3 id=\"一、使用合适的选择器\">一、使用合适的选择器</h3><p><strong>$(‘#id’)</strong><br>使用id来定位DOM元素无疑是提高性能的最佳方式，因为这会直接调用本地方法<code>document.getElementById()</code>。<br>如果这样找不到所需要的元素，可以使用find()方法。<code>$(&quot;#content&quot;).find(&quot;div&quot;);</code>为了提高性能，建议从最近的id元素开始往下搜索。</p>\n<p><strong>$(‘p’),$(‘div’),$(‘input’)</strong><br>标签选择器也不错，因为jQuery是直接调用本地方法<code>document.getElementsByTagName()</code>。</p>\n<p><strong>$(‘.class’)</strong><br>对于比较新的浏览器，它支持本地方法<code>document.getElementsByClassName()</code>。但是对于ie8及以下版本浏览器，只能通过DOM搜索的方法来实现，这无疑会带来一些性能的影响。建议有选择地使用。</p>\n<p><strong>$(“[attribute=value]”)</strong><br>对于利用属性来定位DOM元素，本地javascript并没有方法直接实现，大多是使用DOM搜索的方式来达到效果。很多现代浏览器支持querySelectAll()方法，但是不同浏览器的性能还是有区别。总体来说，使用这种方式性能不是非常理想，所以为了获得更好的优化效果，建议尽量避免这种对性能有害的方式。</p>\n<p><strong>$(“:hidden”)</strong><br>和上面利用属性定位DOM元素一样，这种伪选择器也同样没有直接在本地javascript方法中实现，并且jQuery需要搜索每一个元素来定位这个选择器，这将对性能带来比较大的影响，所以建议尽量不要使用。如果非要使用，请先使用ID选择器定位父元素然后再使用该选择器，这样对性能优化有帮助。</p>\n<ul>\n<li><strong>尽量使用ID选择器</strong></li>\n<li><strong>尽量给选择器指定上下文</strong></li>\n</ul>\n<h3 id=\"二、缓存对象\">二、缓存对象</h3><p>其实这是javascript也需要注意的地方<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//bad</span></div><div class=\"line\">$(<span class=\"string\">\"#light\"</span>).bind(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);</div><div class=\"line\">$(<span class=\"string\">\"#light\"</span>).css(<span class=\"string\">'border'</span>,<span class=\"string\">\"1px solid red\"</span>);</div><div class=\"line\">$(<span class=\"string\">\"#light\"</span>).fadeIn(<span class=\"string\">\"slow\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//good</span></div><div class=\"line\"><span class=\"keyword\">var</span> light = $(<span class=\"string\">\"#light\"</span>);</div><div class=\"line\">light.bind(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;);</div><div class=\"line\">light.css(<span class=\"string\">'border'</span>,<span class=\"string\">\"1px solid red\"</span>);</div><div class=\"line\">light.fadeIn(<span class=\"string\">\"slow\"</span>);</div></pre></td></tr></table></figure></p>\n<p>本例中用链式方式将更加简洁，上面只是为了说明缓存变量的重要性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//链式</span></div><div class=\"line\"><span class=\"keyword\">var</span> light = $(<span class=\"string\">\"#light\"</span>);</div><div class=\"line\">light.bind(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;)</div><div class=\"line\">    .css(<span class=\"string\">'border'</span>,<span class=\"string\">\"1px solid red\"</span>)</div><div class=\"line\">    .fadeIn(<span class=\"string\">\"slow\"</span>);</div></pre></td></tr></table></figure></p>\n<p>如果打算在其他函数中使用jQuery对象，那么可以把它们缓存到全局环境中。如下代码所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.$my = &#123;</div><div class=\"line\">    <span class=\"attr\">head</span> : $(<span class=\"string\">'head'</span>),</div><div class=\"line\">    <span class=\"attr\">light</span>: $(<span class=\"string\">'#light'</span>),</div><div class=\"line\">    <span class=\"attr\">light_button</span>: $(<span class=\"string\">\"#light_button\"</span>)</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dosomething</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//现在可以引用存储结构并操作它们</span></div><div class=\"line\">    <span class=\"keyword\">var</span> script = docuement.creatElement(<span class=\"string\">\"script\"</span>);</div><div class=\"line\">    $my.head.append(script);</div><div class=\"line\">    <span class=\"comment\">// 当你在函数内部操作时，可以继续将查询存入全局对象中去</span></div><div class=\"line\">    $my.cool_results = $(<span class=\"string\">\"#some_ul li\"</span>);</div><div class=\"line\">    $my.other_results = $(<span class=\"string\">\"#some\"</span>);</div><div class=\"line\">    <span class=\"comment\">// 全局函数作为一个普通的jquery对象去使用</span></div><div class=\"line\">    $my.other_results.css(<span class=\"string\">\"border-color\"</span>,<span class=\"string\">\"red\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>记住，永远不要让相同的选择器在你的代码里出现多次。</p>\n<h3 id=\"三、事件代理\">三、事件代理</h3><p>每一个JavaScript事件（例如click、mouseover等）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时，这点会很好用。比如,我们要为一个表格绑定这样的行为：点击td后，把背景色设置为红色，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//bad</span></div><div class=\"line\">$(<span class=\"string\">\"#mytable td\"</span>).click(functuon()&#123;</div><div class=\"line\">   $(<span class=\"keyword\">this</span>).css(<span class=\"string\">'background'</span>,<span class=\"string\">'red'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>假如有100个td元素，在使用以上方式时，绑定了100个事件，这将带来很负面的性能影响。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//good</span></div><div class=\"line\">$(<span class=\"string\">\"#mytable\"</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> $clicked = $(e.target);<span class=\"comment\">//e.target 捕捉到触发的目标元素</span></div><div class=\"line\">    $clicked.css(<span class=\"string\">'background'</span>,<span class=\"string\">'red'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>在这种方式中，只为一个元素绑定了事件，明显优于之前那种。<br>在jQuery 1.7中，提供了新的方式on()来帮助我们将整个事件监听封装到一个便利的方法中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//good</span></div><div class=\"line\">$(<span class=\"string\">\"#mytable\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"string\">'td'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    $(<span class=\"keyword\">this</span>).css(<span class=\"string\">'background'</span>,<span class=\"string\">'red'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"四、将你的代码转换为jQuery插件\">四、将你的代码转换为jQuery插件</h3><p>如果每次都需要用一定的时间去开发类似的代码，那么可以考虑将代码变成插件。它能够使你的代码有更好的重用性，并且能够有效组织代码。创建插件的代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$</span>)</span>&#123;</div><div class=\"line\">    $.fn.pulgName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"comment\">//code</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)(jQuery)</div></pre></td></tr></table></figure></p>\n<h3 id=\"五、合理利用HTML的data属性\">五、合理利用HTML的data属性</h3><p>HTML5的data属性可以帮助我们插入数据，特别是前后端的数据交换。jQuery的data()方法可以自动得到数据。例子：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"d1\"</span> <span class=\"attr\">data-role</span>=<span class=\"string\">\"page\"</span> <span class=\"attr\">data-last-value</span>=<span class=\"string\">\"43\"</span> <span class=\"attr\">data-options</span>=<span class=\"string\">'&#123;\"name\":\"John\"&#125;'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>读取数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">\"#d1\"</span>).data(<span class=\"string\">\"role\"</span>);  <span class=\"comment\">//page</span></div><div class=\"line\">$(<span class=\"string\">\"#d1\"</span>).data(<span class=\"string\">\"last-value\"</span>);  <span class=\"comment\">//43</span></div><div class=\"line\">$(<span class=\"string\">\"#d1\"</span>).data(<span class=\"string\">\"options\"</span>).name;  <span class=\"comment\">//John</span></div></pre></td></tr></table></figure></p>\n<p><em>——总结来自《锋利的jQuery》</em></p>"},{"title":"函数防抖和节流","_content":"\n### 函数防抖\n我们经常会遇到这样的需求：需要我们监听用户的输入向后端发送请求，比如搜索推荐，我们会监听input框的change事件，但是如果用户每次按下键盘都发送请求，会发送很多请求、卡顿等。为了优化这种情况，我们就需要用到函数防抖。\n\n>函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。\n\n使用函数防抖后，假设我们input框的change事件，当输入完成后300ms我们才向服务端发送请求，如果在300ms内，用户又开始输入了，那我们就重新计时等待300ms。直到用户停止输入，300ms内都没有再次输入，我们就发出请求。这样就可以让用户真的输入完毕后才开始使用用户输入的信息，而不是在打每一个字母的时候。\n\n我们先看下underscore.js里相关函数的定义：\n\n```javascript\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n_.debounce = function(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n  var later = function() {\n    var last = _.now() - timestamp;\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n  return function() {\n    context = this;\n    args = arguments;\n    timestamp = _.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n    return result;\n  };\n};\n```\n参数function是需要进行函数防抖的函数；参数wait则是需要等待的时间，单位为毫秒；immediate参数如果为true，则debounce函数会在调用时立刻执行一次function，而不需要等到wait这个时间后，例如防止点击提交按钮时的多次点击就可以使用这个参数。\n\n可以从下面我写的例子里看到2者的区别，明显看出使用了防抖的明显避免了没必要的多次请求。\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/fuxowejolo/1/embed?js,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.41.6\"></script>\n\n### 函数节流\n还有一些需求，在滚动页面的时候监听滚动的位置做出相应的交互，比如本站文章页右侧的目录导航滚动。所以我们需要监听页面的滚动事件，在滚动事件监听的回调里执行你的方法。如果用户滚动很快，一秒内可能执行上百次，导致页面性能变得很慢。\n但是这次的情况跟上面的有所不同，我们不是要在每完成等待某个时间后去执行某函数，而是要每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。\n\n我们还是来看一下underscore.js里相关函数的定义：\n\n```javascript\n// Returns a function, that, when invoked, will only be triggered at most once\n// during a given window of time. Normally, the throttled function will run\n// as much as it can, without ever going more than once per `wait` duration;\n// but if you'd like to disable the execution on the leading edge, pass\n// `{leading: false}`. To disable execution on the trailing edge, ditto.\n\n_.throttle = function(func, wait, options) {\n  var context, args, result;\n  var timeout = null;\n  var previous = 0;\n  if (!options) options = {};\n  var later = function() {\n    previous = options.leading === false ? 0 : _.now();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n  return function() {\n    var now = _.now();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n};\n```\n参数function是需要进行函数节流的函数；参数wait则是函数执行的时间间隔，单位是毫秒。option有两个选项，throttle第一次调用时默认会立刻执行一次function，如果传入{leading: false}，则第一次调用时不执行function。{trailing: false}参数则表示禁止最后那一次延迟的调用。\n进行滚动2个DIV内部，可以看到函数节流的效果，明显看出，快速滚动，函数节流的情况下减少了多次回调的调用。\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/havuximowu/1/embed?js,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.41.6\"></script>\n\n","source":"_posts/debounce-and-throttle.md","raw":"title: 函数防抖和节流\ntags: web前端知识\n---\n\n### 函数防抖\n我们经常会遇到这样的需求：需要我们监听用户的输入向后端发送请求，比如搜索推荐，我们会监听input框的change事件，但是如果用户每次按下键盘都发送请求，会发送很多请求、卡顿等。为了优化这种情况，我们就需要用到函数防抖。\n\n>函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。\n\n使用函数防抖后，假设我们input框的change事件，当输入完成后300ms我们才向服务端发送请求，如果在300ms内，用户又开始输入了，那我们就重新计时等待300ms。直到用户停止输入，300ms内都没有再次输入，我们就发出请求。这样就可以让用户真的输入完毕后才开始使用用户输入的信息，而不是在打每一个字母的时候。\n\n我们先看下underscore.js里相关函数的定义：\n\n```javascript\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n_.debounce = function(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n  var later = function() {\n    var last = _.now() - timestamp;\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n  return function() {\n    context = this;\n    args = arguments;\n    timestamp = _.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n    return result;\n  };\n};\n```\n参数function是需要进行函数防抖的函数；参数wait则是需要等待的时间，单位为毫秒；immediate参数如果为true，则debounce函数会在调用时立刻执行一次function，而不需要等到wait这个时间后，例如防止点击提交按钮时的多次点击就可以使用这个参数。\n\n可以从下面我写的例子里看到2者的区别，明显看出使用了防抖的明显避免了没必要的多次请求。\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/fuxowejolo/1/embed?js,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.41.6\"></script>\n\n### 函数节流\n还有一些需求，在滚动页面的时候监听滚动的位置做出相应的交互，比如本站文章页右侧的目录导航滚动。所以我们需要监听页面的滚动事件，在滚动事件监听的回调里执行你的方法。如果用户滚动很快，一秒内可能执行上百次，导致页面性能变得很慢。\n但是这次的情况跟上面的有所不同，我们不是要在每完成等待某个时间后去执行某函数，而是要每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。\n\n我们还是来看一下underscore.js里相关函数的定义：\n\n```javascript\n// Returns a function, that, when invoked, will only be triggered at most once\n// during a given window of time. Normally, the throttled function will run\n// as much as it can, without ever going more than once per `wait` duration;\n// but if you'd like to disable the execution on the leading edge, pass\n// `{leading: false}`. To disable execution on the trailing edge, ditto.\n\n_.throttle = function(func, wait, options) {\n  var context, args, result;\n  var timeout = null;\n  var previous = 0;\n  if (!options) options = {};\n  var later = function() {\n    previous = options.leading === false ? 0 : _.now();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n  return function() {\n    var now = _.now();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n};\n```\n参数function是需要进行函数节流的函数；参数wait则是函数执行的时间间隔，单位是毫秒。option有两个选项，throttle第一次调用时默认会立刻执行一次function，如果传入{leading: false}，则第一次调用时不执行function。{trailing: false}参数则表示禁止最后那一次延迟的调用。\n进行滚动2个DIV内部，可以看到函数节流的效果，明显看出，快速滚动，函数节流的情况下减少了多次回调的调用。\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/havuximowu/1/embed?js,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.41.6\"></script>\n\n","slug":"debounce-and-throttle","published":1,"date":"2017-03-07T08:10:49.000Z","updated":"2017-03-10T03:14:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ewn000aer2zmk5enu0f","content":"<h3 id=\"函数防抖\">函数防抖</h3><p>我们经常会遇到这样的需求：需要我们监听用户的输入向后端发送请求，比如搜索推荐，我们会监听input框的change事件，但是如果用户每次按下键盘都发送请求，会发送很多请求、卡顿等。为了优化这种情况，我们就需要用到函数防抖。</p>\n<blockquote>\n<p>函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。</p>\n</blockquote>\n<p>使用函数防抖后，假设我们input框的change事件，当输入完成后300ms我们才向服务端发送请求，如果在300ms内，用户又开始输入了，那我们就重新计时等待300ms。直到用户停止输入，300ms内都没有再次输入，我们就发出请求。这样就可以让用户真的输入完毕后才开始使用用户输入的信息，而不是在打每一个字母的时候。</p>\n<p>我们先看下underscore.js里相关函数的定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Returns a function, that, as long as it continues to be invoked, will not</span></div><div class=\"line\"><span class=\"comment\">// be triggered. The function will be called after it stops being called for</span></div><div class=\"line\"><span class=\"comment\">// N milliseconds. If `immediate` is passed, trigger the function on the</span></div><div class=\"line\"><span class=\"comment\">// leading edge, instead of the trailing.</span></div><div class=\"line\">_.debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> timeout, args, context, timestamp, result;</div><div class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> last = _.now() - timestamp;</div><div class=\"line\">    <span class=\"keyword\">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      timeout = setTimeout(later, wait - last);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      timeout = <span class=\"literal\">null</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!immediate) &#123;</div><div class=\"line\">        result = func.apply(context, args);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    context = <span class=\"keyword\">this</span>;</div><div class=\"line\">    args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">    timestamp = _.now();</div><div class=\"line\">    <span class=\"keyword\">var</span> callNow = immediate &amp;&amp; !timeout;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!timeout) timeout = setTimeout(later, wait);</div><div class=\"line\">    <span class=\"keyword\">if</span> (callNow) &#123;</div><div class=\"line\">      result = func.apply(context, args);</div><div class=\"line\">      context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>参数function是需要进行函数防抖的函数；参数wait则是需要等待的时间，单位为毫秒；immediate参数如果为true，则debounce函数会在调用时立刻执行一次function，而不需要等到wait这个时间后，例如防止点击提交按钮时的多次点击就可以使用这个参数。</p>\n<p>可以从下面我写的例子里看到2者的区别，明显看出使用了防抖的明显避免了没必要的多次请求。<br><a class=\"jsbin-embed\" href=\"http://jsbin.com/fuxowejolo/1/embed?js,output\" target=\"_blank\" rel=\"external\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.41.6\"></script></p>\n<h3 id=\"函数节流\">函数节流</h3><p>还有一些需求，在滚动页面的时候监听滚动的位置做出相应的交互，比如本站文章页右侧的目录导航滚动。所以我们需要监听页面的滚动事件，在滚动事件监听的回调里执行你的方法。如果用户滚动很快，一秒内可能执行上百次，导致页面性能变得很慢。<br>但是这次的情况跟上面的有所不同，我们不是要在每完成等待某个时间后去执行某函数，而是要每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。</p>\n<p>我们还是来看一下underscore.js里相关函数的定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Returns a function, that, when invoked, will only be triggered at most once</span></div><div class=\"line\"><span class=\"comment\">// during a given window of time. Normally, the throttled function will run</span></div><div class=\"line\"><span class=\"comment\">// as much as it can, without ever going more than once per `wait` duration;</span></div><div class=\"line\"><span class=\"comment\">// but if you'd like to disable the execution on the leading edge, pass</span></div><div class=\"line\"><span class=\"comment\">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></div><div class=\"line\"></div><div class=\"line\">_.throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> context, args, result;</div><div class=\"line\">  <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    previous = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : _.now();</div><div class=\"line\">    timeout = <span class=\"literal\">null</span>;</div><div class=\"line\">    result = func.apply(context, args);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> now = _.now();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!previous &amp;&amp; options.leading === <span class=\"literal\">false</span>) previous = now;</div><div class=\"line\">    <span class=\"keyword\">var</span> remaining = wait - (now - previous);</div><div class=\"line\">    context = <span class=\"keyword\">this</span>;</div><div class=\"line\">    args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (timeout) &#123;</div><div class=\"line\">        clearTimeout(timeout);</div><div class=\"line\">        timeout = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      previous = now;</div><div class=\"line\">      result = func.apply(context, args);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.trailing !== <span class=\"literal\">false</span>) &#123;</div><div class=\"line\">      timeout = setTimeout(later, remaining);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>参数function是需要进行函数节流的函数；参数wait则是函数执行的时间间隔，单位是毫秒。option有两个选项，throttle第一次调用时默认会立刻执行一次function，如果传入{leading: false}，则第一次调用时不执行function。{trailing: false}参数则表示禁止最后那一次延迟的调用。<br>进行滚动2个DIV内部，可以看到函数节流的效果，明显看出，快速滚动，函数节流的情况下减少了多次回调的调用。<br><a class=\"jsbin-embed\" href=\"http://jsbin.com/havuximowu/1/embed?js,output\" target=\"_blank\" rel=\"external\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.41.6\"></script></p>\n","excerpt":"","more":"<h3 id=\"函数防抖\">函数防抖</h3><p>我们经常会遇到这样的需求：需要我们监听用户的输入向后端发送请求，比如搜索推荐，我们会监听input框的change事件，但是如果用户每次按下键盘都发送请求，会发送很多请求、卡顿等。为了优化这种情况，我们就需要用到函数防抖。</p>\n<blockquote>\n<p>函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。</p>\n</blockquote>\n<p>使用函数防抖后，假设我们input框的change事件，当输入完成后300ms我们才向服务端发送请求，如果在300ms内，用户又开始输入了，那我们就重新计时等待300ms。直到用户停止输入，300ms内都没有再次输入，我们就发出请求。这样就可以让用户真的输入完毕后才开始使用用户输入的信息，而不是在打每一个字母的时候。</p>\n<p>我们先看下underscore.js里相关函数的定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Returns a function, that, as long as it continues to be invoked, will not</span></div><div class=\"line\"><span class=\"comment\">// be triggered. The function will be called after it stops being called for</span></div><div class=\"line\"><span class=\"comment\">// N milliseconds. If `immediate` is passed, trigger the function on the</span></div><div class=\"line\"><span class=\"comment\">// leading edge, instead of the trailing.</span></div><div class=\"line\">_.debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> timeout, args, context, timestamp, result;</div><div class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> last = _.now() - timestamp;</div><div class=\"line\">    <span class=\"keyword\">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      timeout = setTimeout(later, wait - last);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      timeout = <span class=\"literal\">null</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!immediate) &#123;</div><div class=\"line\">        result = func.apply(context, args);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    context = <span class=\"keyword\">this</span>;</div><div class=\"line\">    args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">    timestamp = _.now();</div><div class=\"line\">    <span class=\"keyword\">var</span> callNow = immediate &amp;&amp; !timeout;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!timeout) timeout = setTimeout(later, wait);</div><div class=\"line\">    <span class=\"keyword\">if</span> (callNow) &#123;</div><div class=\"line\">      result = func.apply(context, args);</div><div class=\"line\">      context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>参数function是需要进行函数防抖的函数；参数wait则是需要等待的时间，单位为毫秒；immediate参数如果为true，则debounce函数会在调用时立刻执行一次function，而不需要等到wait这个时间后，例如防止点击提交按钮时的多次点击就可以使用这个参数。</p>\n<p>可以从下面我写的例子里看到2者的区别，明显看出使用了防抖的明显避免了没必要的多次请求。<br><a class=\"jsbin-embed\" href=\"http://jsbin.com/fuxowejolo/1/embed?js,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.41.6\"></script></p>\n<h3 id=\"函数节流\">函数节流</h3><p>还有一些需求，在滚动页面的时候监听滚动的位置做出相应的交互，比如本站文章页右侧的目录导航滚动。所以我们需要监听页面的滚动事件，在滚动事件监听的回调里执行你的方法。如果用户滚动很快，一秒内可能执行上百次，导致页面性能变得很慢。<br>但是这次的情况跟上面的有所不同，我们不是要在每完成等待某个时间后去执行某函数，而是要每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。</p>\n<p>我们还是来看一下underscore.js里相关函数的定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Returns a function, that, when invoked, will only be triggered at most once</span></div><div class=\"line\"><span class=\"comment\">// during a given window of time. Normally, the throttled function will run</span></div><div class=\"line\"><span class=\"comment\">// as much as it can, without ever going more than once per `wait` duration;</span></div><div class=\"line\"><span class=\"comment\">// but if you'd like to disable the execution on the leading edge, pass</span></div><div class=\"line\"><span class=\"comment\">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></div><div class=\"line\"></div><div class=\"line\">_.throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, options</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> context, args, result;</div><div class=\"line\">  <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    previous = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : _.now();</div><div class=\"line\">    timeout = <span class=\"literal\">null</span>;</div><div class=\"line\">    result = func.apply(context, args);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> now = _.now();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!previous &amp;&amp; options.leading === <span class=\"literal\">false</span>) previous = now;</div><div class=\"line\">    <span class=\"keyword\">var</span> remaining = wait - (now - previous);</div><div class=\"line\">    context = <span class=\"keyword\">this</span>;</div><div class=\"line\">    args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (timeout) &#123;</div><div class=\"line\">        clearTimeout(timeout);</div><div class=\"line\">        timeout = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      previous = now;</div><div class=\"line\">      result = func.apply(context, args);</div><div class=\"line\">      <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.trailing !== <span class=\"literal\">false</span>) &#123;</div><div class=\"line\">      timeout = setTimeout(later, remaining);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>参数function是需要进行函数节流的函数；参数wait则是函数执行的时间间隔，单位是毫秒。option有两个选项，throttle第一次调用时默认会立刻执行一次function，如果传入{leading: false}，则第一次调用时不执行function。{trailing: false}参数则表示禁止最后那一次延迟的调用。<br>进行滚动2个DIV内部，可以看到函数节流的效果，明显看出，快速滚动，函数节流的情况下减少了多次回调的调用。<br><a class=\"jsbin-embed\" href=\"http://jsbin.com/havuximowu/1/embed?js,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.41.6\"></script></p>\n"},{"title":"单元测试 & mocha框架","date":"2017-01-06T02:11:30.000Z","_content":"## 一、什么是单元测试\n\n>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。\n\n单元测试在前端领域并不被重视，前端程序员也没有写单元测试的习惯。但是，随着前端技术的发展，随着node的发展，越来越多“非UI”的前端代码出现，前端开发们也需要了解掌握单元测试知识。\n单元测试是保证代码质量的重要环节之一，特别是这些代码是会提供给其他人使用的时候，比如node插件，grunt插件等等\n单元测试的作用有许多，下面列举一些：\n- 保证代码可用\n- 另一种纬度的文档\n- 方便迭代回归\n- 驱动开发\n\n### TDD与BDD\n__TDD__,全称是Test Driver Development，测试驱动开发。先编写测试用例（没有代码之前这些测试用例一个也通不过），然后再写代码让这些测试用例通过。更进一层的讲就是：编写足够的测试用例使测试失败，编写足够的代码是测试成功。我们编码的目的更加明确的。\n__TDD的优点__：\n1. 站在用户的角度思考，从用户的角度尽可能地想会进行的操作，而不是从一个开发的角度。\n2. 先编写测试用例，再进行开发，为开发进行指导性的参考，防止遗漏某些功能。\n3. 首先由了一套完整的测试用例，便可以让代码重构更安全，因为重构只是改变内部结构，不应改变外部功能，而TDD是关注外部接口，所以在重构时，只要保证测试用例通过即可放心更改内部代码。\n4. 如果更改了某部分代码使测试用例不通过了，我们可以马上定位到刚才写的代码，修改错误。\n\nTDD把工作量前置，前期的准备工作量较大，不过后期就会很轻松。\n关于TDD的介绍，可以看看这篇文章：[学习TDD：TDD的好处](http://blog.csdn.net/m13666368773/article/details/7006912)\n\n__BDD__,全称是Behavior Driven Development，行为驱动开发。相比于TDD，BDD更加侧重设计，其要求在设计测试用例的时候对系统进行定义，倡导使用通用的语言将系统的行为描述出来，将系统设计和测试用例结合起来，从而以此为驱动进行开发工作。\nBDD的通用语言是一种近乎自然语言的描述软件的形式。传统的开发模式中，开发人员很难从业务需求考虑问题，基于这种通用语言形式可以尽可能避免了因为理解需求不充分而带来的不必要的工作量。\nBDD描述的行为就像一个个的故事(Story)，需求方、开发者、测试人员一起合作，分析软件的需求，然后将这些需求写成一个个的故事。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。\n\n## 二、mocha\n[Mocha](https://mochajs.org/)是具有丰富特性的 JavaScript 测试框架，可以运行在 Node.js 和浏览器中，使得异步测试更简单更有趣。Mocha 可以持续运行测试，支持灵活又准确的报告，当映射到未捕获异常时转到正确的测试示例。\n它支持TDD/BDD等多种流行的接口，也接受多种Assertions（断言），如should.js/expect/chai/better-assert（断言框架）等，通过这些即可构建各种风格的测试用例。\n\n### 1. 安装\n要开始我们的单元测试之路，首先要安装mocha。\n```javascript\nnpm install mocha --save\n```\n为了方便，我们选择了断言库，这里选择的是[chai](http://chaijs.com/)。chai是一个断言库，node本身也有个断言模块，但是功能比较弱，语法也比较贫乏。 \nchai提供了三种断言风格来分别适用于BDD和TDD。__expect/should__ API 对应BDD风格__，__Assert__ API 对应TDD风格。\n```javascript\nnpm install chai --save\n```\n### 2. 起步\n修改package.json 配置：\n```javascript\n .....\n\"scripts\": {\n    \"test\": \"mocha\"\n  },\n  .....\n```\nmocha默认执行test文件夹下的文件，所以一般测试文件都放在/test文件夹下面。并且命名为xxx.test.js\n/api/add.js\n```javascript\nfunction add(x,y){\n    return x + y;\n}\nmodule.exports = add;\n```\n/api/checkUser.js\n```javascript\nfunction checkUser(userName){\n    return new Promise(function(resolve,reject){\n        setTimeout(function(){\n            if(userName == 'cky'){\n                resolve({data:true});\n            }else{\n                resolve({data:false});\n            }\n        },300);\n    });\n}\nmodule.exports = checkUser;\n```\n/test/add.test.js\n\n```javascript\nvar mocha  = require('mocha');\nvar chai   = require(\"chai\");\nvar expect = chai.expect;\nvar add    = require('../api/add');\ndescribe('api文件测试', function() {\n  describe('add()函数测试', function() {\n    it('1+2应该等于3', function() {\n      expect(add(1,2)).to.be.equal(3);\n    });\n  });\n});\n```\n/test/userCheck.test.js\n\n```javascript\nvar mocha     = require('mocha');\nvar chai      = require(\"chai\");\nvar expect    = chai.expect;\nvar checkUser = require('../api/checkUser');\ndescribe('api文件测试', function() {\n  describe('checkUser()异步函数测试', function() {\n    it('cky返回true', function() {\n      return checkUser('cky').then(function(rs){\n        expect(rs.data).to.be.ok;\n      });\n    });\n    it('xxx返回false', function() {\n      return checkUser('xxx').then(function(rs){\n        expect(rs.data).to.be.not.ok;\n      });\n    });\n  });\n});\n```\n\n执行结果：\n```powershell\n▶ npm test\n> mochatest@0.0.1 test /Users/chenkeyi/cky/myDemo/test\n> mocha\n  api文件测试\n    add()函数测试\n      ✓ 1+1应该等于2\n    checkUser()异步函数测试\n      ✓ cky返回true (304ms)\n      ✓ xxx返回false (303ms)\n  3 passing (627ms)\n```\n\n上面这段代码，就是测试脚本，它可以独立执行。测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。\ndescribe块称为\"测试套件\"（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（\"api文件测试\"），第二个参数是一个实际执行的函数。\nit块称为\"测试用例\"（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（\"1+2应该等于3\"），第二个参数是一个实际执行的函数。\n\n从`checkUser`方法测试也可以看出，是支持promise风格写法的。\n\n### 3. 断言\n\n所谓\"断言\"，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。所有的测试用例（it块）都应该含有一句或多句的断言。它是编写测试用例的关键。断言功能由断言库来实现，Mocha本身不带断言库，所以必须先引入断言库。\n\n上面也提到了断言库chai，其中有三个API expect/should/assert，\n详细的文档可以查看[chai](http://chaijs.com/api/)。\n\n`expect(rs.data).to.be.ok;`这句话，就是一个断言。\n\n要使用断言，首先要\n```javascript\nvar chai      = require(\"chai\");\nvar expect    = chai.expect;\n```\n确认引入断言库，这里介绍比较常用的expect风格api。\n我们可以这样写：`expect(4+5).equal(9);`\nChai添加了下面的链式getter，它们不会做任何事，但是你可以将它们添加进入断言中是的句子变得啰嗦但是增加了易读性。\n- to\n- be\n- been\n- is\n- that\n- and\n- have\n- with\n- at\n- of\n- same\n- a\n- an\n\n重写上面的方法：\n`expect(4+5).to.equal(5)`\n下面是一些使用断言例子\n\n```javascript\n// 相等或不相等\nexpect(4 + 5).to.be.equal(9);\nexpect(4 + 5).to.be.not.equal(10);\nexpect(foo).to.be.deep.equal({ bar: 'baz' });\n// 布尔值为true\nexpect('everthing').to.be.ok;\nexpect(false).to.not.be.ok;\n// typeof\nexpect('test').to.be.a('string');\nexpect({ foo: 'bar' }).to.be.an('object');\nexpect(foo).to.be.an.instanceof(Foo);\n// include\nexpect([1,2,3]).to.include(2);\nexpect('foobar').to.contain('foo');\nexpect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\n// empty\nexpect([]).to.be.empty;\nexpect('').to.be.empty;\nexpect({}).to.be.empty;\n// match\nexpect('foobar').to.match(/^foo/);\n```\n### 4. 命令行参数\n`--recursive` 执行/test文件夹下的所有测试文件\n`--reporter,-R` 参数用来指定测试报告的格式，默认是spec格式\n`--watch,-w` 参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。\n`--bail,-b` 参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例。这对持续集成很有用。\n`--grep,-g` 参数用于搜索测试用例的名称（即it块的第一个参数），然后只执行匹配的测试用例。\n`--invert,-i` 参数表示只运行不符合条件的测试脚本，必须与--grep参数配合使用。\n\n这些命令行参数可以写在mocha.opts文件中配置，这样命令行输入`mocha`一个命令就可以了\n```javascript\n//mocha.opts\n--reporter tap\n--recursive\n--growl\n```\n\n如果不是在test文件夹下存放测试文件，可以在mocha.opts配置文件中配置\n```javascript\n//指定运行server-tests文件夹下的文件\nserver-tests\n--recursive\n```\n\n### 5. 异步测试\nMocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错。对于涉及异步操作的测试用例，这个时间往往是不够的，需要用-t或--timeout参数指定超时门槛。\n```javascript\n//timeout.js\nvar mocha     = require('mocha');\nvar chai      = require(\"chai\");\nvar expect    = chai.expect;\nvar checkUser = require('../api/checkUser');\ndescribe('api文件测试', function() {\n  describe('timeout超时测试', function() {\n    it('测试应该4000毫秒后结束', function(done) {\n      var x = true;\n      var f = function() {\n        x = false;\n        expect(x).to.be.not.ok;\n        done(); // 通知Mocha测试结束\n      };\n      setTimeout(f, 4000);\n    });\n  });\n});\n```\n在不设置 -t时，执行报错\n```javascript\n1) api文件测试 timeout超时测试 测试应该4000毫秒后结束:\n     Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.\n```\n设置超时5000m`mocha -t 5000`后正常执行\n\n另外，上面的测试用例里面，有一个done函数。it块执行的时候，传入一个done参数，当测试结束的时候，必须显式调用这个函数，告诉Mocha测试结束了。否则，Mocha就无法知道，测试是否结束，会一直等到超时报错。\n\n另外，Mocha内置对Promise的支持，允许直接返回Promise，等到它的状态改变，再执行断言，而不用显式调用done，见/test/userCheck.test.js。\n\n### 6. 测试用例的钩子\n\nMocha在describe块之中，提供测试用例的四个钩子：`before()`、`after()`、`beforeEach()`和`afterEach()`。它们会在指定时间执行。\n```javascript\ndescribe('hooks', function() {\n  before(function() {\n    // 在本区块的所有测试用例之前执行\n  });\n  after(function() {\n    // 在本区块的所有测试用例之后执行\n  });\n  beforeEach(function() {\n    // 在本区块的每个测试用例之前执行\n  });\n  afterEach(function() {\n    // 在本区块的每个测试用例之后执行\n  });\n  // test cases\n});\n```\n\n\n\n## 三、参考文档 \n- [测试框架 Mocha 实例教程](http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)\n- [单元测试 & mocha 简述](http://imweb.io/topic/5634c91109e01a534b461eaa?utm_source=tuicool&utm_medium=referral)\n- [学习TDD：TDD的好处](http://blog.csdn.net/m13666368773/article/details/7006912)","source":"_posts/mocha.md","raw":"title: 单元测试 & mocha框架\ndate: 2016-01-06 12：08\ntags: \n- node.js学习笔记 \n- web前端知识\n---\n## 一、什么是单元测试\n\n>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。\n\n单元测试在前端领域并不被重视，前端程序员也没有写单元测试的习惯。但是，随着前端技术的发展，随着node的发展，越来越多“非UI”的前端代码出现，前端开发们也需要了解掌握单元测试知识。\n单元测试是保证代码质量的重要环节之一，特别是这些代码是会提供给其他人使用的时候，比如node插件，grunt插件等等\n单元测试的作用有许多，下面列举一些：\n- 保证代码可用\n- 另一种纬度的文档\n- 方便迭代回归\n- 驱动开发\n\n### TDD与BDD\n__TDD__,全称是Test Driver Development，测试驱动开发。先编写测试用例（没有代码之前这些测试用例一个也通不过），然后再写代码让这些测试用例通过。更进一层的讲就是：编写足够的测试用例使测试失败，编写足够的代码是测试成功。我们编码的目的更加明确的。\n__TDD的优点__：\n1. 站在用户的角度思考，从用户的角度尽可能地想会进行的操作，而不是从一个开发的角度。\n2. 先编写测试用例，再进行开发，为开发进行指导性的参考，防止遗漏某些功能。\n3. 首先由了一套完整的测试用例，便可以让代码重构更安全，因为重构只是改变内部结构，不应改变外部功能，而TDD是关注外部接口，所以在重构时，只要保证测试用例通过即可放心更改内部代码。\n4. 如果更改了某部分代码使测试用例不通过了，我们可以马上定位到刚才写的代码，修改错误。\n\nTDD把工作量前置，前期的准备工作量较大，不过后期就会很轻松。\n关于TDD的介绍，可以看看这篇文章：[学习TDD：TDD的好处](http://blog.csdn.net/m13666368773/article/details/7006912)\n\n__BDD__,全称是Behavior Driven Development，行为驱动开发。相比于TDD，BDD更加侧重设计，其要求在设计测试用例的时候对系统进行定义，倡导使用通用的语言将系统的行为描述出来，将系统设计和测试用例结合起来，从而以此为驱动进行开发工作。\nBDD的通用语言是一种近乎自然语言的描述软件的形式。传统的开发模式中，开发人员很难从业务需求考虑问题，基于这种通用语言形式可以尽可能避免了因为理解需求不充分而带来的不必要的工作量。\nBDD描述的行为就像一个个的故事(Story)，需求方、开发者、测试人员一起合作，分析软件的需求，然后将这些需求写成一个个的故事。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。\n\n## 二、mocha\n[Mocha](https://mochajs.org/)是具有丰富特性的 JavaScript 测试框架，可以运行在 Node.js 和浏览器中，使得异步测试更简单更有趣。Mocha 可以持续运行测试，支持灵活又准确的报告，当映射到未捕获异常时转到正确的测试示例。\n它支持TDD/BDD等多种流行的接口，也接受多种Assertions（断言），如should.js/expect/chai/better-assert（断言框架）等，通过这些即可构建各种风格的测试用例。\n\n### 1. 安装\n要开始我们的单元测试之路，首先要安装mocha。\n```javascript\nnpm install mocha --save\n```\n为了方便，我们选择了断言库，这里选择的是[chai](http://chaijs.com/)。chai是一个断言库，node本身也有个断言模块，但是功能比较弱，语法也比较贫乏。 \nchai提供了三种断言风格来分别适用于BDD和TDD。__expect/should__ API 对应BDD风格__，__Assert__ API 对应TDD风格。\n```javascript\nnpm install chai --save\n```\n### 2. 起步\n修改package.json 配置：\n```javascript\n .....\n\"scripts\": {\n    \"test\": \"mocha\"\n  },\n  .....\n```\nmocha默认执行test文件夹下的文件，所以一般测试文件都放在/test文件夹下面。并且命名为xxx.test.js\n/api/add.js\n```javascript\nfunction add(x,y){\n    return x + y;\n}\nmodule.exports = add;\n```\n/api/checkUser.js\n```javascript\nfunction checkUser(userName){\n    return new Promise(function(resolve,reject){\n        setTimeout(function(){\n            if(userName == 'cky'){\n                resolve({data:true});\n            }else{\n                resolve({data:false});\n            }\n        },300);\n    });\n}\nmodule.exports = checkUser;\n```\n/test/add.test.js\n\n```javascript\nvar mocha  = require('mocha');\nvar chai   = require(\"chai\");\nvar expect = chai.expect;\nvar add    = require('../api/add');\ndescribe('api文件测试', function() {\n  describe('add()函数测试', function() {\n    it('1+2应该等于3', function() {\n      expect(add(1,2)).to.be.equal(3);\n    });\n  });\n});\n```\n/test/userCheck.test.js\n\n```javascript\nvar mocha     = require('mocha');\nvar chai      = require(\"chai\");\nvar expect    = chai.expect;\nvar checkUser = require('../api/checkUser');\ndescribe('api文件测试', function() {\n  describe('checkUser()异步函数测试', function() {\n    it('cky返回true', function() {\n      return checkUser('cky').then(function(rs){\n        expect(rs.data).to.be.ok;\n      });\n    });\n    it('xxx返回false', function() {\n      return checkUser('xxx').then(function(rs){\n        expect(rs.data).to.be.not.ok;\n      });\n    });\n  });\n});\n```\n\n执行结果：\n```powershell\n▶ npm test\n> mochatest@0.0.1 test /Users/chenkeyi/cky/myDemo/test\n> mocha\n  api文件测试\n    add()函数测试\n      ✓ 1+1应该等于2\n    checkUser()异步函数测试\n      ✓ cky返回true (304ms)\n      ✓ xxx返回false (303ms)\n  3 passing (627ms)\n```\n\n上面这段代码，就是测试脚本，它可以独立执行。测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。\ndescribe块称为\"测试套件\"（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（\"api文件测试\"），第二个参数是一个实际执行的函数。\nit块称为\"测试用例\"（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（\"1+2应该等于3\"），第二个参数是一个实际执行的函数。\n\n从`checkUser`方法测试也可以看出，是支持promise风格写法的。\n\n### 3. 断言\n\n所谓\"断言\"，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。所有的测试用例（it块）都应该含有一句或多句的断言。它是编写测试用例的关键。断言功能由断言库来实现，Mocha本身不带断言库，所以必须先引入断言库。\n\n上面也提到了断言库chai，其中有三个API expect/should/assert，\n详细的文档可以查看[chai](http://chaijs.com/api/)。\n\n`expect(rs.data).to.be.ok;`这句话，就是一个断言。\n\n要使用断言，首先要\n```javascript\nvar chai      = require(\"chai\");\nvar expect    = chai.expect;\n```\n确认引入断言库，这里介绍比较常用的expect风格api。\n我们可以这样写：`expect(4+5).equal(9);`\nChai添加了下面的链式getter，它们不会做任何事，但是你可以将它们添加进入断言中是的句子变得啰嗦但是增加了易读性。\n- to\n- be\n- been\n- is\n- that\n- and\n- have\n- with\n- at\n- of\n- same\n- a\n- an\n\n重写上面的方法：\n`expect(4+5).to.equal(5)`\n下面是一些使用断言例子\n\n```javascript\n// 相等或不相等\nexpect(4 + 5).to.be.equal(9);\nexpect(4 + 5).to.be.not.equal(10);\nexpect(foo).to.be.deep.equal({ bar: 'baz' });\n// 布尔值为true\nexpect('everthing').to.be.ok;\nexpect(false).to.not.be.ok;\n// typeof\nexpect('test').to.be.a('string');\nexpect({ foo: 'bar' }).to.be.an('object');\nexpect(foo).to.be.an.instanceof(Foo);\n// include\nexpect([1,2,3]).to.include(2);\nexpect('foobar').to.contain('foo');\nexpect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\n// empty\nexpect([]).to.be.empty;\nexpect('').to.be.empty;\nexpect({}).to.be.empty;\n// match\nexpect('foobar').to.match(/^foo/);\n```\n### 4. 命令行参数\n`--recursive` 执行/test文件夹下的所有测试文件\n`--reporter,-R` 参数用来指定测试报告的格式，默认是spec格式\n`--watch,-w` 参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。\n`--bail,-b` 参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例。这对持续集成很有用。\n`--grep,-g` 参数用于搜索测试用例的名称（即it块的第一个参数），然后只执行匹配的测试用例。\n`--invert,-i` 参数表示只运行不符合条件的测试脚本，必须与--grep参数配合使用。\n\n这些命令行参数可以写在mocha.opts文件中配置，这样命令行输入`mocha`一个命令就可以了\n```javascript\n//mocha.opts\n--reporter tap\n--recursive\n--growl\n```\n\n如果不是在test文件夹下存放测试文件，可以在mocha.opts配置文件中配置\n```javascript\n//指定运行server-tests文件夹下的文件\nserver-tests\n--recursive\n```\n\n### 5. 异步测试\nMocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错。对于涉及异步操作的测试用例，这个时间往往是不够的，需要用-t或--timeout参数指定超时门槛。\n```javascript\n//timeout.js\nvar mocha     = require('mocha');\nvar chai      = require(\"chai\");\nvar expect    = chai.expect;\nvar checkUser = require('../api/checkUser');\ndescribe('api文件测试', function() {\n  describe('timeout超时测试', function() {\n    it('测试应该4000毫秒后结束', function(done) {\n      var x = true;\n      var f = function() {\n        x = false;\n        expect(x).to.be.not.ok;\n        done(); // 通知Mocha测试结束\n      };\n      setTimeout(f, 4000);\n    });\n  });\n});\n```\n在不设置 -t时，执行报错\n```javascript\n1) api文件测试 timeout超时测试 测试应该4000毫秒后结束:\n     Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.\n```\n设置超时5000m`mocha -t 5000`后正常执行\n\n另外，上面的测试用例里面，有一个done函数。it块执行的时候，传入一个done参数，当测试结束的时候，必须显式调用这个函数，告诉Mocha测试结束了。否则，Mocha就无法知道，测试是否结束，会一直等到超时报错。\n\n另外，Mocha内置对Promise的支持，允许直接返回Promise，等到它的状态改变，再执行断言，而不用显式调用done，见/test/userCheck.test.js。\n\n### 6. 测试用例的钩子\n\nMocha在describe块之中，提供测试用例的四个钩子：`before()`、`after()`、`beforeEach()`和`afterEach()`。它们会在指定时间执行。\n```javascript\ndescribe('hooks', function() {\n  before(function() {\n    // 在本区块的所有测试用例之前执行\n  });\n  after(function() {\n    // 在本区块的所有测试用例之后执行\n  });\n  beforeEach(function() {\n    // 在本区块的每个测试用例之前执行\n  });\n  afterEach(function() {\n    // 在本区块的每个测试用例之后执行\n  });\n  // test cases\n});\n```\n\n\n\n## 三、参考文档 \n- [测试框架 Mocha 实例教程](http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)\n- [单元测试 & mocha 简述](http://imweb.io/topic/5634c91109e01a534b461eaa?utm_source=tuicool&utm_medium=referral)\n- [学习TDD：TDD的好处](http://blog.csdn.net/m13666368773/article/details/7006912)","slug":"mocha","published":1,"updated":"2017-01-11T14:08:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ewp000ber2zfeolf5rt","content":"<h2 id=\"一、什么是单元测试\">一、什么是单元测试</h2><blockquote>\n<p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p>\n</blockquote>\n<p>单元测试在前端领域并不被重视，前端程序员也没有写单元测试的习惯。但是，随着前端技术的发展，随着node的发展，越来越多“非UI”的前端代码出现，前端开发们也需要了解掌握单元测试知识。<br>单元测试是保证代码质量的重要环节之一，特别是这些代码是会提供给其他人使用的时候，比如node插件，grunt插件等等<br>单元测试的作用有许多，下面列举一些：</p>\n<ul>\n<li>保证代码可用</li>\n<li>另一种纬度的文档</li>\n<li>方便迭代回归</li>\n<li>驱动开发</li>\n</ul>\n<h3 id=\"TDD与BDD\">TDD与BDD</h3><p><strong>TDD</strong>,全称是Test Driver Development，测试驱动开发。先编写测试用例（没有代码之前这些测试用例一个也通不过），然后再写代码让这些测试用例通过。更进一层的讲就是：编写足够的测试用例使测试失败，编写足够的代码是测试成功。我们编码的目的更加明确的。<br><strong>TDD的优点</strong>：</p>\n<ol>\n<li>站在用户的角度思考，从用户的角度尽可能地想会进行的操作，而不是从一个开发的角度。</li>\n<li>先编写测试用例，再进行开发，为开发进行指导性的参考，防止遗漏某些功能。</li>\n<li>首先由了一套完整的测试用例，便可以让代码重构更安全，因为重构只是改变内部结构，不应改变外部功能，而TDD是关注外部接口，所以在重构时，只要保证测试用例通过即可放心更改内部代码。</li>\n<li>如果更改了某部分代码使测试用例不通过了，我们可以马上定位到刚才写的代码，修改错误。</li>\n</ol>\n<p>TDD把工作量前置，前期的准备工作量较大，不过后期就会很轻松。<br>关于TDD的介绍，可以看看这篇文章：<a href=\"http://blog.csdn.net/m13666368773/article/details/7006912\" target=\"_blank\" rel=\"external\">学习TDD：TDD的好处</a></p>\n<p><strong>BDD</strong>,全称是Behavior Driven Development，行为驱动开发。相比于TDD，BDD更加侧重设计，其要求在设计测试用例的时候对系统进行定义，倡导使用通用的语言将系统的行为描述出来，将系统设计和测试用例结合起来，从而以此为驱动进行开发工作。<br>BDD的通用语言是一种近乎自然语言的描述软件的形式。传统的开发模式中，开发人员很难从业务需求考虑问题，基于这种通用语言形式可以尽可能避免了因为理解需求不充分而带来的不必要的工作量。<br>BDD描述的行为就像一个个的故事(Story)，需求方、开发者、测试人员一起合作，分析软件的需求，然后将这些需求写成一个个的故事。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。</p>\n<h2 id=\"二、mocha\">二、mocha</h2><p><a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">Mocha</a>是具有丰富特性的 JavaScript 测试框架，可以运行在 Node.js 和浏览器中，使得异步测试更简单更有趣。Mocha 可以持续运行测试，支持灵活又准确的报告，当映射到未捕获异常时转到正确的测试示例。<br>它支持TDD/BDD等多种流行的接口，也接受多种Assertions（断言），如should.js/expect/chai/better-assert（断言框架）等，通过这些即可构建各种风格的测试用例。</p>\n<h3 id=\"1-_安装\">1. 安装</h3><p>要开始我们的单元测试之路，首先要安装mocha。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install mocha --save</div></pre></td></tr></table></figure></p>\n<p>为了方便，我们选择了断言库，这里选择的是<a href=\"http://chaijs.com/\" target=\"_blank\" rel=\"external\">chai</a>。chai是一个断言库，node本身也有个断言模块，但是功能比较弱，语法也比较贫乏。<br>chai提供了三种断言风格来分别适用于BDD和TDD。<strong>expect/should</strong> API 对应BDD风格<strong>，</strong>Assert__ API 对应TDD风格。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install chai --save</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-_起步\">2. 起步</h3><p>修改package.json 配置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> .....</div><div class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"mocha\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  .....</div></pre></td></tr></table></figure></p>\n<p>mocha默认执行test文件夹下的文件，所以一般测试文件都放在/test文件夹下面。并且命名为xxx.test.js<br>/api/add.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x,y</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = add;</div></pre></td></tr></table></figure></p>\n<p>/api/checkUser.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkUser</span>(<span class=\"params\">userName</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(userName == <span class=\"string\">'cky'</span>)&#123;</div><div class=\"line\">                resolve(&#123;<span class=\"attr\">data</span>:<span class=\"literal\">true</span>&#125;);</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                resolve(&#123;<span class=\"attr\">data</span>:<span class=\"literal\">false</span>&#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;,<span class=\"number\">300</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = checkUser;</div></pre></td></tr></table></figure></p>\n<p>/test/add.test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mocha  = <span class=\"built_in\">require</span>(<span class=\"string\">'mocha'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> chai   = <span class=\"built_in\">require</span>(<span class=\"string\">\"chai\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> expect = chai.expect;</div><div class=\"line\"><span class=\"keyword\">var</span> add    = <span class=\"built_in\">require</span>(<span class=\"string\">'../api/add'</span>);</div><div class=\"line\">describe(<span class=\"string\">'api文件测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  describe(<span class=\"string\">'add()函数测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'1+2应该等于3'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      expect(add(<span class=\"number\">1</span>,<span class=\"number\">2</span>)).to.be.equal(<span class=\"number\">3</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>/test/userCheck.test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mocha     = <span class=\"built_in\">require</span>(<span class=\"string\">'mocha'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> chai      = <span class=\"built_in\">require</span>(<span class=\"string\">\"chai\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> expect    = chai.expect;</div><div class=\"line\"><span class=\"keyword\">var</span> checkUser = <span class=\"built_in\">require</span>(<span class=\"string\">'../api/checkUser'</span>);</div><div class=\"line\">describe(<span class=\"string\">'api文件测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  describe(<span class=\"string\">'checkUser()异步函数测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'cky返回true'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> checkUser(<span class=\"string\">'cky'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">rs</span>)</span>&#123;</div><div class=\"line\">        expect(rs.data).to.be.ok;</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    it(<span class=\"string\">'xxx返回false'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> checkUser(<span class=\"string\">'xxx'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">rs</span>)</span>&#123;</div><div class=\"line\">        expect(rs.data).to.be.not.ok;</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>执行结果：<br><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">▶ npm test</div><div class=\"line\">&gt; mochatest@<span class=\"number\">0.0</span>.<span class=\"number\">1</span> test /Users/chenkeyi/cky/myDemo/test</div><div class=\"line\">&gt; mocha</div><div class=\"line\">  api文件测试</div><div class=\"line\">    add()函数测试</div><div class=\"line\">      ✓ <span class=\"number\">1</span>+<span class=\"number\">1</span>应该等于<span class=\"number\">2</span></div><div class=\"line\">    checkUser()异步函数测试</div><div class=\"line\">      ✓ cky返回true (<span class=\"number\">304</span>ms)</div><div class=\"line\">      ✓ xxx返回false (<span class=\"number\">303</span>ms)</div><div class=\"line\">  <span class=\"number\">3</span> passing (<span class=\"number\">627</span>ms)</div></pre></td></tr></table></figure></p>\n<p>上面这段代码，就是测试脚本，它可以独立执行。测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。<br>describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”api文件测试”），第二个参数是一个实际执行的函数。<br>it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（”1+2应该等于3”），第二个参数是一个实际执行的函数。</p>\n<p>从<code>checkUser</code>方法测试也可以看出，是支持promise风格写法的。</p>\n<h3 id=\"3-_断言\">3. 断言</h3><p>所谓”断言”，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。所有的测试用例（it块）都应该含有一句或多句的断言。它是编写测试用例的关键。断言功能由断言库来实现，Mocha本身不带断言库，所以必须先引入断言库。</p>\n<p>上面也提到了断言库chai，其中有三个API expect/should/assert，<br>详细的文档可以查看<a href=\"http://chaijs.com/api/\" target=\"_blank\" rel=\"external\">chai</a>。</p>\n<p><code>expect(rs.data).to.be.ok;</code>这句话，就是一个断言。</p>\n<p>要使用断言，首先要<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> chai      = <span class=\"built_in\">require</span>(<span class=\"string\">\"chai\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> expect    = chai.expect;</div></pre></td></tr></table></figure></p>\n<p>确认引入断言库，这里介绍比较常用的expect风格api。<br>我们可以这样写：<code>expect(4+5).equal(9);</code><br>Chai添加了下面的链式getter，它们不会做任何事，但是你可以将它们添加进入断言中是的句子变得啰嗦但是增加了易读性。</p>\n<ul>\n<li>to</li>\n<li>be</li>\n<li>been</li>\n<li>is</li>\n<li>that</li>\n<li>and</li>\n<li>have</li>\n<li>with</li>\n<li>at</li>\n<li>of</li>\n<li>same</li>\n<li>a</li>\n<li>an</li>\n</ul>\n<p>重写上面的方法：<br><code>expect(4+5).to.equal(5)</code><br>下面是一些使用断言例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 相等或不相等</span></div><div class=\"line\">expect(<span class=\"number\">4</span> + <span class=\"number\">5</span>).to.be.equal(<span class=\"number\">9</span>);</div><div class=\"line\">expect(<span class=\"number\">4</span> + <span class=\"number\">5</span>).to.be.not.equal(<span class=\"number\">10</span>);</div><div class=\"line\">expect(foo).to.be.deep.equal(&#123; <span class=\"attr\">bar</span>: <span class=\"string\">'baz'</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// 布尔值为true</span></div><div class=\"line\">expect(<span class=\"string\">'everthing'</span>).to.be.ok;</div><div class=\"line\">expect(<span class=\"literal\">false</span>).to.not.be.ok;</div><div class=\"line\"><span class=\"comment\">// typeof</span></div><div class=\"line\">expect(<span class=\"string\">'test'</span>).to.be.a(<span class=\"string\">'string'</span>);</div><div class=\"line\">expect(&#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span> &#125;).to.be.an(<span class=\"string\">'object'</span>);</div><div class=\"line\">expect(foo).to.be.an.instanceof(Foo);</div><div class=\"line\"><span class=\"comment\">// include</span></div><div class=\"line\">expect([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]).to.include(<span class=\"number\">2</span>);</div><div class=\"line\">expect(<span class=\"string\">'foobar'</span>).to.contain(<span class=\"string\">'foo'</span>);</div><div class=\"line\">expect(&#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">hello</span>: <span class=\"string\">'universe'</span> &#125;).to.include.keys(<span class=\"string\">'foo'</span>);</div><div class=\"line\"><span class=\"comment\">// empty</span></div><div class=\"line\">expect([]).to.be.empty;</div><div class=\"line\">expect(<span class=\"string\">''</span>).to.be.empty;</div><div class=\"line\">expect(&#123;&#125;).to.be.empty;</div><div class=\"line\"><span class=\"comment\">// match</span></div><div class=\"line\">expect(<span class=\"string\">'foobar'</span>).to.match(<span class=\"regexp\">/^foo/</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"4-_命令行参数\">4. 命令行参数</h3><p><code>--recursive</code> 执行/test文件夹下的所有测试文件<br><code>--reporter,-R</code> 参数用来指定测试报告的格式，默认是spec格式<br><code>--watch,-w</code> 参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。<br><code>--bail,-b</code> 参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例。这对持续集成很有用。<br><code>--grep,-g</code> 参数用于搜索测试用例的名称（即it块的第一个参数），然后只执行匹配的测试用例。<br><code>--invert,-i</code> 参数表示只运行不符合条件的测试脚本，必须与–grep参数配合使用。</p>\n<p>这些命令行参数可以写在mocha.opts文件中配置，这样命令行输入<code>mocha</code>一个命令就可以了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//mocha.opts</span></div><div class=\"line\">--reporter tap</div><div class=\"line\">--recursive</div><div class=\"line\">--growl</div></pre></td></tr></table></figure></p>\n<p>如果不是在test文件夹下存放测试文件，可以在mocha.opts配置文件中配置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//指定运行server-tests文件夹下的文件</span></div><div class=\"line\">server-tests</div><div class=\"line\">--recursive</div></pre></td></tr></table></figure></p>\n<h3 id=\"5-_异步测试\">5. 异步测试</h3><p>Mocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错。对于涉及异步操作的测试用例，这个时间往往是不够的，需要用-t或–timeout参数指定超时门槛。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//timeout.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> mocha     = <span class=\"built_in\">require</span>(<span class=\"string\">'mocha'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> chai      = <span class=\"built_in\">require</span>(<span class=\"string\">\"chai\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> expect    = chai.expect;</div><div class=\"line\"><span class=\"keyword\">var</span> checkUser = <span class=\"built_in\">require</span>(<span class=\"string\">'../api/checkUser'</span>);</div><div class=\"line\">describe(<span class=\"string\">'api文件测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  describe(<span class=\"string\">'timeout超时测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'测试应该4000毫秒后结束'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> x = <span class=\"literal\">true</span>;</div><div class=\"line\">      <span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        x = <span class=\"literal\">false</span>;</div><div class=\"line\">        expect(x).to.be.not.ok;</div><div class=\"line\">        done(); <span class=\"comment\">// 通知Mocha测试结束</span></div><div class=\"line\">      &#125;;</div><div class=\"line\">      setTimeout(f, <span class=\"number\">4000</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>在不设置 -t时，执行报错<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>) api文件测试 timeout超时测试 测试应该<span class=\"number\">4000</span>毫秒后结束:</div><div class=\"line\">     <span class=\"built_in\">Error</span>: Timeout <span class=\"keyword\">of</span> <span class=\"number\">2000</span>ms exceeded. For <span class=\"keyword\">async</span> tests and hooks, ensure <span class=\"string\">\"done()\"</span> is called; <span class=\"keyword\">if</span> returning a <span class=\"built_in\">Promise</span>, ensure it resolves.</div></pre></td></tr></table></figure></p>\n<p>设置超时5000m<code>mocha -t 5000</code>后正常执行</p>\n<p>另外，上面的测试用例里面，有一个done函数。it块执行的时候，传入一个done参数，当测试结束的时候，必须显式调用这个函数，告诉Mocha测试结束了。否则，Mocha就无法知道，测试是否结束，会一直等到超时报错。</p>\n<p>另外，Mocha内置对Promise的支持，允许直接返回Promise，等到它的状态改变，再执行断言，而不用显式调用done，见/test/userCheck.test.js。</p>\n<h3 id=\"6-_测试用例的钩子\">6. 测试用例的钩子</h3><p>Mocha在describe块之中，提供测试用例的四个钩子：<code>before()</code>、<code>after()</code>、<code>beforeEach()</code>和<code>afterEach()</code>。它们会在指定时间执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'hooks'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  before(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在本区块的所有测试用例之前执行</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  after(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在本区块的所有测试用例之后执行</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  beforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在本区块的每个测试用例之前执行</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  afterEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在本区块的每个测试用例之后执行</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"comment\">// test cases</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"三、参考文档\">三、参考文档</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html\" target=\"_blank\" rel=\"external\">测试框架 Mocha 实例教程</a></li>\n<li><a href=\"http://imweb.io/topic/5634c91109e01a534b461eaa?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">单元测试 &amp; mocha 简述</a></li>\n<li><a href=\"http://blog.csdn.net/m13666368773/article/details/7006912\" target=\"_blank\" rel=\"external\">学习TDD：TDD的好处</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"一、什么是单元测试\">一、什么是单元测试</h2><blockquote>\n<p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p>\n</blockquote>\n<p>单元测试在前端领域并不被重视，前端程序员也没有写单元测试的习惯。但是，随着前端技术的发展，随着node的发展，越来越多“非UI”的前端代码出现，前端开发们也需要了解掌握单元测试知识。<br>单元测试是保证代码质量的重要环节之一，特别是这些代码是会提供给其他人使用的时候，比如node插件，grunt插件等等<br>单元测试的作用有许多，下面列举一些：</p>\n<ul>\n<li>保证代码可用</li>\n<li>另一种纬度的文档</li>\n<li>方便迭代回归</li>\n<li>驱动开发</li>\n</ul>\n<h3 id=\"TDD与BDD\">TDD与BDD</h3><p><strong>TDD</strong>,全称是Test Driver Development，测试驱动开发。先编写测试用例（没有代码之前这些测试用例一个也通不过），然后再写代码让这些测试用例通过。更进一层的讲就是：编写足够的测试用例使测试失败，编写足够的代码是测试成功。我们编码的目的更加明确的。<br><strong>TDD的优点</strong>：</p>\n<ol>\n<li>站在用户的角度思考，从用户的角度尽可能地想会进行的操作，而不是从一个开发的角度。</li>\n<li>先编写测试用例，再进行开发，为开发进行指导性的参考，防止遗漏某些功能。</li>\n<li>首先由了一套完整的测试用例，便可以让代码重构更安全，因为重构只是改变内部结构，不应改变外部功能，而TDD是关注外部接口，所以在重构时，只要保证测试用例通过即可放心更改内部代码。</li>\n<li>如果更改了某部分代码使测试用例不通过了，我们可以马上定位到刚才写的代码，修改错误。</li>\n</ol>\n<p>TDD把工作量前置，前期的准备工作量较大，不过后期就会很轻松。<br>关于TDD的介绍，可以看看这篇文章：<a href=\"http://blog.csdn.net/m13666368773/article/details/7006912\">学习TDD：TDD的好处</a></p>\n<p><strong>BDD</strong>,全称是Behavior Driven Development，行为驱动开发。相比于TDD，BDD更加侧重设计，其要求在设计测试用例的时候对系统进行定义，倡导使用通用的语言将系统的行为描述出来，将系统设计和测试用例结合起来，从而以此为驱动进行开发工作。<br>BDD的通用语言是一种近乎自然语言的描述软件的形式。传统的开发模式中，开发人员很难从业务需求考虑问题，基于这种通用语言形式可以尽可能避免了因为理解需求不充分而带来的不必要的工作量。<br>BDD描述的行为就像一个个的故事(Story)，需求方、开发者、测试人员一起合作，分析软件的需求，然后将这些需求写成一个个的故事。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。</p>\n<h2 id=\"二、mocha\">二、mocha</h2><p><a href=\"https://mochajs.org/\">Mocha</a>是具有丰富特性的 JavaScript 测试框架，可以运行在 Node.js 和浏览器中，使得异步测试更简单更有趣。Mocha 可以持续运行测试，支持灵活又准确的报告，当映射到未捕获异常时转到正确的测试示例。<br>它支持TDD/BDD等多种流行的接口，也接受多种Assertions（断言），如should.js/expect/chai/better-assert（断言框架）等，通过这些即可构建各种风格的测试用例。</p>\n<h3 id=\"1-_安装\">1. 安装</h3><p>要开始我们的单元测试之路，首先要安装mocha。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install mocha --save</div></pre></td></tr></table></figure></p>\n<p>为了方便，我们选择了断言库，这里选择的是<a href=\"http://chaijs.com/\">chai</a>。chai是一个断言库，node本身也有个断言模块，但是功能比较弱，语法也比较贫乏。<br>chai提供了三种断言风格来分别适用于BDD和TDD。<strong>expect/should</strong> API 对应BDD风格<strong>，</strong>Assert__ API 对应TDD风格。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install chai --save</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-_起步\">2. 起步</h3><p>修改package.json 配置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> .....</div><div class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"mocha\"</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  .....</div></pre></td></tr></table></figure></p>\n<p>mocha默认执行test文件夹下的文件，所以一般测试文件都放在/test文件夹下面。并且命名为xxx.test.js<br>/api/add.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x,y</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = add;</div></pre></td></tr></table></figure></p>\n<p>/api/checkUser.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkUser</span>(<span class=\"params\">userName</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(userName == <span class=\"string\">'cky'</span>)&#123;</div><div class=\"line\">                resolve(&#123;<span class=\"attr\">data</span>:<span class=\"literal\">true</span>&#125;);</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                resolve(&#123;<span class=\"attr\">data</span>:<span class=\"literal\">false</span>&#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;,<span class=\"number\">300</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = checkUser;</div></pre></td></tr></table></figure></p>\n<p>/test/add.test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mocha  = <span class=\"built_in\">require</span>(<span class=\"string\">'mocha'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> chai   = <span class=\"built_in\">require</span>(<span class=\"string\">\"chai\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> expect = chai.expect;</div><div class=\"line\"><span class=\"keyword\">var</span> add    = <span class=\"built_in\">require</span>(<span class=\"string\">'../api/add'</span>);</div><div class=\"line\">describe(<span class=\"string\">'api文件测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  describe(<span class=\"string\">'add()函数测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'1+2应该等于3'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      expect(add(<span class=\"number\">1</span>,<span class=\"number\">2</span>)).to.be.equal(<span class=\"number\">3</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>/test/userCheck.test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mocha     = <span class=\"built_in\">require</span>(<span class=\"string\">'mocha'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> chai      = <span class=\"built_in\">require</span>(<span class=\"string\">\"chai\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> expect    = chai.expect;</div><div class=\"line\"><span class=\"keyword\">var</span> checkUser = <span class=\"built_in\">require</span>(<span class=\"string\">'../api/checkUser'</span>);</div><div class=\"line\">describe(<span class=\"string\">'api文件测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  describe(<span class=\"string\">'checkUser()异步函数测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'cky返回true'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> checkUser(<span class=\"string\">'cky'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">rs</span>)</span>&#123;</div><div class=\"line\">        expect(rs.data).to.be.ok;</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    it(<span class=\"string\">'xxx返回false'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> checkUser(<span class=\"string\">'xxx'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">rs</span>)</span>&#123;</div><div class=\"line\">        expect(rs.data).to.be.not.ok;</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>执行结果：<br><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">▶ npm test</div><div class=\"line\">&gt; mochatest@<span class=\"number\">0.0</span>.<span class=\"number\">1</span> test /Users/chenkeyi/cky/myDemo/test</div><div class=\"line\">&gt; mocha</div><div class=\"line\">  api文件测试</div><div class=\"line\">    add()函数测试</div><div class=\"line\">      ✓ <span class=\"number\">1</span>+<span class=\"number\">1</span>应该等于<span class=\"number\">2</span></div><div class=\"line\">    checkUser()异步函数测试</div><div class=\"line\">      ✓ cky返回true (<span class=\"number\">304</span>ms)</div><div class=\"line\">      ✓ xxx返回false (<span class=\"number\">303</span>ms)</div><div class=\"line\">  <span class=\"number\">3</span> passing (<span class=\"number\">627</span>ms)</div></pre></td></tr></table></figure></p>\n<p>上面这段代码，就是测试脚本，它可以独立执行。测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。<br>describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”api文件测试”），第二个参数是一个实际执行的函数。<br>it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（”1+2应该等于3”），第二个参数是一个实际执行的函数。</p>\n<p>从<code>checkUser</code>方法测试也可以看出，是支持promise风格写法的。</p>\n<h3 id=\"3-_断言\">3. 断言</h3><p>所谓”断言”，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。所有的测试用例（it块）都应该含有一句或多句的断言。它是编写测试用例的关键。断言功能由断言库来实现，Mocha本身不带断言库，所以必须先引入断言库。</p>\n<p>上面也提到了断言库chai，其中有三个API expect/should/assert，<br>详细的文档可以查看<a href=\"http://chaijs.com/api/\">chai</a>。</p>\n<p><code>expect(rs.data).to.be.ok;</code>这句话，就是一个断言。</p>\n<p>要使用断言，首先要<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> chai      = <span class=\"built_in\">require</span>(<span class=\"string\">\"chai\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> expect    = chai.expect;</div></pre></td></tr></table></figure></p>\n<p>确认引入断言库，这里介绍比较常用的expect风格api。<br>我们可以这样写：<code>expect(4+5).equal(9);</code><br>Chai添加了下面的链式getter，它们不会做任何事，但是你可以将它们添加进入断言中是的句子变得啰嗦但是增加了易读性。</p>\n<ul>\n<li>to</li>\n<li>be</li>\n<li>been</li>\n<li>is</li>\n<li>that</li>\n<li>and</li>\n<li>have</li>\n<li>with</li>\n<li>at</li>\n<li>of</li>\n<li>same</li>\n<li>a</li>\n<li>an</li>\n</ul>\n<p>重写上面的方法：<br><code>expect(4+5).to.equal(5)</code><br>下面是一些使用断言例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 相等或不相等</span></div><div class=\"line\">expect(<span class=\"number\">4</span> + <span class=\"number\">5</span>).to.be.equal(<span class=\"number\">9</span>);</div><div class=\"line\">expect(<span class=\"number\">4</span> + <span class=\"number\">5</span>).to.be.not.equal(<span class=\"number\">10</span>);</div><div class=\"line\">expect(foo).to.be.deep.equal(&#123; <span class=\"attr\">bar</span>: <span class=\"string\">'baz'</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// 布尔值为true</span></div><div class=\"line\">expect(<span class=\"string\">'everthing'</span>).to.be.ok;</div><div class=\"line\">expect(<span class=\"literal\">false</span>).to.not.be.ok;</div><div class=\"line\"><span class=\"comment\">// typeof</span></div><div class=\"line\">expect(<span class=\"string\">'test'</span>).to.be.a(<span class=\"string\">'string'</span>);</div><div class=\"line\">expect(&#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span> &#125;).to.be.an(<span class=\"string\">'object'</span>);</div><div class=\"line\">expect(foo).to.be.an.instanceof(Foo);</div><div class=\"line\"><span class=\"comment\">// include</span></div><div class=\"line\">expect([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]).to.include(<span class=\"number\">2</span>);</div><div class=\"line\">expect(<span class=\"string\">'foobar'</span>).to.contain(<span class=\"string\">'foo'</span>);</div><div class=\"line\">expect(&#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">hello</span>: <span class=\"string\">'universe'</span> &#125;).to.include.keys(<span class=\"string\">'foo'</span>);</div><div class=\"line\"><span class=\"comment\">// empty</span></div><div class=\"line\">expect([]).to.be.empty;</div><div class=\"line\">expect(<span class=\"string\">''</span>).to.be.empty;</div><div class=\"line\">expect(&#123;&#125;).to.be.empty;</div><div class=\"line\"><span class=\"comment\">// match</span></div><div class=\"line\">expect(<span class=\"string\">'foobar'</span>).to.match(<span class=\"regexp\">/^foo/</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"4-_命令行参数\">4. 命令行参数</h3><p><code>--recursive</code> 执行/test文件夹下的所有测试文件<br><code>--reporter,-R</code> 参数用来指定测试报告的格式，默认是spec格式<br><code>--watch,-w</code> 参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。<br><code>--bail,-b</code> 参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例。这对持续集成很有用。<br><code>--grep,-g</code> 参数用于搜索测试用例的名称（即it块的第一个参数），然后只执行匹配的测试用例。<br><code>--invert,-i</code> 参数表示只运行不符合条件的测试脚本，必须与–grep参数配合使用。</p>\n<p>这些命令行参数可以写在mocha.opts文件中配置，这样命令行输入<code>mocha</code>一个命令就可以了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//mocha.opts</span></div><div class=\"line\">--reporter tap</div><div class=\"line\">--recursive</div><div class=\"line\">--growl</div></pre></td></tr></table></figure></p>\n<p>如果不是在test文件夹下存放测试文件，可以在mocha.opts配置文件中配置<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//指定运行server-tests文件夹下的文件</span></div><div class=\"line\">server-tests</div><div class=\"line\">--recursive</div></pre></td></tr></table></figure></p>\n<h3 id=\"5-_异步测试\">5. 异步测试</h3><p>Mocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错。对于涉及异步操作的测试用例，这个时间往往是不够的，需要用-t或–timeout参数指定超时门槛。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//timeout.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> mocha     = <span class=\"built_in\">require</span>(<span class=\"string\">'mocha'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> chai      = <span class=\"built_in\">require</span>(<span class=\"string\">\"chai\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> expect    = chai.expect;</div><div class=\"line\"><span class=\"keyword\">var</span> checkUser = <span class=\"built_in\">require</span>(<span class=\"string\">'../api/checkUser'</span>);</div><div class=\"line\">describe(<span class=\"string\">'api文件测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  describe(<span class=\"string\">'timeout超时测试'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'测试应该4000毫秒后结束'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> x = <span class=\"literal\">true</span>;</div><div class=\"line\">      <span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        x = <span class=\"literal\">false</span>;</div><div class=\"line\">        expect(x).to.be.not.ok;</div><div class=\"line\">        done(); <span class=\"comment\">// 通知Mocha测试结束</span></div><div class=\"line\">      &#125;;</div><div class=\"line\">      setTimeout(f, <span class=\"number\">4000</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>在不设置 -t时，执行报错<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>) api文件测试 timeout超时测试 测试应该<span class=\"number\">4000</span>毫秒后结束:</div><div class=\"line\">     <span class=\"built_in\">Error</span>: Timeout <span class=\"keyword\">of</span> <span class=\"number\">2000</span>ms exceeded. For <span class=\"keyword\">async</span> tests and hooks, ensure <span class=\"string\">\"done()\"</span> is called; <span class=\"keyword\">if</span> returning a <span class=\"built_in\">Promise</span>, ensure it resolves.</div></pre></td></tr></table></figure></p>\n<p>设置超时5000m<code>mocha -t 5000</code>后正常执行</p>\n<p>另外，上面的测试用例里面，有一个done函数。it块执行的时候，传入一个done参数，当测试结束的时候，必须显式调用这个函数，告诉Mocha测试结束了。否则，Mocha就无法知道，测试是否结束，会一直等到超时报错。</p>\n<p>另外，Mocha内置对Promise的支持，允许直接返回Promise，等到它的状态改变，再执行断言，而不用显式调用done，见/test/userCheck.test.js。</p>\n<h3 id=\"6-_测试用例的钩子\">6. 测试用例的钩子</h3><p>Mocha在describe块之中，提供测试用例的四个钩子：<code>before()</code>、<code>after()</code>、<code>beforeEach()</code>和<code>afterEach()</code>。它们会在指定时间执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'hooks'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  before(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在本区块的所有测试用例之前执行</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  after(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在本区块的所有测试用例之后执行</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  beforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在本区块的每个测试用例之前执行</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  afterEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在本区块的每个测试用例之后执行</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"comment\">// test cases</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"三、参考文档\">三、参考文档</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html\">测试框架 Mocha 实例教程</a></li>\n<li><a href=\"http://imweb.io/topic/5634c91109e01a534b461eaa?utm_source=tuicool&amp;utm_medium=referral\">单元测试 &amp; mocha 简述</a></li>\n<li><a href=\"http://blog.csdn.net/m13666368773/article/details/7006912\">学习TDD：TDD的好处</a></li>\n</ul>\n"},{"title":"关于jQuery的Deferred对象介绍（译）","date":"2016-03-25T09:28:50.000Z","_content":"\n(趁着毕设要求，翻译了一篇文章，顺便放上来。英文不好翻了2天才翻完，/(ㄒoㄒ)/~~如有错误欢迎指正。)\n原文链接:[An Introduction to jQuery’s Deferred Objects](http://www.sitepoint.com/introduction-jquery-deferred-objects/)\n\n长久以来，javascript的开发者习惯于使用回调函数去执行某些任务。一个常见的例子就是当某些事件比如`click`或者`keypress`执行的时候，通过`addEventListener()`添加回调函数。这样做的好处是，回调函数很简单，让工作能够很方便地完成，不幸的是，当你的网页变得越来越复杂而且你需要执行许多异步请求时，它们变得越来越难以处理。\n\nECMAScript2015引进了一个原生的方法去处理这种情况：promise。如果你不知道什么是promise，你可以读一读这篇文章[An Overview of JavaScript Promises](http://www.sitepoint.com/overview-javascript-promises/)。jQuery推出了它自己风格的promise，就是 __Deferred对象__ 。它在promise被引入ECMAScript之前几年就被引入了jqurey，在这篇文章里，我会讨论一下什么是`Deferred`对象，还有它解决了什么问题。\n\n## 一个简单的历史介绍\n`Deferred`对象在jQuery1.5版本被引入，它能让回调函数成为一个回调队列，继而被链式调用，它还能处理同步或者异步函数的成功或者失败状态。从此以后，它成为了一个课题被讨论和研究，也有一些批评的声音，伴随着批评和它也发生了许多改变。这里有两篇对它的批判性的文章：[You’re Missing the Point of Promises](https://blog.domenic.me/youre-missing-the-point-of-promises/)和[JavaScript Promises and why jQuery implementation is broken](https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/)。\n\n连同[Promise对象](http://api.jquery.com/Types/#Promise),Deferred代表了jQuery对于Promises的实现。在jQuery1.X版本和2.x版本里，deferred对象依附于[the CommonJS Promises/A proposal](http://wiki.commonjs.org/wiki/Promises/A)，这个提案被作为[Promises/A+ proposal](https://promisesaplus.com/)的基础，而原生的promises就是在此基础上建立的。正如前面所提到的，jQuery没有依附于 Promises/A+的原因是它在这之前就已经产生了。\n\n因为jQuery是一个先驱者，还由于向后兼容问题，在原生javascript里使用promise与在jQuery1.x、2.x版本里使用都有一些区别。而且，由于jQuery遵循了一个不同的提案，这个框架和其他实现了promises的框架比如[the Q library](https://github.com/kriskowal/q)是互不兼容的。\n\n在即将到来的 __jQuery 3__ 版本里，改进了与原生的Promises(在ECMAScript 2015被实现的)的兼容性。虽然有些主要的方法（then())还是由于向后兼容的原因和原生的Promises有些差别，但是其使用习惯已经越来越接近规范标准了。\n\n<h2 id=\"callbackJquery\">jQuery中的回调</h2>\n为了理解为什么你需要使用`Deferred`对象，让我们先讨论一个例子。当你使用jQuery的时候，一定经常使用它的ajax方法去处理异步请求。为了理解这个例子，让我们假设你正在开发一个网页并且正在向Github的API发送Ajax请求。你的目标是收到用户的仓库列表，找到最近更新过的仓库，找到第一个名为'README.md'的文件，最终接收到这个文件的内容。基于以上的描述，你每一个Ajax请求可能都会是在上一个步骤完成的时候发送，换句话说，这些请求必须在一个队列中执行。\n\n让我们把这些描述转换为代码（请注意我没有使用真的Github的API），我们得到以下代码：\n```javascript\nvar username = 'testuser';\nvar fileToSearch = 'README.md';\n\n$.getJSON('https://api.github.com/user/' + username + '/repositories', function(repositories) {\n  \n  var lastUpdatedRepository = repositories[0].name;\n\n  $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/files', function(files) {\n    var README = null;\n\n    for (var i = 0; i < files.length; i++) {\n      if (files[i].name.indexOf(fileToSearch) >= 0) {\n        README = files[i].path;\n\n        break;\n      }\n    }\n\n    $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/file/' + README + '/content', function(content) {\n      console.log('The content of the file is: ' + content);\n    });\n  });\n});\n\n```\n正如你在这个例子里看到的，为了达到目的，我们必须嵌套执行Ajax请求。这让我们的代码变得可读性比较差。在我们必须嵌套使用大量的回调，或者需要一个独立的回调函数需要和另一个函数以同步的方式执行时，我们通常称这种情况为“回调地狱”。\n\n为了让这种情况变好一点，你可以将我上面写的匿名函数提取出来命名。然而，这样改变也没啥帮助，我们仍然发现我们身处于回调地狱中。下面，我们就走进`Deferred`对象和`Promise`对象吧。\n\n## Deferred对象和Promise对象\nDeferred对象可以在执行异步操作的时候使用，比如Ajax请求和动画。在jQuery里，`Promise`对象创建于`Deferred`对象或者`jQuery`对象。它拥有`Deferred`对象下的方法，如：`always()`,`done()`,`fail()`,`state()`,和`then()`。我会在下面介绍这些方法。\n\n如果你是来自原生javascript世界的，你可能会对这两个对象的存在感到很困惑。为什么我们要有两个对象（`Deferred`和`Promise`），而原生Javascript只有一个（`Promise`)？为了解释他们的不同和他们的用例，我在我的书中对他们进行了类比[jQuery in Action, Third Edition](https://www.manning.com/books/jquery-in-action-third-edition)。\n\n一个使用`Deferred`对象的典型情况是，如果你正在编写一个函数去处理异步操作，并且可能会返回一个值（返回一个错误或者不返回值也行）。在这种情况下，你的函数是值的“生产者”，而且你希望阻止用户去改变`Deferred`的状态。当你是这个函数的消费者时，你就要使用`promise`。\n\n为了阐明这个观点，让我们假设你希望实现一个基于promise的 `timeout()`方法(下面是这个[例子的代码](#creatingapromisebasedsettimeoutfunction)。你负责写这个函数，但是必须等到获得一个时间的数字（在这个等待的情况下没有值返回），这让你成为一个“生产者”。你这个函数的“消费者”不需要关心去resolve它或者reject它，“消费者”只需要能够在Deferred执行完成后、失败后、或者进程中添加函数。另外，你想要确保你的“消费者”不能resolve或reject这个Deferred对象。为了达到这个目标，你需要在你创建的`timeoout()`函数中返回`Deferred`的`promise`对象，而不是`Deferred`对象本身。这样做之后，你能确保除了你的`timeout()`函数以外，没有人能够调用`resolve()`和`reject()`方法。\n\n你可以在[StackOverflow question](http://stackoverflow.com/questions/17308172/deferred-versus-promise)了解更多关于jQuery的Deferred对象和Promise对象的区别。\n\n现在你知道这些对象是什么了，让我们来了解一下这些方法的作用。\n\n## Deferred对象的方法\n`Deferred`对象非常灵活，提供了很多方法满足你的需求。它可以被创建为`jQuery.Deferred()`，方法如下：\n```javascript\nvar deferred = jQuery.Deferred();\n```\n或者，你也可以用`$`创建：\n```javascript\nvar deferred = $.Deferred();\n```\n一旦创建，这个`Deferred`对象就暴露了一些方法，除了那些不赞成使用的和被移除的方法，它暴露的方法有：\n\n- `always(callbacks[, callbacks, ..., callbacks]):` 在无论Deferred对象resolved还是rejected的时候都会执行。\n- `done(callbacks[, callbacks, ..., callbacks]):` 当Deferred对象resolved的时候执行。\n- `fail(callbacks[, callbacks, ..., callbacks]):` 当Deferred对象rejected的时候执行。\n- `notify([argument, ..., argument]):` 根据给定的 args参数 调用Deferred对象上进行中的回调 （progressCallbacks）。\n- `notifyWith(context[, argument, ..., argument]):` 根据给定的上下文（context）和args递延调用Deferred对象上进行中的回调（progressCallbacks ）。\n- `progress(callbacks[, callbacks, ..., callbacks])`:当Deferred（延迟）对象生成进度通知时，调用添加处理程序。\n- `promise([target]):` Return a Deferred‘s Promise object.\n- `reject([argument, ..., argument]):` 拒绝Deferred（延迟）对象，并根据给定的args参数调用任何失败回调函数（failCallbacks）。\n- `rejectWith(context[, argument, ..., argument]): `拒绝Deferred（延迟）对象，并根据给定的 context和args参数调用任何失败回调函数（failCallbacks）。\n- `resolve([argument, ..., argument]):` 解决Deferred（延迟）对象，并根据给定的args参数调用任何完成回调函数（doneCallbacks）。\n- `resolveWith(context[, argument, ..., argument]):` 解决Deferred（延迟）对象，并根据给定的 context和args参数调用任何完成回调函数（doneCallbacks）。\n- `state():`确定一个Deferred（延迟）对象的当前状态。\n- `then(resolvedCallback[, rejectedCallback[, progressCallback]]):` 当Deferred（延迟）对象解决，拒绝或仍在进行中时，调用添加处理程序。\n\n通过这些方法的描述，让我们能够更明显地了解到jQuery文档中的术语和ECMAScript标准里的区别。在ECMAScript标准里，一个promise对象被称作resolved是在他完成或者被拒绝的时候。然而，在jQuery文档里，resolved描述的只是在ECMAScript中的完成状态。\n\nDeferred提供了大量的方法，在本篇文章中不能全部介绍到。不过，在下面的内容中，我会展示一些`Deferred`对象和`Promise`对象的使用的例子。首先，我来会用Deferred对象重写一下在[jQuery中的回调](#callbackJquery)中的那段代码，然后我会把“生产者和消费者”的比喻再解释一下。\n\n## 用Deferred对象完成Ajax请求队列\n在这个章节我会展示怎么用Deferred对象和它的一些方法去提高[jQuery中的回调](#callbackJquery)里的那段代码的可读性，在开始探索之前，我们必须要明白我们需要用到哪些方法。\n\n根据我们的需求和上面列出的方法列表，很明显我们可以用`done()`或者`then()`方法去管理成功的状态。由于你们大多数可能已经习惯于使用Javascript的`Promise`对象，在这个例子中，我会选择使用`then()`方法。在这两个方法最重要的一个区别是`then()`方法能够\n将接收到的值作为参数传递给其他在后面调用的`then()`、`done()`、`fail()`或`progress()`方法。\n\n最后的代码：\n```javascript\nvar username = 'testuser';\nvar fileToSearch = 'README.md';\n\n$.getJSON('https://api.github.com/user/' + username + '/repositories')\n    .then(function(repositories) {\n        return repositories[0].name;\n    })\n    .then(function(lastUpdatedRepository) {\n        return $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/files');\n    })\n    .then(function(files) {\n        var README = null;\n\n        for (var i = 0; i < files.length; i++) {\n            if (files[i].name.indexOf(fileToSearch) >= 0) {\n                README = files[i].path;\n\n                break;\n            }\n        }\n\n        return README;\n    })\n    .then(function(README) {\n        return $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/file/' + README + '/content');\n    })\n    .then(function(content) {\n        console.log(content);\n    });\n```\n\n正如你看到的，这段代码比之前的可读性好了很多，因为我们能把每一个步骤拆开看，它们都同一级，没有嵌套。\n\n<h2 id=\"creatingapromisebasedsettimeoutfunction\">创造一个基于Promise的setTimeout函数</h2>\n你也许知道，`setTimeout()`能在指定的时间后执行回调函数。它的两个元素（回调函数和时间）都应该作为参数被提供。让我们假设你想要1秒后在控制台打印一段信息。使用`setTimeout()`，你可以达到这个目的：\n\n```javascript\nsetTimeout(\n  function() {\n    console.log('I waited for 1 second!');\n  },\n  1000\n);\n```\n\n正如你所见，第一个参数是一个想要被执行的函数，第二个是多少需要等待的毫秒数。这个函数一向很有用，但是如果你想用通过`Deferred`队列实现呢？\n\n在下面我会告诉你怎么用jQuery提供的`Promise`对象完成一个基于promise的`setTimeout()`函数。\n\n最后的代码：\n```javascript\nfunction timeout(milliseconds) {\n    // Create a new Deferred object\n    var deferred = $.Deferred();\n\n    // Resolve the Deferred after the amount of time specified by milliseconds\n    setTimeout(deferred.resolve, milliseconds);\n\n    // Return the Deferred's Promise object\n    return deferred.promise();\n}\n\ntimeout(1000).then(function() {\n    console.log('I waited for 1 second!');\n});\n```\n我定义了一个`timeout()`函数，包裹了javaScript的原生`setTimeout()`方法。在`timeout()`方法里我创建了一个新的`Deferred`对象去管理异步任务，在`milliseconds`时间后`deferred`对象被设置为resolve状态。在这种情况下，`timeout()`函数是这个值的生产者，所以它创建了`Deferred`对象还返回了`Promise`对象。通过这样，我能确保这个函数的调用者（消费者）不能够resolve或者reject这个`Deferred`对象。事实上，这个调用者只能添加函数去执行，和使用`done()`,`faile()`等方法。\n\n## jQuery 1.x/2.x 与 jQuery 3的区别\n在第一个例子里，我们创建了一段代码去查找一个名为\"README.md\"的文件，但是我们没有处理这个文件没有被找到的情况。这种情况应该被称作失败的情况，当失败发送时，我们可能需要去打断这个队列直接结束。如果这样做的话它会很自然的抛出一个异常，取到这个异常后被fail()这个方法执行，就像你在js里面用的catch()方法一样。\n\n遵循Promises/A和Promises/A+的库（比如jQuery3.x），抛出的异常是被转换为rejection然后调用错误回调函数，比如`fail()`，被捕获的异常会作为参数传递进去。\n\n在jQuery1.x和2.x版本中，未被捕获的异常会终止程序的执行，这些版本下允许抛出的异常冒泡，通常是达到`window.onerror`。如果没有定义函数去处理这个异常，这个异常信息会在控制台显示，而且会中断代码执行。\n\n为了更好的理解他们不同的地方，让我们看看这个例子：\n```javascript\nvar deferred = $.Deferred();\ndeferred\n  .then(function() {\n    throw new Error('An error message');\n  })\n  .then(\n    function() {\n      console.log('First success function');\n    },\n    function() {\n      console.log('First failure function');\n    }\n  )\n  .then(\n    function() {\n      console.log('Second success function');\n    },\n    function() {\n      console.log('Second failure function');\n    }\n  );\n\ndeferred.resolve();\n\n```\n在jQuery3.x版本中，会打印信息\"First failure function\"和\"Second success function\"到控制台。原因就和我上面说的一样，一个抛出的异常会被转变为`rejection`，然后错误处理函数会在这时候被调用。而且，一旦异常被管理到（在这个例子中传递给了第二个`then()`），接下来的成功回调函数会被调用（本例中的第三个`then()`）。\n\n在jQuery1.x和2.x版本中，只有第一个函数（抛出异常的函数）会执行，然后你会看到在控制台输出了\"Uncaught Error: An error message\"。\n\n__jQuery 1.x/2.x__\n<iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/nozege/embed?js,console\" src=\"http://jsbin.com/nozege/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe>\n__jQuery3__\n<iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/kifazi/embed?js,console\" src=\"http://jsbin.com/kifazi/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe>\n\n为了进一步提高它与ECMAScript 2015的兼容性，jQuery3也给`Deferred`和`Promise`对象添加了一个`catch()`方法。它是被定义来处理`Deferred`对象`rejected`或者 它的`Promise`对象处于rejected的情况：\n```javascript\ndeferred.catch(rejectedCallback)\n```\n这个方法只是`then(null,rejectedCallback)`的简写形式。\n\n## 总结\n在这篇文章里，我向你介绍了jQuery对于promises的实现方式。Promises让你不用很麻烦地让异步函数并行起来，也不用在回调函数里嵌套回调函数再嵌套回调函数……\n\n除此之外，我也介绍了jQuery3怎么提升它和原生promise的兼容性。尽管老版本的jQuery和ECMAScript 2015的还有比较明显的不同，`Deferred`对象仍然是一个令人难以置信的强大的工具。作为一个专业的开发者，随着项目难度的增加，你会发现你会经常用到它。\n","source":"_posts/introduction-jquery-deferred-objects.md","raw":"title: 关于jQuery的Deferred对象介绍（译）\ndate: 2016-03-25 17:28:50\ntags: web前端知识\n---\n\n(趁着毕设要求，翻译了一篇文章，顺便放上来。英文不好翻了2天才翻完，/(ㄒoㄒ)/~~如有错误欢迎指正。)\n原文链接:[An Introduction to jQuery’s Deferred Objects](http://www.sitepoint.com/introduction-jquery-deferred-objects/)\n\n长久以来，javascript的开发者习惯于使用回调函数去执行某些任务。一个常见的例子就是当某些事件比如`click`或者`keypress`执行的时候，通过`addEventListener()`添加回调函数。这样做的好处是，回调函数很简单，让工作能够很方便地完成，不幸的是，当你的网页变得越来越复杂而且你需要执行许多异步请求时，它们变得越来越难以处理。\n\nECMAScript2015引进了一个原生的方法去处理这种情况：promise。如果你不知道什么是promise，你可以读一读这篇文章[An Overview of JavaScript Promises](http://www.sitepoint.com/overview-javascript-promises/)。jQuery推出了它自己风格的promise，就是 __Deferred对象__ 。它在promise被引入ECMAScript之前几年就被引入了jqurey，在这篇文章里，我会讨论一下什么是`Deferred`对象，还有它解决了什么问题。\n\n## 一个简单的历史介绍\n`Deferred`对象在jQuery1.5版本被引入，它能让回调函数成为一个回调队列，继而被链式调用，它还能处理同步或者异步函数的成功或者失败状态。从此以后，它成为了一个课题被讨论和研究，也有一些批评的声音，伴随着批评和它也发生了许多改变。这里有两篇对它的批判性的文章：[You’re Missing the Point of Promises](https://blog.domenic.me/youre-missing-the-point-of-promises/)和[JavaScript Promises and why jQuery implementation is broken](https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/)。\n\n连同[Promise对象](http://api.jquery.com/Types/#Promise),Deferred代表了jQuery对于Promises的实现。在jQuery1.X版本和2.x版本里，deferred对象依附于[the CommonJS Promises/A proposal](http://wiki.commonjs.org/wiki/Promises/A)，这个提案被作为[Promises/A+ proposal](https://promisesaplus.com/)的基础，而原生的promises就是在此基础上建立的。正如前面所提到的，jQuery没有依附于 Promises/A+的原因是它在这之前就已经产生了。\n\n因为jQuery是一个先驱者，还由于向后兼容问题，在原生javascript里使用promise与在jQuery1.x、2.x版本里使用都有一些区别。而且，由于jQuery遵循了一个不同的提案，这个框架和其他实现了promises的框架比如[the Q library](https://github.com/kriskowal/q)是互不兼容的。\n\n在即将到来的 __jQuery 3__ 版本里，改进了与原生的Promises(在ECMAScript 2015被实现的)的兼容性。虽然有些主要的方法（then())还是由于向后兼容的原因和原生的Promises有些差别，但是其使用习惯已经越来越接近规范标准了。\n\n<h2 id=\"callbackJquery\">jQuery中的回调</h2>\n为了理解为什么你需要使用`Deferred`对象，让我们先讨论一个例子。当你使用jQuery的时候，一定经常使用它的ajax方法去处理异步请求。为了理解这个例子，让我们假设你正在开发一个网页并且正在向Github的API发送Ajax请求。你的目标是收到用户的仓库列表，找到最近更新过的仓库，找到第一个名为'README.md'的文件，最终接收到这个文件的内容。基于以上的描述，你每一个Ajax请求可能都会是在上一个步骤完成的时候发送，换句话说，这些请求必须在一个队列中执行。\n\n让我们把这些描述转换为代码（请注意我没有使用真的Github的API），我们得到以下代码：\n```javascript\nvar username = 'testuser';\nvar fileToSearch = 'README.md';\n\n$.getJSON('https://api.github.com/user/' + username + '/repositories', function(repositories) {\n  \n  var lastUpdatedRepository = repositories[0].name;\n\n  $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/files', function(files) {\n    var README = null;\n\n    for (var i = 0; i < files.length; i++) {\n      if (files[i].name.indexOf(fileToSearch) >= 0) {\n        README = files[i].path;\n\n        break;\n      }\n    }\n\n    $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/file/' + README + '/content', function(content) {\n      console.log('The content of the file is: ' + content);\n    });\n  });\n});\n\n```\n正如你在这个例子里看到的，为了达到目的，我们必须嵌套执行Ajax请求。这让我们的代码变得可读性比较差。在我们必须嵌套使用大量的回调，或者需要一个独立的回调函数需要和另一个函数以同步的方式执行时，我们通常称这种情况为“回调地狱”。\n\n为了让这种情况变好一点，你可以将我上面写的匿名函数提取出来命名。然而，这样改变也没啥帮助，我们仍然发现我们身处于回调地狱中。下面，我们就走进`Deferred`对象和`Promise`对象吧。\n\n## Deferred对象和Promise对象\nDeferred对象可以在执行异步操作的时候使用，比如Ajax请求和动画。在jQuery里，`Promise`对象创建于`Deferred`对象或者`jQuery`对象。它拥有`Deferred`对象下的方法，如：`always()`,`done()`,`fail()`,`state()`,和`then()`。我会在下面介绍这些方法。\n\n如果你是来自原生javascript世界的，你可能会对这两个对象的存在感到很困惑。为什么我们要有两个对象（`Deferred`和`Promise`），而原生Javascript只有一个（`Promise`)？为了解释他们的不同和他们的用例，我在我的书中对他们进行了类比[jQuery in Action, Third Edition](https://www.manning.com/books/jquery-in-action-third-edition)。\n\n一个使用`Deferred`对象的典型情况是，如果你正在编写一个函数去处理异步操作，并且可能会返回一个值（返回一个错误或者不返回值也行）。在这种情况下，你的函数是值的“生产者”，而且你希望阻止用户去改变`Deferred`的状态。当你是这个函数的消费者时，你就要使用`promise`。\n\n为了阐明这个观点，让我们假设你希望实现一个基于promise的 `timeout()`方法(下面是这个[例子的代码](#creatingapromisebasedsettimeoutfunction)。你负责写这个函数，但是必须等到获得一个时间的数字（在这个等待的情况下没有值返回），这让你成为一个“生产者”。你这个函数的“消费者”不需要关心去resolve它或者reject它，“消费者”只需要能够在Deferred执行完成后、失败后、或者进程中添加函数。另外，你想要确保你的“消费者”不能resolve或reject这个Deferred对象。为了达到这个目标，你需要在你创建的`timeoout()`函数中返回`Deferred`的`promise`对象，而不是`Deferred`对象本身。这样做之后，你能确保除了你的`timeout()`函数以外，没有人能够调用`resolve()`和`reject()`方法。\n\n你可以在[StackOverflow question](http://stackoverflow.com/questions/17308172/deferred-versus-promise)了解更多关于jQuery的Deferred对象和Promise对象的区别。\n\n现在你知道这些对象是什么了，让我们来了解一下这些方法的作用。\n\n## Deferred对象的方法\n`Deferred`对象非常灵活，提供了很多方法满足你的需求。它可以被创建为`jQuery.Deferred()`，方法如下：\n```javascript\nvar deferred = jQuery.Deferred();\n```\n或者，你也可以用`$`创建：\n```javascript\nvar deferred = $.Deferred();\n```\n一旦创建，这个`Deferred`对象就暴露了一些方法，除了那些不赞成使用的和被移除的方法，它暴露的方法有：\n\n- `always(callbacks[, callbacks, ..., callbacks]):` 在无论Deferred对象resolved还是rejected的时候都会执行。\n- `done(callbacks[, callbacks, ..., callbacks]):` 当Deferred对象resolved的时候执行。\n- `fail(callbacks[, callbacks, ..., callbacks]):` 当Deferred对象rejected的时候执行。\n- `notify([argument, ..., argument]):` 根据给定的 args参数 调用Deferred对象上进行中的回调 （progressCallbacks）。\n- `notifyWith(context[, argument, ..., argument]):` 根据给定的上下文（context）和args递延调用Deferred对象上进行中的回调（progressCallbacks ）。\n- `progress(callbacks[, callbacks, ..., callbacks])`:当Deferred（延迟）对象生成进度通知时，调用添加处理程序。\n- `promise([target]):` Return a Deferred‘s Promise object.\n- `reject([argument, ..., argument]):` 拒绝Deferred（延迟）对象，并根据给定的args参数调用任何失败回调函数（failCallbacks）。\n- `rejectWith(context[, argument, ..., argument]): `拒绝Deferred（延迟）对象，并根据给定的 context和args参数调用任何失败回调函数（failCallbacks）。\n- `resolve([argument, ..., argument]):` 解决Deferred（延迟）对象，并根据给定的args参数调用任何完成回调函数（doneCallbacks）。\n- `resolveWith(context[, argument, ..., argument]):` 解决Deferred（延迟）对象，并根据给定的 context和args参数调用任何完成回调函数（doneCallbacks）。\n- `state():`确定一个Deferred（延迟）对象的当前状态。\n- `then(resolvedCallback[, rejectedCallback[, progressCallback]]):` 当Deferred（延迟）对象解决，拒绝或仍在进行中时，调用添加处理程序。\n\n通过这些方法的描述，让我们能够更明显地了解到jQuery文档中的术语和ECMAScript标准里的区别。在ECMAScript标准里，一个promise对象被称作resolved是在他完成或者被拒绝的时候。然而，在jQuery文档里，resolved描述的只是在ECMAScript中的完成状态。\n\nDeferred提供了大量的方法，在本篇文章中不能全部介绍到。不过，在下面的内容中，我会展示一些`Deferred`对象和`Promise`对象的使用的例子。首先，我来会用Deferred对象重写一下在[jQuery中的回调](#callbackJquery)中的那段代码，然后我会把“生产者和消费者”的比喻再解释一下。\n\n## 用Deferred对象完成Ajax请求队列\n在这个章节我会展示怎么用Deferred对象和它的一些方法去提高[jQuery中的回调](#callbackJquery)里的那段代码的可读性，在开始探索之前，我们必须要明白我们需要用到哪些方法。\n\n根据我们的需求和上面列出的方法列表，很明显我们可以用`done()`或者`then()`方法去管理成功的状态。由于你们大多数可能已经习惯于使用Javascript的`Promise`对象，在这个例子中，我会选择使用`then()`方法。在这两个方法最重要的一个区别是`then()`方法能够\n将接收到的值作为参数传递给其他在后面调用的`then()`、`done()`、`fail()`或`progress()`方法。\n\n最后的代码：\n```javascript\nvar username = 'testuser';\nvar fileToSearch = 'README.md';\n\n$.getJSON('https://api.github.com/user/' + username + '/repositories')\n    .then(function(repositories) {\n        return repositories[0].name;\n    })\n    .then(function(lastUpdatedRepository) {\n        return $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/files');\n    })\n    .then(function(files) {\n        var README = null;\n\n        for (var i = 0; i < files.length; i++) {\n            if (files[i].name.indexOf(fileToSearch) >= 0) {\n                README = files[i].path;\n\n                break;\n            }\n        }\n\n        return README;\n    })\n    .then(function(README) {\n        return $.getJSON('https://api.github.com/user/' + username + '/repository/' + lastUpdatedRepository + '/file/' + README + '/content');\n    })\n    .then(function(content) {\n        console.log(content);\n    });\n```\n\n正如你看到的，这段代码比之前的可读性好了很多，因为我们能把每一个步骤拆开看，它们都同一级，没有嵌套。\n\n<h2 id=\"creatingapromisebasedsettimeoutfunction\">创造一个基于Promise的setTimeout函数</h2>\n你也许知道，`setTimeout()`能在指定的时间后执行回调函数。它的两个元素（回调函数和时间）都应该作为参数被提供。让我们假设你想要1秒后在控制台打印一段信息。使用`setTimeout()`，你可以达到这个目的：\n\n```javascript\nsetTimeout(\n  function() {\n    console.log('I waited for 1 second!');\n  },\n  1000\n);\n```\n\n正如你所见，第一个参数是一个想要被执行的函数，第二个是多少需要等待的毫秒数。这个函数一向很有用，但是如果你想用通过`Deferred`队列实现呢？\n\n在下面我会告诉你怎么用jQuery提供的`Promise`对象完成一个基于promise的`setTimeout()`函数。\n\n最后的代码：\n```javascript\nfunction timeout(milliseconds) {\n    // Create a new Deferred object\n    var deferred = $.Deferred();\n\n    // Resolve the Deferred after the amount of time specified by milliseconds\n    setTimeout(deferred.resolve, milliseconds);\n\n    // Return the Deferred's Promise object\n    return deferred.promise();\n}\n\ntimeout(1000).then(function() {\n    console.log('I waited for 1 second!');\n});\n```\n我定义了一个`timeout()`函数，包裹了javaScript的原生`setTimeout()`方法。在`timeout()`方法里我创建了一个新的`Deferred`对象去管理异步任务，在`milliseconds`时间后`deferred`对象被设置为resolve状态。在这种情况下，`timeout()`函数是这个值的生产者，所以它创建了`Deferred`对象还返回了`Promise`对象。通过这样，我能确保这个函数的调用者（消费者）不能够resolve或者reject这个`Deferred`对象。事实上，这个调用者只能添加函数去执行，和使用`done()`,`faile()`等方法。\n\n## jQuery 1.x/2.x 与 jQuery 3的区别\n在第一个例子里，我们创建了一段代码去查找一个名为\"README.md\"的文件，但是我们没有处理这个文件没有被找到的情况。这种情况应该被称作失败的情况，当失败发送时，我们可能需要去打断这个队列直接结束。如果这样做的话它会很自然的抛出一个异常，取到这个异常后被fail()这个方法执行，就像你在js里面用的catch()方法一样。\n\n遵循Promises/A和Promises/A+的库（比如jQuery3.x），抛出的异常是被转换为rejection然后调用错误回调函数，比如`fail()`，被捕获的异常会作为参数传递进去。\n\n在jQuery1.x和2.x版本中，未被捕获的异常会终止程序的执行，这些版本下允许抛出的异常冒泡，通常是达到`window.onerror`。如果没有定义函数去处理这个异常，这个异常信息会在控制台显示，而且会中断代码执行。\n\n为了更好的理解他们不同的地方，让我们看看这个例子：\n```javascript\nvar deferred = $.Deferred();\ndeferred\n  .then(function() {\n    throw new Error('An error message');\n  })\n  .then(\n    function() {\n      console.log('First success function');\n    },\n    function() {\n      console.log('First failure function');\n    }\n  )\n  .then(\n    function() {\n      console.log('Second success function');\n    },\n    function() {\n      console.log('Second failure function');\n    }\n  );\n\ndeferred.resolve();\n\n```\n在jQuery3.x版本中，会打印信息\"First failure function\"和\"Second success function\"到控制台。原因就和我上面说的一样，一个抛出的异常会被转变为`rejection`，然后错误处理函数会在这时候被调用。而且，一旦异常被管理到（在这个例子中传递给了第二个`then()`），接下来的成功回调函数会被调用（本例中的第三个`then()`）。\n\n在jQuery1.x和2.x版本中，只有第一个函数（抛出异常的函数）会执行，然后你会看到在控制台输出了\"Uncaught Error: An error message\"。\n\n__jQuery 1.x/2.x__\n<iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/nozege/embed?js,console\" src=\"http://jsbin.com/nozege/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe>\n__jQuery3__\n<iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/kifazi/embed?js,console\" src=\"http://jsbin.com/kifazi/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe>\n\n为了进一步提高它与ECMAScript 2015的兼容性，jQuery3也给`Deferred`和`Promise`对象添加了一个`catch()`方法。它是被定义来处理`Deferred`对象`rejected`或者 它的`Promise`对象处于rejected的情况：\n```javascript\ndeferred.catch(rejectedCallback)\n```\n这个方法只是`then(null,rejectedCallback)`的简写形式。\n\n## 总结\n在这篇文章里，我向你介绍了jQuery对于promises的实现方式。Promises让你不用很麻烦地让异步函数并行起来，也不用在回调函数里嵌套回调函数再嵌套回调函数……\n\n除此之外，我也介绍了jQuery3怎么提升它和原生promise的兼容性。尽管老版本的jQuery和ECMAScript 2015的还有比较明显的不同，`Deferred`对象仍然是一个令人难以置信的强大的工具。作为一个专业的开发者，随着项目难度的增加，你会发现你会经常用到它。\n","slug":"introduction-jquery-deferred-objects","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ewr000der2zhiej50bj","content":"<p>(趁着毕设要求，翻译了一篇文章，顺便放上来。英文不好翻了2天才翻完，/(ㄒoㄒ)/~~如有错误欢迎指正。)<br>原文链接:<a href=\"http://www.sitepoint.com/introduction-jquery-deferred-objects/\" target=\"_blank\" rel=\"external\">An Introduction to jQuery’s Deferred Objects</a></p>\n<p>长久以来，javascript的开发者习惯于使用回调函数去执行某些任务。一个常见的例子就是当某些事件比如<code>click</code>或者<code>keypress</code>执行的时候，通过<code>addEventListener()</code>添加回调函数。这样做的好处是，回调函数很简单，让工作能够很方便地完成，不幸的是，当你的网页变得越来越复杂而且你需要执行许多异步请求时，它们变得越来越难以处理。</p>\n<p>ECMAScript2015引进了一个原生的方法去处理这种情况：promise。如果你不知道什么是promise，你可以读一读这篇文章<a href=\"http://www.sitepoint.com/overview-javascript-promises/\" target=\"_blank\" rel=\"external\">An Overview of JavaScript Promises</a>。jQuery推出了它自己风格的promise，就是 <strong>Deferred对象</strong> 。它在promise被引入ECMAScript之前几年就被引入了jqurey，在这篇文章里，我会讨论一下什么是<code>Deferred</code>对象，还有它解决了什么问题。</p>\n<h2 id=\"一个简单的历史介绍\">一个简单的历史介绍</h2><p><code>Deferred</code>对象在jQuery1.5版本被引入，它能让回调函数成为一个回调队列，继而被链式调用，它还能处理同步或者异步函数的成功或者失败状态。从此以后，它成为了一个课题被讨论和研究，也有一些批评的声音，伴随着批评和它也发生了许多改变。这里有两篇对它的批判性的文章：<a href=\"https://blog.domenic.me/youre-missing-the-point-of-promises/\" target=\"_blank\" rel=\"external\">You’re Missing the Point of Promises</a>和<a href=\"https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/\" target=\"_blank\" rel=\"external\">JavaScript Promises and why jQuery implementation is broken</a>。</p>\n<p>连同<a href=\"http://api.jquery.com/Types/#Promise\" target=\"_blank\" rel=\"external\">Promise对象</a>,Deferred代表了jQuery对于Promises的实现。在jQuery1.X版本和2.x版本里，deferred对象依附于<a href=\"http://wiki.commonjs.org/wiki/Promises/A\" target=\"_blank\" rel=\"external\">the CommonJS Promises/A proposal</a>，这个提案被作为<a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"external\">Promises/A+ proposal</a>的基础，而原生的promises就是在此基础上建立的。正如前面所提到的，jQuery没有依附于 Promises/A+的原因是它在这之前就已经产生了。</p>\n<p>因为jQuery是一个先驱者，还由于向后兼容问题，在原生javascript里使用promise与在jQuery1.x、2.x版本里使用都有一些区别。而且，由于jQuery遵循了一个不同的提案，这个框架和其他实现了promises的框架比如<a href=\"https://github.com/kriskowal/q\" target=\"_blank\" rel=\"external\">the Q library</a>是互不兼容的。</p>\n<p>在即将到来的 <strong>jQuery 3</strong> 版本里，改进了与原生的Promises(在ECMAScript 2015被实现的)的兼容性。虽然有些主要的方法（then())还是由于向后兼容的原因和原生的Promises有些差别，但是其使用习惯已经越来越接近规范标准了。</p>\n<p></p><h2 id=\"callbackJquery\">jQuery中的回调</h2><br>为了理解为什么你需要使用<code>Deferred</code>对象，让我们先讨论一个例子。当你使用jQuery的时候，一定经常使用它的ajax方法去处理异步请求。为了理解这个例子，让我们假设你正在开发一个网页并且正在向Github的API发送Ajax请求。你的目标是收到用户的仓库列表，找到最近更新过的仓库，找到第一个名为’README.md’的文件，最终接收到这个文件的内容。基于以上的描述，你每一个Ajax请求可能都会是在上一个步骤完成的时候发送，换句话说，这些请求必须在一个队列中执行。<p></p>\n<p>让我们把这些描述转换为代码（请注意我没有使用真的Github的API），我们得到以下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> username = <span class=\"string\">'testuser'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> fileToSearch = <span class=\"string\">'README.md'</span>;</div><div class=\"line\"></div><div class=\"line\">$.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repositories'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">repositories</span>) </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">var</span> lastUpdatedRepository = repositories[<span class=\"number\">0</span>].name;</div><div class=\"line\"></div><div class=\"line\">  $.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repository/'</span> + lastUpdatedRepository + <span class=\"string\">'/files'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">files</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> README = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; files.length; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (files[i].name.indexOf(fileToSearch) &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        README = files[i].path;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    $.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repository/'</span> + lastUpdatedRepository + <span class=\"string\">'/file/'</span> + README + <span class=\"string\">'/content'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'The content of the file is: '</span> + content);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>正如你在这个例子里看到的，为了达到目的，我们必须嵌套执行Ajax请求。这让我们的代码变得可读性比较差。在我们必须嵌套使用大量的回调，或者需要一个独立的回调函数需要和另一个函数以同步的方式执行时，我们通常称这种情况为“回调地狱”。</p>\n<p>为了让这种情况变好一点，你可以将我上面写的匿名函数提取出来命名。然而，这样改变也没啥帮助，我们仍然发现我们身处于回调地狱中。下面，我们就走进<code>Deferred</code>对象和<code>Promise</code>对象吧。</p>\n<h2 id=\"Deferred对象和Promise对象\">Deferred对象和Promise对象</h2><p>Deferred对象可以在执行异步操作的时候使用，比如Ajax请求和动画。在jQuery里，<code>Promise</code>对象创建于<code>Deferred</code>对象或者<code>jQuery</code>对象。它拥有<code>Deferred</code>对象下的方法，如：<code>always()</code>,<code>done()</code>,<code>fail()</code>,<code>state()</code>,和<code>then()</code>。我会在下面介绍这些方法。</p>\n<p>如果你是来自原生javascript世界的，你可能会对这两个对象的存在感到很困惑。为什么我们要有两个对象（<code>Deferred</code>和<code>Promise</code>），而原生Javascript只有一个（<code>Promise</code>)？为了解释他们的不同和他们的用例，我在我的书中对他们进行了类比<a href=\"https://www.manning.com/books/jquery-in-action-third-edition\" target=\"_blank\" rel=\"external\">jQuery in Action, Third Edition</a>。</p>\n<p>一个使用<code>Deferred</code>对象的典型情况是，如果你正在编写一个函数去处理异步操作，并且可能会返回一个值（返回一个错误或者不返回值也行）。在这种情况下，你的函数是值的“生产者”，而且你希望阻止用户去改变<code>Deferred</code>的状态。当你是这个函数的消费者时，你就要使用<code>promise</code>。</p>\n<p>为了阐明这个观点，让我们假设你希望实现一个基于promise的 <code>timeout()</code>方法(下面是这个<a href=\"#creatingapromisebasedsettimeoutfunction\">例子的代码</a>。你负责写这个函数，但是必须等到获得一个时间的数字（在这个等待的情况下没有值返回），这让你成为一个“生产者”。你这个函数的“消费者”不需要关心去resolve它或者reject它，“消费者”只需要能够在Deferred执行完成后、失败后、或者进程中添加函数。另外，你想要确保你的“消费者”不能resolve或reject这个Deferred对象。为了达到这个目标，你需要在你创建的<code>timeoout()</code>函数中返回<code>Deferred</code>的<code>promise</code>对象，而不是<code>Deferred</code>对象本身。这样做之后，你能确保除了你的<code>timeout()</code>函数以外，没有人能够调用<code>resolve()</code>和<code>reject()</code>方法。</p>\n<p>你可以在<a href=\"http://stackoverflow.com/questions/17308172/deferred-versus-promise\" target=\"_blank\" rel=\"external\">StackOverflow question</a>了解更多关于jQuery的Deferred对象和Promise对象的区别。</p>\n<p>现在你知道这些对象是什么了，让我们来了解一下这些方法的作用。</p>\n<h2 id=\"Deferred对象的方法\">Deferred对象的方法</h2><p><code>Deferred</code>对象非常灵活，提供了很多方法满足你的需求。它可以被创建为<code>jQuery.Deferred()</code>，方法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> deferred = jQuery.Deferred();</div></pre></td></tr></table></figure></p>\n<p>或者，你也可以用<code>$</code>创建：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> deferred = $.Deferred();</div></pre></td></tr></table></figure></p>\n<p>一旦创建，这个<code>Deferred</code>对象就暴露了一些方法，除了那些不赞成使用的和被移除的方法，它暴露的方法有：</p>\n<ul>\n<li><code>always(callbacks[, callbacks, ..., callbacks]):</code> 在无论Deferred对象resolved还是rejected的时候都会执行。</li>\n<li><code>done(callbacks[, callbacks, ..., callbacks]):</code> 当Deferred对象resolved的时候执行。</li>\n<li><code>fail(callbacks[, callbacks, ..., callbacks]):</code> 当Deferred对象rejected的时候执行。</li>\n<li><code>notify([argument, ..., argument]):</code> 根据给定的 args参数 调用Deferred对象上进行中的回调 （progressCallbacks）。</li>\n<li><code>notifyWith(context[, argument, ..., argument]):</code> 根据给定的上下文（context）和args递延调用Deferred对象上进行中的回调（progressCallbacks ）。</li>\n<li><code>progress(callbacks[, callbacks, ..., callbacks])</code>:当Deferred（延迟）对象生成进度通知时，调用添加处理程序。</li>\n<li><code>promise([target]):</code> Return a Deferred‘s Promise object.</li>\n<li><code>reject([argument, ..., argument]):</code> 拒绝Deferred（延迟）对象，并根据给定的args参数调用任何失败回调函数（failCallbacks）。</li>\n<li><code>rejectWith(context[, argument, ..., argument]):</code>拒绝Deferred（延迟）对象，并根据给定的 context和args参数调用任何失败回调函数（failCallbacks）。</li>\n<li><code>resolve([argument, ..., argument]):</code> 解决Deferred（延迟）对象，并根据给定的args参数调用任何完成回调函数（doneCallbacks）。</li>\n<li><code>resolveWith(context[, argument, ..., argument]):</code> 解决Deferred（延迟）对象，并根据给定的 context和args参数调用任何完成回调函数（doneCallbacks）。</li>\n<li><code>state():</code>确定一个Deferred（延迟）对象的当前状态。</li>\n<li><code>then(resolvedCallback[, rejectedCallback[, progressCallback]]):</code> 当Deferred（延迟）对象解决，拒绝或仍在进行中时，调用添加处理程序。</li>\n</ul>\n<p>通过这些方法的描述，让我们能够更明显地了解到jQuery文档中的术语和ECMAScript标准里的区别。在ECMAScript标准里，一个promise对象被称作resolved是在他完成或者被拒绝的时候。然而，在jQuery文档里，resolved描述的只是在ECMAScript中的完成状态。</p>\n<p>Deferred提供了大量的方法，在本篇文章中不能全部介绍到。不过，在下面的内容中，我会展示一些<code>Deferred</code>对象和<code>Promise</code>对象的使用的例子。首先，我来会用Deferred对象重写一下在<a href=\"#callbackJquery\">jQuery中的回调</a>中的那段代码，然后我会把“生产者和消费者”的比喻再解释一下。</p>\n<h2 id=\"用Deferred对象完成Ajax请求队列\">用Deferred对象完成Ajax请求队列</h2><p>在这个章节我会展示怎么用Deferred对象和它的一些方法去提高<a href=\"#callbackJquery\">jQuery中的回调</a>里的那段代码的可读性，在开始探索之前，我们必须要明白我们需要用到哪些方法。</p>\n<p>根据我们的需求和上面列出的方法列表，很明显我们可以用<code>done()</code>或者<code>then()</code>方法去管理成功的状态。由于你们大多数可能已经习惯于使用Javascript的<code>Promise</code>对象，在这个例子中，我会选择使用<code>then()</code>方法。在这两个方法最重要的一个区别是<code>then()</code>方法能够<br>将接收到的值作为参数传递给其他在后面调用的<code>then()</code>、<code>done()</code>、<code>fail()</code>或<code>progress()</code>方法。</p>\n<p>最后的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> username = <span class=\"string\">'testuser'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> fileToSearch = <span class=\"string\">'README.md'</span>;</div><div class=\"line\"></div><div class=\"line\">$.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repositories'</span>)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">repositories</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> repositories[<span class=\"number\">0</span>].name;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">lastUpdatedRepository</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> $.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repository/'</span> + lastUpdatedRepository + <span class=\"string\">'/files'</span>);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">files</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> README = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; files.length; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (files[i].name.indexOf(fileToSearch) &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                README = files[i].path;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> README;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">README</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> $.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repository/'</span> + lastUpdatedRepository + <span class=\"string\">'/file/'</span> + README + <span class=\"string\">'/content'</span>);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(content);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>正如你看到的，这段代码比之前的可读性好了很多，因为我们能把每一个步骤拆开看，它们都同一级，没有嵌套。</p>\n<p></p><h2 id=\"creatingapromisebasedsettimeoutfunction\">创造一个基于Promise的setTimeout函数</h2><br>你也许知道，<code>setTimeout()</code>能在指定的时间后执行回调函数。它的两个元素（回调函数和时间）都应该作为参数被提供。让我们假设你想要1秒后在控制台打印一段信息。使用<code>setTimeout()</code>，你可以达到这个目的：<p></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I waited for 1 second!'</span>);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"number\">1000</span></div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>正如你所见，第一个参数是一个想要被执行的函数，第二个是多少需要等待的毫秒数。这个函数一向很有用，但是如果你想用通过<code>Deferred</code>队列实现呢？</p>\n<p>在下面我会告诉你怎么用jQuery提供的<code>Promise</code>对象完成一个基于promise的<code>setTimeout()</code>函数。</p>\n<p>最后的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">milliseconds</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Create a new Deferred object</span></div><div class=\"line\">    <span class=\"keyword\">var</span> deferred = $.Deferred();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Resolve the Deferred after the amount of time specified by milliseconds</span></div><div class=\"line\">    setTimeout(deferred.resolve, milliseconds);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Return the Deferred's Promise object</span></div><div class=\"line\">    <span class=\"keyword\">return</span> deferred.promise();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">timeout(<span class=\"number\">1000</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I waited for 1 second!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>我定义了一个<code>timeout()</code>函数，包裹了javaScript的原生<code>setTimeout()</code>方法。在<code>timeout()</code>方法里我创建了一个新的<code>Deferred</code>对象去管理异步任务，在<code>milliseconds</code>时间后<code>deferred</code>对象被设置为resolve状态。在这种情况下，<code>timeout()</code>函数是这个值的生产者，所以它创建了<code>Deferred</code>对象还返回了<code>Promise</code>对象。通过这样，我能确保这个函数的调用者（消费者）不能够resolve或者reject这个<code>Deferred</code>对象。事实上，这个调用者只能添加函数去执行，和使用<code>done()</code>,<code>faile()</code>等方法。</p>\n<h2 id=\"jQuery_1-x/2-x_与_jQuery_3的区别\">jQuery 1.x/2.x 与 jQuery 3的区别</h2><p>在第一个例子里，我们创建了一段代码去查找一个名为”README.md”的文件，但是我们没有处理这个文件没有被找到的情况。这种情况应该被称作失败的情况，当失败发送时，我们可能需要去打断这个队列直接结束。如果这样做的话它会很自然的抛出一个异常，取到这个异常后被fail()这个方法执行，就像你在js里面用的catch()方法一样。</p>\n<p>遵循Promises/A和Promises/A+的库（比如jQuery3.x），抛出的异常是被转换为rejection然后调用错误回调函数，比如<code>fail()</code>，被捕获的异常会作为参数传递进去。</p>\n<p>在jQuery1.x和2.x版本中，未被捕获的异常会终止程序的执行，这些版本下允许抛出的异常冒泡，通常是达到<code>window.onerror</code>。如果没有定义函数去处理这个异常，这个异常信息会在控制台显示，而且会中断代码执行。</p>\n<p>为了更好的理解他们不同的地方，让我们看看这个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> deferred = $.Deferred();</div><div class=\"line\">deferred</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'An error message'</span>);</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .then(</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'First success function'</span>);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'First failure function'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  )</div><div class=\"line\">  .then(</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Second success function'</span>);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Second failure function'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  );</div><div class=\"line\"></div><div class=\"line\">deferred.resolve();</div></pre></td></tr></table></figure></p>\n<p>在jQuery3.x版本中，会打印信息”First failure function”和”Second success function”到控制台。原因就和我上面说的一样，一个抛出的异常会被转变为<code>rejection</code>，然后错误处理函数会在这时候被调用。而且，一旦异常被管理到（在这个例子中传递给了第二个<code>then()</code>），接下来的成功回调函数会被调用（本例中的第三个<code>then()</code>）。</p>\n<p>在jQuery1.x和2.x版本中，只有第一个函数（抛出异常的函数）会执行，然后你会看到在控制台输出了”Uncaught Error: An error message”。</p>\n<p><strong>jQuery 1.x/2.x</strong></p>\n<iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/nozege/embed?js,console\" src=\"http://jsbin.com/nozege/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe><br><strong>jQuery3</strong><br><iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/kifazi/embed?js,console\" src=\"http://jsbin.com/kifazi/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe>\n\n<p>为了进一步提高它与ECMAScript 2015的兼容性，jQuery3也给<code>Deferred</code>和<code>Promise</code>对象添加了一个<code>catch()</code>方法。它是被定义来处理<code>Deferred</code>对象<code>rejected</code>或者 它的<code>Promise</code>对象处于rejected的情况：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">deferred.catch(rejectedCallback)</div></pre></td></tr></table></figure></p>\n<p>这个方法只是<code>then(null,rejectedCallback)</code>的简写形式。</p>\n<h2 id=\"总结\">总结</h2><p>在这篇文章里，我向你介绍了jQuery对于promises的实现方式。Promises让你不用很麻烦地让异步函数并行起来，也不用在回调函数里嵌套回调函数再嵌套回调函数……</p>\n<p>除此之外，我也介绍了jQuery3怎么提升它和原生promise的兼容性。尽管老版本的jQuery和ECMAScript 2015的还有比较明显的不同，<code>Deferred</code>对象仍然是一个令人难以置信的强大的工具。作为一个专业的开发者，随着项目难度的增加，你会发现你会经常用到它。</p>\n","excerpt":"","more":"<p>(趁着毕设要求，翻译了一篇文章，顺便放上来。英文不好翻了2天才翻完，/(ㄒoㄒ)/~~如有错误欢迎指正。)<br>原文链接:<a href=\"http://www.sitepoint.com/introduction-jquery-deferred-objects/\">An Introduction to jQuery’s Deferred Objects</a></p>\n<p>长久以来，javascript的开发者习惯于使用回调函数去执行某些任务。一个常见的例子就是当某些事件比如<code>click</code>或者<code>keypress</code>执行的时候，通过<code>addEventListener()</code>添加回调函数。这样做的好处是，回调函数很简单，让工作能够很方便地完成，不幸的是，当你的网页变得越来越复杂而且你需要执行许多异步请求时，它们变得越来越难以处理。</p>\n<p>ECMAScript2015引进了一个原生的方法去处理这种情况：promise。如果你不知道什么是promise，你可以读一读这篇文章<a href=\"http://www.sitepoint.com/overview-javascript-promises/\">An Overview of JavaScript Promises</a>。jQuery推出了它自己风格的promise，就是 <strong>Deferred对象</strong> 。它在promise被引入ECMAScript之前几年就被引入了jqurey，在这篇文章里，我会讨论一下什么是<code>Deferred</code>对象，还有它解决了什么问题。</p>\n<h2 id=\"一个简单的历史介绍\">一个简单的历史介绍</h2><p><code>Deferred</code>对象在jQuery1.5版本被引入，它能让回调函数成为一个回调队列，继而被链式调用，它还能处理同步或者异步函数的成功或者失败状态。从此以后，它成为了一个课题被讨论和研究，也有一些批评的声音，伴随着批评和它也发生了许多改变。这里有两篇对它的批判性的文章：<a href=\"https://blog.domenic.me/youre-missing-the-point-of-promises/\">You’re Missing the Point of Promises</a>和<a href=\"https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/\">JavaScript Promises and why jQuery implementation is broken</a>。</p>\n<p>连同<a href=\"http://api.jquery.com/Types/#Promise\">Promise对象</a>,Deferred代表了jQuery对于Promises的实现。在jQuery1.X版本和2.x版本里，deferred对象依附于<a href=\"http://wiki.commonjs.org/wiki/Promises/A\">the CommonJS Promises/A proposal</a>，这个提案被作为<a href=\"https://promisesaplus.com/\">Promises/A+ proposal</a>的基础，而原生的promises就是在此基础上建立的。正如前面所提到的，jQuery没有依附于 Promises/A+的原因是它在这之前就已经产生了。</p>\n<p>因为jQuery是一个先驱者，还由于向后兼容问题，在原生javascript里使用promise与在jQuery1.x、2.x版本里使用都有一些区别。而且，由于jQuery遵循了一个不同的提案，这个框架和其他实现了promises的框架比如<a href=\"https://github.com/kriskowal/q\">the Q library</a>是互不兼容的。</p>\n<p>在即将到来的 <strong>jQuery 3</strong> 版本里，改进了与原生的Promises(在ECMAScript 2015被实现的)的兼容性。虽然有些主要的方法（then())还是由于向后兼容的原因和原生的Promises有些差别，但是其使用习惯已经越来越接近规范标准了。</p>\n<p><h2 id=\"callbackJquery\">jQuery中的回调</h2><br>为了理解为什么你需要使用<code>Deferred</code>对象，让我们先讨论一个例子。当你使用jQuery的时候，一定经常使用它的ajax方法去处理异步请求。为了理解这个例子，让我们假设你正在开发一个网页并且正在向Github的API发送Ajax请求。你的目标是收到用户的仓库列表，找到最近更新过的仓库，找到第一个名为’README.md’的文件，最终接收到这个文件的内容。基于以上的描述，你每一个Ajax请求可能都会是在上一个步骤完成的时候发送，换句话说，这些请求必须在一个队列中执行。</p>\n<p>让我们把这些描述转换为代码（请注意我没有使用真的Github的API），我们得到以下代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> username = <span class=\"string\">'testuser'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> fileToSearch = <span class=\"string\">'README.md'</span>;</div><div class=\"line\"></div><div class=\"line\">$.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repositories'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">repositories</span>) </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">var</span> lastUpdatedRepository = repositories[<span class=\"number\">0</span>].name;</div><div class=\"line\"></div><div class=\"line\">  $.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repository/'</span> + lastUpdatedRepository + <span class=\"string\">'/files'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">files</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> README = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; files.length; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (files[i].name.indexOf(fileToSearch) &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        README = files[i].path;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    $.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repository/'</span> + lastUpdatedRepository + <span class=\"string\">'/file/'</span> + README + <span class=\"string\">'/content'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'The content of the file is: '</span> + content);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>正如你在这个例子里看到的，为了达到目的，我们必须嵌套执行Ajax请求。这让我们的代码变得可读性比较差。在我们必须嵌套使用大量的回调，或者需要一个独立的回调函数需要和另一个函数以同步的方式执行时，我们通常称这种情况为“回调地狱”。</p>\n<p>为了让这种情况变好一点，你可以将我上面写的匿名函数提取出来命名。然而，这样改变也没啥帮助，我们仍然发现我们身处于回调地狱中。下面，我们就走进<code>Deferred</code>对象和<code>Promise</code>对象吧。</p>\n<h2 id=\"Deferred对象和Promise对象\">Deferred对象和Promise对象</h2><p>Deferred对象可以在执行异步操作的时候使用，比如Ajax请求和动画。在jQuery里，<code>Promise</code>对象创建于<code>Deferred</code>对象或者<code>jQuery</code>对象。它拥有<code>Deferred</code>对象下的方法，如：<code>always()</code>,<code>done()</code>,<code>fail()</code>,<code>state()</code>,和<code>then()</code>。我会在下面介绍这些方法。</p>\n<p>如果你是来自原生javascript世界的，你可能会对这两个对象的存在感到很困惑。为什么我们要有两个对象（<code>Deferred</code>和<code>Promise</code>），而原生Javascript只有一个（<code>Promise</code>)？为了解释他们的不同和他们的用例，我在我的书中对他们进行了类比<a href=\"https://www.manning.com/books/jquery-in-action-third-edition\">jQuery in Action, Third Edition</a>。</p>\n<p>一个使用<code>Deferred</code>对象的典型情况是，如果你正在编写一个函数去处理异步操作，并且可能会返回一个值（返回一个错误或者不返回值也行）。在这种情况下，你的函数是值的“生产者”，而且你希望阻止用户去改变<code>Deferred</code>的状态。当你是这个函数的消费者时，你就要使用<code>promise</code>。</p>\n<p>为了阐明这个观点，让我们假设你希望实现一个基于promise的 <code>timeout()</code>方法(下面是这个<a href=\"#creatingapromisebasedsettimeoutfunction\">例子的代码</a>。你负责写这个函数，但是必须等到获得一个时间的数字（在这个等待的情况下没有值返回），这让你成为一个“生产者”。你这个函数的“消费者”不需要关心去resolve它或者reject它，“消费者”只需要能够在Deferred执行完成后、失败后、或者进程中添加函数。另外，你想要确保你的“消费者”不能resolve或reject这个Deferred对象。为了达到这个目标，你需要在你创建的<code>timeoout()</code>函数中返回<code>Deferred</code>的<code>promise</code>对象，而不是<code>Deferred</code>对象本身。这样做之后，你能确保除了你的<code>timeout()</code>函数以外，没有人能够调用<code>resolve()</code>和<code>reject()</code>方法。</p>\n<p>你可以在<a href=\"http://stackoverflow.com/questions/17308172/deferred-versus-promise\">StackOverflow question</a>了解更多关于jQuery的Deferred对象和Promise对象的区别。</p>\n<p>现在你知道这些对象是什么了，让我们来了解一下这些方法的作用。</p>\n<h2 id=\"Deferred对象的方法\">Deferred对象的方法</h2><p><code>Deferred</code>对象非常灵活，提供了很多方法满足你的需求。它可以被创建为<code>jQuery.Deferred()</code>，方法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> deferred = jQuery.Deferred();</div></pre></td></tr></table></figure></p>\n<p>或者，你也可以用<code>$</code>创建：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> deferred = $.Deferred();</div></pre></td></tr></table></figure></p>\n<p>一旦创建，这个<code>Deferred</code>对象就暴露了一些方法，除了那些不赞成使用的和被移除的方法，它暴露的方法有：</p>\n<ul>\n<li><code>always(callbacks[, callbacks, ..., callbacks]):</code> 在无论Deferred对象resolved还是rejected的时候都会执行。</li>\n<li><code>done(callbacks[, callbacks, ..., callbacks]):</code> 当Deferred对象resolved的时候执行。</li>\n<li><code>fail(callbacks[, callbacks, ..., callbacks]):</code> 当Deferred对象rejected的时候执行。</li>\n<li><code>notify([argument, ..., argument]):</code> 根据给定的 args参数 调用Deferred对象上进行中的回调 （progressCallbacks）。</li>\n<li><code>notifyWith(context[, argument, ..., argument]):</code> 根据给定的上下文（context）和args递延调用Deferred对象上进行中的回调（progressCallbacks ）。</li>\n<li><code>progress(callbacks[, callbacks, ..., callbacks])</code>:当Deferred（延迟）对象生成进度通知时，调用添加处理程序。</li>\n<li><code>promise([target]):</code> Return a Deferred‘s Promise object.</li>\n<li><code>reject([argument, ..., argument]):</code> 拒绝Deferred（延迟）对象，并根据给定的args参数调用任何失败回调函数（failCallbacks）。</li>\n<li><code>rejectWith(context[, argument, ..., argument]):</code>拒绝Deferred（延迟）对象，并根据给定的 context和args参数调用任何失败回调函数（failCallbacks）。</li>\n<li><code>resolve([argument, ..., argument]):</code> 解决Deferred（延迟）对象，并根据给定的args参数调用任何完成回调函数（doneCallbacks）。</li>\n<li><code>resolveWith(context[, argument, ..., argument]):</code> 解决Deferred（延迟）对象，并根据给定的 context和args参数调用任何完成回调函数（doneCallbacks）。</li>\n<li><code>state():</code>确定一个Deferred（延迟）对象的当前状态。</li>\n<li><code>then(resolvedCallback[, rejectedCallback[, progressCallback]]):</code> 当Deferred（延迟）对象解决，拒绝或仍在进行中时，调用添加处理程序。</li>\n</ul>\n<p>通过这些方法的描述，让我们能够更明显地了解到jQuery文档中的术语和ECMAScript标准里的区别。在ECMAScript标准里，一个promise对象被称作resolved是在他完成或者被拒绝的时候。然而，在jQuery文档里，resolved描述的只是在ECMAScript中的完成状态。</p>\n<p>Deferred提供了大量的方法，在本篇文章中不能全部介绍到。不过，在下面的内容中，我会展示一些<code>Deferred</code>对象和<code>Promise</code>对象的使用的例子。首先，我来会用Deferred对象重写一下在<a href=\"#callbackJquery\">jQuery中的回调</a>中的那段代码，然后我会把“生产者和消费者”的比喻再解释一下。</p>\n<h2 id=\"用Deferred对象完成Ajax请求队列\">用Deferred对象完成Ajax请求队列</h2><p>在这个章节我会展示怎么用Deferred对象和它的一些方法去提高<a href=\"#callbackJquery\">jQuery中的回调</a>里的那段代码的可读性，在开始探索之前，我们必须要明白我们需要用到哪些方法。</p>\n<p>根据我们的需求和上面列出的方法列表，很明显我们可以用<code>done()</code>或者<code>then()</code>方法去管理成功的状态。由于你们大多数可能已经习惯于使用Javascript的<code>Promise</code>对象，在这个例子中，我会选择使用<code>then()</code>方法。在这两个方法最重要的一个区别是<code>then()</code>方法能够<br>将接收到的值作为参数传递给其他在后面调用的<code>then()</code>、<code>done()</code>、<code>fail()</code>或<code>progress()</code>方法。</p>\n<p>最后的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> username = <span class=\"string\">'testuser'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> fileToSearch = <span class=\"string\">'README.md'</span>;</div><div class=\"line\"></div><div class=\"line\">$.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repositories'</span>)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">repositories</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> repositories[<span class=\"number\">0</span>].name;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">lastUpdatedRepository</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> $.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repository/'</span> + lastUpdatedRepository + <span class=\"string\">'/files'</span>);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">files</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> README = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; files.length; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (files[i].name.indexOf(fileToSearch) &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                README = files[i].path;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> README;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">README</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> $.getJSON(<span class=\"string\">'https://api.github.com/user/'</span> + username + <span class=\"string\">'/repository/'</span> + lastUpdatedRepository + <span class=\"string\">'/file/'</span> + README + <span class=\"string\">'/content'</span>);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(content);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>正如你看到的，这段代码比之前的可读性好了很多，因为我们能把每一个步骤拆开看，它们都同一级，没有嵌套。</p>\n<p><h2 id=\"creatingapromisebasedsettimeoutfunction\">创造一个基于Promise的setTimeout函数</h2><br>你也许知道，<code>setTimeout()</code>能在指定的时间后执行回调函数。它的两个元素（回调函数和时间）都应该作为参数被提供。让我们假设你想要1秒后在控制台打印一段信息。使用<code>setTimeout()</code>，你可以达到这个目的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I waited for 1 second!'</span>);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"number\">1000</span></div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>正如你所见，第一个参数是一个想要被执行的函数，第二个是多少需要等待的毫秒数。这个函数一向很有用，但是如果你想用通过<code>Deferred</code>队列实现呢？</p>\n<p>在下面我会告诉你怎么用jQuery提供的<code>Promise</code>对象完成一个基于promise的<code>setTimeout()</code>函数。</p>\n<p>最后的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">milliseconds</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Create a new Deferred object</span></div><div class=\"line\">    <span class=\"keyword\">var</span> deferred = $.Deferred();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Resolve the Deferred after the amount of time specified by milliseconds</span></div><div class=\"line\">    setTimeout(deferred.resolve, milliseconds);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Return the Deferred's Promise object</span></div><div class=\"line\">    <span class=\"keyword\">return</span> deferred.promise();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">timeout(<span class=\"number\">1000</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I waited for 1 second!'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>我定义了一个<code>timeout()</code>函数，包裹了javaScript的原生<code>setTimeout()</code>方法。在<code>timeout()</code>方法里我创建了一个新的<code>Deferred</code>对象去管理异步任务，在<code>milliseconds</code>时间后<code>deferred</code>对象被设置为resolve状态。在这种情况下，<code>timeout()</code>函数是这个值的生产者，所以它创建了<code>Deferred</code>对象还返回了<code>Promise</code>对象。通过这样，我能确保这个函数的调用者（消费者）不能够resolve或者reject这个<code>Deferred</code>对象。事实上，这个调用者只能添加函数去执行，和使用<code>done()</code>,<code>faile()</code>等方法。</p>\n<h2 id=\"jQuery_1-x/2-x_与_jQuery_3的区别\">jQuery 1.x/2.x 与 jQuery 3的区别</h2><p>在第一个例子里，我们创建了一段代码去查找一个名为”README.md”的文件，但是我们没有处理这个文件没有被找到的情况。这种情况应该被称作失败的情况，当失败发送时，我们可能需要去打断这个队列直接结束。如果这样做的话它会很自然的抛出一个异常，取到这个异常后被fail()这个方法执行，就像你在js里面用的catch()方法一样。</p>\n<p>遵循Promises/A和Promises/A+的库（比如jQuery3.x），抛出的异常是被转换为rejection然后调用错误回调函数，比如<code>fail()</code>，被捕获的异常会作为参数传递进去。</p>\n<p>在jQuery1.x和2.x版本中，未被捕获的异常会终止程序的执行，这些版本下允许抛出的异常冒泡，通常是达到<code>window.onerror</code>。如果没有定义函数去处理这个异常，这个异常信息会在控制台显示，而且会中断代码执行。</p>\n<p>为了更好的理解他们不同的地方，让我们看看这个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> deferred = $.Deferred();</div><div class=\"line\">deferred</div><div class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'An error message'</span>);</div><div class=\"line\">  &#125;)</div><div class=\"line\">  .then(</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'First success function'</span>);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'First failure function'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  )</div><div class=\"line\">  .then(</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Second success function'</span>);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Second failure function'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  );</div><div class=\"line\"></div><div class=\"line\">deferred.resolve();</div></pre></td></tr></table></figure></p>\n<p>在jQuery3.x版本中，会打印信息”First failure function”和”Second success function”到控制台。原因就和我上面说的一样，一个抛出的异常会被转变为<code>rejection</code>，然后错误处理函数会在这时候被调用。而且，一旦异常被管理到（在这个例子中传递给了第二个<code>then()</code>），接下来的成功回调函数会被调用（本例中的第三个<code>then()</code>）。</p>\n<p>在jQuery1.x和2.x版本中，只有第一个函数（抛出异常的函数）会执行，然后你会看到在控制台输出了”Uncaught Error: An error message”。</p>\n<p><strong>jQuery 1.x/2.x</strong></p>\n<iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/nozege/embed?js,console\" src=\"http://jsbin.com/nozege/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe><br><strong>jQuery3</strong><br><iframe class=\"\" id=\"\" data-url=\"http://jsbin.com/kifazi/embed?js,console\" src=\"http://jsbin.com/kifazi/embed?js,console\" style=\"border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 200px;\"></iframe>\n\n<p>为了进一步提高它与ECMAScript 2015的兼容性，jQuery3也给<code>Deferred</code>和<code>Promise</code>对象添加了一个<code>catch()</code>方法。它是被定义来处理<code>Deferred</code>对象<code>rejected</code>或者 它的<code>Promise</code>对象处于rejected的情况：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">deferred.catch(rejectedCallback)</div></pre></td></tr></table></figure></p>\n<p>这个方法只是<code>then(null,rejectedCallback)</code>的简写形式。</p>\n<h2 id=\"总结\">总结</h2><p>在这篇文章里，我向你介绍了jQuery对于promises的实现方式。Promises让你不用很麻烦地让异步函数并行起来，也不用在回调函数里嵌套回调函数再嵌套回调函数……</p>\n<p>除此之外，我也介绍了jQuery3怎么提升它和原生promise的兼容性。尽管老版本的jQuery和ECMAScript 2015的还有比较明显的不同，<code>Deferred</code>对象仍然是一个令人难以置信的强大的工具。作为一个专业的开发者，随着项目难度的增加，你会发现你会经常用到它。</p>\n"},{"title":"node.js学习笔记(十)——工程的结构","date":"2016-01-06T15:16:50.000Z","_content":"### 一、app.js工程的入口\n分析app.js代码：\n<!-- more -->\n```javascript\n//引用模块\n//我们导入了express模块，前面我们通过npm install依赖上了，在这里就可以通过require直接获取\nvar express = require('express');\nvar path = require('path');\nvar favicon = require('serve-favicon');\nvar logger = require('morgan');\nvar cookieParser = require('cookie-parser');\nvar bodyParser = require('body-parser');\nvar debug = require('debug')('myapp:server');\nvar http = require('http');\n//routes是一个文件夹形式的本地模块，即/routes/index.\nvar routes = require('./routes/index');\nvar users = require('./routes/users');\n//实例化express对象\nvar app = express();\n//配置app的参数和启用中间件 见注1 注2\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\napp.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));\napp.use(logger('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/', routes);\napp.use('/users', users);\n//错误处理中间件\napp.use(function(req, res, next) {\n  var err = new Error('Not Found');\n  err.status = 404;\n  next(err);\n});\napp.use(function(err, req, res, next) {\n  res.status(err.status || 500);\n  res.render('error', {\n    message: err.message,\n    error: {}\n  });\n});\n//开发模式下\nif (app.get('env') === 'development') {\n  app.use(function(err, req, res, next) {\n    res.status(err.status || 500);\n    res.render('error', {\n      message: err.message,\n      error: err\n    });\n  });\n}\n\n//Get port from environment and store in Express.\nvar port = normalizePort(process.env.PORT || '3000');\napp.set('port', port);\n\n//创建http服务\nvar server = http.createServer(app);\n//Listen on provided port, on all network interfaces.\nserver.listen(port);\nserver.on('error', onError);\nserver.on('listening', onListening);\n//Normalize a port into a number, string, or false.\nfunction normalizePort(val) {\n  var port = parseInt(val, 10);\n  if (isNaN(port)) {\n    // named pipe\n    return val;\n  }\n  if (port >= 0) {\n    // port number\n    return port;\n  }\n  return false;\n}\n//Event listener for HTTP server \"error\" event.\nfunction onError(error) {\n  if (error.syscall !== 'listen') {\n    throw error;\n  }\n  var bind = typeof port === 'string'\n    ? 'Pipe ' + port\n    : 'Port ' + port;\n  // handle specific listen errors with friendly messages\n  switch (error.code) {\n    case 'EACCES':\n      console.error(bind + ' requires elevated privileges');\n      process.exit(1);\n      break;\n    case 'EADDRINUSE':\n      console.error(bind + ' is already in use');\n      process.exit(1);\n      break;\n    default:\n      throw error;\n  }\n}\n//Event listener for HTTP server \"listening\" event.\nfunction onListening() {\n  var addr = server.address();\n  var bind = typeof addr === 'string'\n    ? 'pipe ' + addr\n    : 'port ' + addr.port;\n  debug('Listening on ' + bind);\n}\n\nmodule.exports = app;\n\n```\n\n注1. app.set是一个Express()的参数设置工具，接受一个键(key)和一个值(value)，可以用的参数如下：\n\n|参数|用途|\n|--|--|\n|basepath|基础机制，通常用于res.redirect()跳转|\n|port|指定的端口|\n|view|视图文件目录，存放模板文件|\n|view engine|视图模块引擎（如ejs jade）|\n|view options|全局视图参数对象|\n|view cache|启用视图缓存|\n|case sensitive routes|路径区分大小写|\n|strict routing|严格路径，启用后不会忽略路径末尾的\"/\"|\n|jsonp callback|开启透明的jsonp支持|\n更多请见[api文档](http://www.expressjs.com.cn/4x/api.html#app.set)\n\n注2. 老版本Express依赖于connect，connect更加短小精悍，是一个偏向基础设施的框架，提供了大量的中间件，可以通过app.use()启用。\n从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 [中间件列表](https://github.com/senchalabs/connect#middleware)。\n[中间件](http://www.expressjs.com.cn/guide/using-middleware.html)：一系列的组件连接到一起，然后让http的请求一次流过这些组件。这些被connect串联起来的组件被称为中间件。\n\n### 二、routes/index.js\nroutes/index.js是路由文件,相当于控制器，用于组织展示的内容。\napp.js中通过`app.use('/',routes)`将'/'路径映射到routes/index.js函数下，交由其处理。\n```javascript\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'cky1' });\n});\n\nmodule.exports = router;\n```\t\n\n### 三、index.ejs模板文件\n它的基础是HTML语言，其中包含了`<%=title%>，功能是显示引用的变量，即通过render传过来的第二个参数的属性。","source":"_posts/nodeJsStudy10.md","raw":"title: node.js学习笔记(十)——工程的结构\ndate: 2016-01-06 23:16:50\ntags: node.js学习笔记\n---\n### 一、app.js工程的入口\n分析app.js代码：\n<!-- more -->\n```javascript\n//引用模块\n//我们导入了express模块，前面我们通过npm install依赖上了，在这里就可以通过require直接获取\nvar express = require('express');\nvar path = require('path');\nvar favicon = require('serve-favicon');\nvar logger = require('morgan');\nvar cookieParser = require('cookie-parser');\nvar bodyParser = require('body-parser');\nvar debug = require('debug')('myapp:server');\nvar http = require('http');\n//routes是一个文件夹形式的本地模块，即/routes/index.\nvar routes = require('./routes/index');\nvar users = require('./routes/users');\n//实例化express对象\nvar app = express();\n//配置app的参数和启用中间件 见注1 注2\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\napp.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));\napp.use(logger('dev'));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(cookieParser());\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.use('/', routes);\napp.use('/users', users);\n//错误处理中间件\napp.use(function(req, res, next) {\n  var err = new Error('Not Found');\n  err.status = 404;\n  next(err);\n});\napp.use(function(err, req, res, next) {\n  res.status(err.status || 500);\n  res.render('error', {\n    message: err.message,\n    error: {}\n  });\n});\n//开发模式下\nif (app.get('env') === 'development') {\n  app.use(function(err, req, res, next) {\n    res.status(err.status || 500);\n    res.render('error', {\n      message: err.message,\n      error: err\n    });\n  });\n}\n\n//Get port from environment and store in Express.\nvar port = normalizePort(process.env.PORT || '3000');\napp.set('port', port);\n\n//创建http服务\nvar server = http.createServer(app);\n//Listen on provided port, on all network interfaces.\nserver.listen(port);\nserver.on('error', onError);\nserver.on('listening', onListening);\n//Normalize a port into a number, string, or false.\nfunction normalizePort(val) {\n  var port = parseInt(val, 10);\n  if (isNaN(port)) {\n    // named pipe\n    return val;\n  }\n  if (port >= 0) {\n    // port number\n    return port;\n  }\n  return false;\n}\n//Event listener for HTTP server \"error\" event.\nfunction onError(error) {\n  if (error.syscall !== 'listen') {\n    throw error;\n  }\n  var bind = typeof port === 'string'\n    ? 'Pipe ' + port\n    : 'Port ' + port;\n  // handle specific listen errors with friendly messages\n  switch (error.code) {\n    case 'EACCES':\n      console.error(bind + ' requires elevated privileges');\n      process.exit(1);\n      break;\n    case 'EADDRINUSE':\n      console.error(bind + ' is already in use');\n      process.exit(1);\n      break;\n    default:\n      throw error;\n  }\n}\n//Event listener for HTTP server \"listening\" event.\nfunction onListening() {\n  var addr = server.address();\n  var bind = typeof addr === 'string'\n    ? 'pipe ' + addr\n    : 'port ' + addr.port;\n  debug('Listening on ' + bind);\n}\n\nmodule.exports = app;\n\n```\n\n注1. app.set是一个Express()的参数设置工具，接受一个键(key)和一个值(value)，可以用的参数如下：\n\n|参数|用途|\n|--|--|\n|basepath|基础机制，通常用于res.redirect()跳转|\n|port|指定的端口|\n|view|视图文件目录，存放模板文件|\n|view engine|视图模块引擎（如ejs jade）|\n|view options|全局视图参数对象|\n|view cache|启用视图缓存|\n|case sensitive routes|路径区分大小写|\n|strict routing|严格路径，启用后不会忽略路径末尾的\"/\"|\n|jsonp callback|开启透明的jsonp支持|\n更多请见[api文档](http://www.expressjs.com.cn/4x/api.html#app.set)\n\n注2. 老版本Express依赖于connect，connect更加短小精悍，是一个偏向基础设施的框架，提供了大量的中间件，可以通过app.use()启用。\n从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 [中间件列表](https://github.com/senchalabs/connect#middleware)。\n[中间件](http://www.expressjs.com.cn/guide/using-middleware.html)：一系列的组件连接到一起，然后让http的请求一次流过这些组件。这些被connect串联起来的组件被称为中间件。\n\n### 二、routes/index.js\nroutes/index.js是路由文件,相当于控制器，用于组织展示的内容。\napp.js中通过`app.use('/',routes)`将'/'路径映射到routes/index.js函数下，交由其处理。\n```javascript\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'cky1' });\n});\n\nmodule.exports = router;\n```\t\n\n### 三、index.ejs模板文件\n它的基础是HTML语言，其中包含了`<%=title%>，功能是显示引用的变量，即通过render传过来的第二个参数的属性。","slug":"nodeJsStudy10","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ewt000fer2znet7nmgk","content":"<h3 id=\"一、app-js工程的入口\">一、app.js工程的入口</h3><p>分析app.js代码：<br><a id=\"more\"></a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//引用模块</span></div><div class=\"line\"><span class=\"comment\">//我们导入了express模块，前面我们通过npm install依赖上了，在这里就可以通过require直接获取</span></div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> favicon = <span class=\"built_in\">require</span>(<span class=\"string\">'serve-favicon'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> logger = <span class=\"built_in\">require</span>(<span class=\"string\">'morgan'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> cookieParser = <span class=\"built_in\">require</span>(<span class=\"string\">'cookie-parser'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> debug = <span class=\"built_in\">require</span>(<span class=\"string\">'debug'</span>)(<span class=\"string\">'myapp:server'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"comment\">//routes是一个文件夹形式的本地模块，即/routes/index.</span></div><div class=\"line\"><span class=\"keyword\">var</span> routes = <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/index'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> users = <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/users'</span>);</div><div class=\"line\"><span class=\"comment\">//实例化express对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> app = express();</div><div class=\"line\"><span class=\"comment\">//配置app的参数和启用中间件 见注1 注2</span></div><div class=\"line\">app.set(<span class=\"string\">'views'</span>, path.join(__dirname, <span class=\"string\">'views'</span>));</div><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>);</div><div class=\"line\">app.use(favicon(path.join(__dirname, <span class=\"string\">'public'</span>, <span class=\"string\">'favicon.ico'</span>)));</div><div class=\"line\">app.use(logger(<span class=\"string\">'dev'</span>));</div><div class=\"line\">app.use(bodyParser.json());</div><div class=\"line\">app.use(bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;));</div><div class=\"line\">app.use(cookieParser());</div><div class=\"line\">app.use(express.static(path.join(__dirname, <span class=\"string\">'public'</span>)));</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"string\">'/'</span>, routes);</div><div class=\"line\">app.use(<span class=\"string\">'/users'</span>, users);</div><div class=\"line\"><span class=\"comment\">//错误处理中间件</span></div><div class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Not Found'</span>);</div><div class=\"line\">  err.status = <span class=\"number\">404</span>;</div><div class=\"line\">  next(err);</div><div class=\"line\">&#125;);</div><div class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</div><div class=\"line\">  res.status(err.status || <span class=\"number\">500</span>);</div><div class=\"line\">  res.render(<span class=\"string\">'error'</span>, &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: err.message,</div><div class=\"line\">    <span class=\"attr\">error</span>: &#123;&#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//开发模式下</span></div><div class=\"line\"><span class=\"keyword\">if</span> (app.get(<span class=\"string\">'env'</span>) === <span class=\"string\">'development'</span>) &#123;</div><div class=\"line\">  app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</div><div class=\"line\">    res.status(err.status || <span class=\"number\">500</span>);</div><div class=\"line\">    res.render(<span class=\"string\">'error'</span>, &#123;</div><div class=\"line\">      <span class=\"attr\">message</span>: err.message,</div><div class=\"line\">      <span class=\"attr\">error</span>: err</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Get port from environment and store in Express.</span></div><div class=\"line\"><span class=\"keyword\">var</span> port = normalizePort(process.env.PORT || <span class=\"string\">'3000'</span>);</div><div class=\"line\">app.set(<span class=\"string\">'port'</span>, port);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建http服务</span></div><div class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(app);</div><div class=\"line\"><span class=\"comment\">//Listen on provided port, on all network interfaces.</span></div><div class=\"line\">server.listen(port);</div><div class=\"line\">server.on(<span class=\"string\">'error'</span>, onError);</div><div class=\"line\">server.on(<span class=\"string\">'listening'</span>, onListening);</div><div class=\"line\"><span class=\"comment\">//Normalize a port into a number, string, or false.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalizePort</span>(<span class=\"params\">val</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> port = <span class=\"built_in\">parseInt</span>(val, <span class=\"number\">10</span>);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">isNaN</span>(port)) &#123;</div><div class=\"line\">    <span class=\"comment\">// named pipe</span></div><div class=\"line\">    <span class=\"keyword\">return</span> val;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (port &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// port number</span></div><div class=\"line\">    <span class=\"keyword\">return</span> port;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Event listener for HTTP server \"error\" event.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onError</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error.syscall !== <span class=\"string\">'listen'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> error;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">var</span> bind = <span class=\"keyword\">typeof</span> port === <span class=\"string\">'string'</span></div><div class=\"line\">    ? <span class=\"string\">'Pipe '</span> + port</div><div class=\"line\">    : <span class=\"string\">'Port '</span> + port;</div><div class=\"line\">  <span class=\"comment\">// handle specific listen errors with friendly messages</span></div><div class=\"line\">  <span class=\"keyword\">switch</span> (error.code) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'EACCES'</span>:</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(bind + <span class=\"string\">' requires elevated privileges'</span>);</div><div class=\"line\">      process.exit(<span class=\"number\">1</span>);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'EADDRINUSE'</span>:</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(bind + <span class=\"string\">' is already in use'</span>);</div><div class=\"line\">      process.exit(<span class=\"number\">1</span>);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">      <span class=\"keyword\">throw</span> error;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Event listener for HTTP server \"listening\" event.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onListening</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> addr = server.address();</div><div class=\"line\">  <span class=\"keyword\">var</span> bind = <span class=\"keyword\">typeof</span> addr === <span class=\"string\">'string'</span></div><div class=\"line\">    ? <span class=\"string\">'pipe '</span> + addr</div><div class=\"line\">    : <span class=\"string\">'port '</span> + addr.port;</div><div class=\"line\">  debug(<span class=\"string\">'Listening on '</span> + bind);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = app;</div></pre></td></tr></table></figure></p>\n<p>注1. app.set是一个Express()的参数设置工具，接受一个键(key)和一个值(value)，可以用的参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>basepath</td>\n<td>基础机制，通常用于res.redirect()跳转</td>\n</tr>\n<tr>\n<td>port</td>\n<td>指定的端口</td>\n</tr>\n<tr>\n<td>view</td>\n<td>视图文件目录，存放模板文件</td>\n</tr>\n<tr>\n<td>view engine</td>\n<td>视图模块引擎（如ejs jade）</td>\n</tr>\n<tr>\n<td>view options</td>\n<td>全局视图参数对象</td>\n</tr>\n<tr>\n<td>view cache</td>\n<td>启用视图缓存</td>\n</tr>\n<tr>\n<td>case sensitive routes</td>\n<td>路径区分大小写</td>\n</tr>\n<tr>\n<td>strict routing</td>\n<td>严格路径，启用后不会忽略路径末尾的”/“</td>\n</tr>\n<tr>\n<td>jsonp callback</td>\n<td>开启透明的jsonp支持</td>\n</tr>\n</tbody>\n</table>\n<p>更多请见<a href=\"http://www.expressjs.com.cn/4x/api.html#app.set\" target=\"_blank\" rel=\"external\">api文档</a></p>\n<p>注2. 老版本Express依赖于connect，connect更加短小精悍，是一个偏向基础设施的框架，提供了大量的中间件，可以通过app.use()启用。<br>从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 <a href=\"https://github.com/senchalabs/connect#middleware\" target=\"_blank\" rel=\"external\">中间件列表</a>。<br><a href=\"http://www.expressjs.com.cn/guide/using-middleware.html\" target=\"_blank\" rel=\"external\">中间件</a>：一系列的组件连接到一起，然后让http的请求一次流过这些组件。这些被connect串联起来的组件被称为中间件。</p>\n<h3 id=\"二、routes/index-js\">二、routes/index.js</h3><p>routes/index.js是路由文件,相当于控制器，用于组织展示的内容。<br>app.js中通过<code>app.use(&#39;/&#39;,routes)</code>将’/‘路径映射到routes/index.js函数下，交由其处理。</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);\n<span class=\"keyword\">var</span> router = express.Router();\n\n<span class=\"comment\">/* GET home page. */</span>\nrouter.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>{\n  res.render(<span class=\"string\">'index'</span>, { title: <span class=\"string\">'cky1'</span> });\n});\n\n<span class=\"built_in\">module</span>.exports = router;\n</code></pre>\n<h3 id=\"三、index-ejs模板文件\">三、index.ejs模板文件</h3><p>它的基础是HTML语言，其中包含了`&lt;%=title%&gt;，功能是显示引用的变量，即通过render传过来的第二个参数的属性。</p>\n","excerpt":"<h3 id=\"一、app-js工程的入口\">一、app.js工程的入口</h3><p>分析app.js代码：<br>","more":"<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//引用模块</span></div><div class=\"line\"><span class=\"comment\">//我们导入了express模块，前面我们通过npm install依赖上了，在这里就可以通过require直接获取</span></div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> favicon = <span class=\"built_in\">require</span>(<span class=\"string\">'serve-favicon'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> logger = <span class=\"built_in\">require</span>(<span class=\"string\">'morgan'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> cookieParser = <span class=\"built_in\">require</span>(<span class=\"string\">'cookie-parser'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> debug = <span class=\"built_in\">require</span>(<span class=\"string\">'debug'</span>)(<span class=\"string\">'myapp:server'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"comment\">//routes是一个文件夹形式的本地模块，即/routes/index.</span></div><div class=\"line\"><span class=\"keyword\">var</span> routes = <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/index'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> users = <span class=\"built_in\">require</span>(<span class=\"string\">'./routes/users'</span>);</div><div class=\"line\"><span class=\"comment\">//实例化express对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> app = express();</div><div class=\"line\"><span class=\"comment\">//配置app的参数和启用中间件 见注1 注2</span></div><div class=\"line\">app.set(<span class=\"string\">'views'</span>, path.join(__dirname, <span class=\"string\">'views'</span>));</div><div class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'ejs'</span>);</div><div class=\"line\">app.use(favicon(path.join(__dirname, <span class=\"string\">'public'</span>, <span class=\"string\">'favicon.ico'</span>)));</div><div class=\"line\">app.use(logger(<span class=\"string\">'dev'</span>));</div><div class=\"line\">app.use(bodyParser.json());</div><div class=\"line\">app.use(bodyParser.urlencoded(&#123; <span class=\"attr\">extended</span>: <span class=\"literal\">false</span> &#125;));</div><div class=\"line\">app.use(cookieParser());</div><div class=\"line\">app.use(express.static(path.join(__dirname, <span class=\"string\">'public'</span>)));</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"string\">'/'</span>, routes);</div><div class=\"line\">app.use(<span class=\"string\">'/users'</span>, users);</div><div class=\"line\"><span class=\"comment\">//错误处理中间件</span></div><div class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Not Found'</span>);</div><div class=\"line\">  err.status = <span class=\"number\">404</span>;</div><div class=\"line\">  next(err);</div><div class=\"line\">&#125;);</div><div class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</div><div class=\"line\">  res.status(err.status || <span class=\"number\">500</span>);</div><div class=\"line\">  res.render(<span class=\"string\">'error'</span>, &#123;</div><div class=\"line\">    <span class=\"attr\">message</span>: err.message,</div><div class=\"line\">    <span class=\"attr\">error</span>: &#123;&#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//开发模式下</span></div><div class=\"line\"><span class=\"keyword\">if</span> (app.get(<span class=\"string\">'env'</span>) === <span class=\"string\">'development'</span>) &#123;</div><div class=\"line\">  app.use(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, req, res, next</span>) </span>&#123;</div><div class=\"line\">    res.status(err.status || <span class=\"number\">500</span>);</div><div class=\"line\">    res.render(<span class=\"string\">'error'</span>, &#123;</div><div class=\"line\">      <span class=\"attr\">message</span>: err.message,</div><div class=\"line\">      <span class=\"attr\">error</span>: err</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Get port from environment and store in Express.</span></div><div class=\"line\"><span class=\"keyword\">var</span> port = normalizePort(process.env.PORT || <span class=\"string\">'3000'</span>);</div><div class=\"line\">app.set(<span class=\"string\">'port'</span>, port);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建http服务</span></div><div class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(app);</div><div class=\"line\"><span class=\"comment\">//Listen on provided port, on all network interfaces.</span></div><div class=\"line\">server.listen(port);</div><div class=\"line\">server.on(<span class=\"string\">'error'</span>, onError);</div><div class=\"line\">server.on(<span class=\"string\">'listening'</span>, onListening);</div><div class=\"line\"><span class=\"comment\">//Normalize a port into a number, string, or false.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalizePort</span>(<span class=\"params\">val</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> port = <span class=\"built_in\">parseInt</span>(val, <span class=\"number\">10</span>);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">isNaN</span>(port)) &#123;</div><div class=\"line\">    <span class=\"comment\">// named pipe</span></div><div class=\"line\">    <span class=\"keyword\">return</span> val;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (port &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// port number</span></div><div class=\"line\">    <span class=\"keyword\">return</span> port;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Event listener for HTTP server \"error\" event.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onError</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error.syscall !== <span class=\"string\">'listen'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> error;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">var</span> bind = <span class=\"keyword\">typeof</span> port === <span class=\"string\">'string'</span></div><div class=\"line\">    ? <span class=\"string\">'Pipe '</span> + port</div><div class=\"line\">    : <span class=\"string\">'Port '</span> + port;</div><div class=\"line\">  <span class=\"comment\">// handle specific listen errors with friendly messages</span></div><div class=\"line\">  <span class=\"keyword\">switch</span> (error.code) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'EACCES'</span>:</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(bind + <span class=\"string\">' requires elevated privileges'</span>);</div><div class=\"line\">      process.exit(<span class=\"number\">1</span>);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'EADDRINUSE'</span>:</div><div class=\"line\">      <span class=\"built_in\">console</span>.error(bind + <span class=\"string\">' is already in use'</span>);</div><div class=\"line\">      process.exit(<span class=\"number\">1</span>);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">      <span class=\"keyword\">throw</span> error;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Event listener for HTTP server \"listening\" event.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onListening</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> addr = server.address();</div><div class=\"line\">  <span class=\"keyword\">var</span> bind = <span class=\"keyword\">typeof</span> addr === <span class=\"string\">'string'</span></div><div class=\"line\">    ? <span class=\"string\">'pipe '</span> + addr</div><div class=\"line\">    : <span class=\"string\">'port '</span> + addr.port;</div><div class=\"line\">  debug(<span class=\"string\">'Listening on '</span> + bind);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = app;</div></pre></td></tr></table></figure></p>\n<p>注1. app.set是一个Express()的参数设置工具，接受一个键(key)和一个值(value)，可以用的参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>basepath</td>\n<td>基础机制，通常用于res.redirect()跳转</td>\n</tr>\n<tr>\n<td>port</td>\n<td>指定的端口</td>\n</tr>\n<tr>\n<td>view</td>\n<td>视图文件目录，存放模板文件</td>\n</tr>\n<tr>\n<td>view engine</td>\n<td>视图模块引擎（如ejs jade）</td>\n</tr>\n<tr>\n<td>view options</td>\n<td>全局视图参数对象</td>\n</tr>\n<tr>\n<td>view cache</td>\n<td>启用视图缓存</td>\n</tr>\n<tr>\n<td>case sensitive routes</td>\n<td>路径区分大小写</td>\n</tr>\n<tr>\n<td>strict routing</td>\n<td>严格路径，启用后不会忽略路径末尾的”/“</td>\n</tr>\n<tr>\n<td>jsonp callback</td>\n<td>开启透明的jsonp支持</td>\n</tr>\n</tbody>\n</table>\n<p>更多请见<a href=\"http://www.expressjs.com.cn/4x/api.html#app.set\">api文档</a></p>\n<p>注2. 老版本Express依赖于connect，connect更加短小精悍，是一个偏向基础设施的框架，提供了大量的中间件，可以通过app.use()启用。<br>从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 <a href=\"https://github.com/senchalabs/connect#middleware\">中间件列表</a>。<br><a href=\"http://www.expressjs.com.cn/guide/using-middleware.html\">中间件</a>：一系列的组件连接到一起，然后让http的请求一次流过这些组件。这些被connect串联起来的组件被称为中间件。</p>\n<h3 id=\"二、routes/index-js\">二、routes/index.js</h3><p>routes/index.js是路由文件,相当于控制器，用于组织展示的内容。<br>app.js中通过<code>app.use(&#39;/&#39;,routes)</code>将’/‘路径映射到routes/index.js函数下，交由其处理。</p>\n<pre><code class=\"javascript\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);\n<span class=\"keyword\">var</span> router = express.Router();\n\n<span class=\"comment\">/* GET home page. */</span>\nrouter.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>{\n  res.render(<span class=\"string\">'index'</span>, { title: <span class=\"string\">'cky1'</span> });\n});\n\n<span class=\"built_in\">module</span>.exports = router;\n</code></pre>\n<h3 id=\"三、index-ejs模板文件\">三、index.ejs模板文件</h3><p>它的基础是HTML语言，其中包含了`&lt;%=title%&gt;，功能是显示引用的变量，即通过render传过来的第二个参数的属性。</p>"},{"title":"node.js学习笔记(十一)——路由控制","date":"2016-01-07T06:08:50.000Z","_content":"### 一、工作原理\n当访问http://localhost:3000， 浏览器会向服务器发送请求，包括请求的方法、路径、HTTP协议版本和请求头信息。app会解析请求的路径，调用相应的逻辑，route/index.js中有 `router.get('/',function(){})`通过`res.render('index',{title:\"cky\"})`调用视图模板index，传递title变量，最终生成HTML页面，返回给浏览器。\n浏览器收到内容后，通过分析需要获取/stylesheet/style.css，因此会再次向服务器发起请求，app.js并没有一个路由指派到/stylesheets/style.css，但app通过`app.use(express.static(__dirname+'/public'))`配置了静态文件服务器，因此会定向到app.js所在目录下的/public/stylesheets/style.css拿取这个文件。\n\n这是一个典型的MVC架构，浏览器发送请求，由路由控制接收，根据不同的路径定向到不同的服务器，控制器处理用户具体的请求，可能会访问数据库中的对象，即模型部分，生成视图的HTML，最后再由控制器返回给浏览器，完成一次请求。\n\n### 二、创建路由规则\n当我们在浏览器访问http://localhost:3000/cky 的时候，服务器响应头返回404 NOT FOUND的错误，这是因为/cky是一个不存在的路由规则，而且它也不是一个public目录下的文件，所以响应404。\n假设我们创建一个/cky的路由规则\n```javascript\nrouter.get('/cky', function(req, res, next) {\n  res.send(\"cky route\");\n});\n\n```\n即可访问。\n服务器开始监听之前，设置好了所有的路由规则，当请求到来时直接分配到相应的函数，app.get是路由规则创建函数。\n\n### 三、路径匹配\n上面讲到了为固定的路径设置路由规则，Express还提供了更高级的路径匹配模式。\n1.\n```javascript\nrouter.get('/user/:username',function(req,res){\n    res.send('user:' +req.params.username);\n});\n```\n访问结果：\n![](http://i4.tietuku.com/52a6b8b573c8450b.jpg)\n路径规则/user/username会自动编译成正则表达式，类似于\\/user\\/([^\\/]+)\\/?这样的形式，路径参数可以在相应函数中通过req.params的属性访问。\n\n2. 路径规则同样支持javascript正则表达式，例如`router.get(\\/user\\/([^\\/]+)\\/?,callback)`这样的好处在于可以定义更加复杂的路径规则，不同之处是配置的参数是匿名的，因此需要通过req.params[0]这样的形式访问。\n\n### 四、REST风格的路由规则\nExpress支持REST风格的请求方式，REST意思是表征状态转移，它是一种基于HTTP协议的网络应用的接口风格，充分利用HTTP的方法实现了统一风格的接口服务，HTTP协议定义了以下8个标准方法：\n\n|请求方法|用途|\n|---|---|\n|GET|请求获取的资源 获取|\n|POST|向指定资源提交数据 新增|\n|DELETE|请求服务器删除指定资源 删除|\n|PUT|请求服务器存储一个资源 更新|\n|HEAD|请求指定资源的响应头|\n|TRACE|回显服务器数到的请求，主要用户测试或诊断|\n|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。|\n|OPTIONS|返回服务器支持HTTP请求方法|\n\nExpress对每种HTTP请求方法都设计了不同的路由绑定函数 \n- GET : app.get(path,callback);\n- POST: app.post(path,callback);\n- PUT : app.put(path,callback);\n- DELETE: app.delete(path,callback);\n...\n...\n所有方法 app.all(path,callback);\napp.all函数，它支持把所有的请求方法绑定到同一个相应函数，是一个非常灵活的函数。\n\n### 五、控制权转移\nExpress支持同一路径绑定多个响应函数\n```javascript\napp.all('test/:user',function(req,res,next){\n    res.send(\"all method is call\");\n    next();\n});\n\napp.get('/test/:user',function(req,res){\n    res.send(\"user: \" + req.params.user); \n});\n```\n但是我们访问都只会返回一次。\nExpress提供了路由控制权转移的方法，即next()函数，通过调用则将控制权交给后面的规则","source":"_posts/nodeJsStudy11.md","raw":"title: node.js学习笔记(十一)——路由控制\ndate: 2016-01-07 14:08:50\ntags: node.js学习笔记\n---\n### 一、工作原理\n当访问http://localhost:3000， 浏览器会向服务器发送请求，包括请求的方法、路径、HTTP协议版本和请求头信息。app会解析请求的路径，调用相应的逻辑，route/index.js中有 `router.get('/',function(){})`通过`res.render('index',{title:\"cky\"})`调用视图模板index，传递title变量，最终生成HTML页面，返回给浏览器。\n浏览器收到内容后，通过分析需要获取/stylesheet/style.css，因此会再次向服务器发起请求，app.js并没有一个路由指派到/stylesheets/style.css，但app通过`app.use(express.static(__dirname+'/public'))`配置了静态文件服务器，因此会定向到app.js所在目录下的/public/stylesheets/style.css拿取这个文件。\n\n这是一个典型的MVC架构，浏览器发送请求，由路由控制接收，根据不同的路径定向到不同的服务器，控制器处理用户具体的请求，可能会访问数据库中的对象，即模型部分，生成视图的HTML，最后再由控制器返回给浏览器，完成一次请求。\n\n### 二、创建路由规则\n当我们在浏览器访问http://localhost:3000/cky 的时候，服务器响应头返回404 NOT FOUND的错误，这是因为/cky是一个不存在的路由规则，而且它也不是一个public目录下的文件，所以响应404。\n假设我们创建一个/cky的路由规则\n```javascript\nrouter.get('/cky', function(req, res, next) {\n  res.send(\"cky route\");\n});\n\n```\n即可访问。\n服务器开始监听之前，设置好了所有的路由规则，当请求到来时直接分配到相应的函数，app.get是路由规则创建函数。\n\n### 三、路径匹配\n上面讲到了为固定的路径设置路由规则，Express还提供了更高级的路径匹配模式。\n1.\n```javascript\nrouter.get('/user/:username',function(req,res){\n    res.send('user:' +req.params.username);\n});\n```\n访问结果：\n![](http://i4.tietuku.com/52a6b8b573c8450b.jpg)\n路径规则/user/username会自动编译成正则表达式，类似于\\/user\\/([^\\/]+)\\/?这样的形式，路径参数可以在相应函数中通过req.params的属性访问。\n\n2. 路径规则同样支持javascript正则表达式，例如`router.get(\\/user\\/([^\\/]+)\\/?,callback)`这样的好处在于可以定义更加复杂的路径规则，不同之处是配置的参数是匿名的，因此需要通过req.params[0]这样的形式访问。\n\n### 四、REST风格的路由规则\nExpress支持REST风格的请求方式，REST意思是表征状态转移，它是一种基于HTTP协议的网络应用的接口风格，充分利用HTTP的方法实现了统一风格的接口服务，HTTP协议定义了以下8个标准方法：\n\n|请求方法|用途|\n|---|---|\n|GET|请求获取的资源 获取|\n|POST|向指定资源提交数据 新增|\n|DELETE|请求服务器删除指定资源 删除|\n|PUT|请求服务器存储一个资源 更新|\n|HEAD|请求指定资源的响应头|\n|TRACE|回显服务器数到的请求，主要用户测试或诊断|\n|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。|\n|OPTIONS|返回服务器支持HTTP请求方法|\n\nExpress对每种HTTP请求方法都设计了不同的路由绑定函数 \n- GET : app.get(path,callback);\n- POST: app.post(path,callback);\n- PUT : app.put(path,callback);\n- DELETE: app.delete(path,callback);\n...\n...\n所有方法 app.all(path,callback);\napp.all函数，它支持把所有的请求方法绑定到同一个相应函数，是一个非常灵活的函数。\n\n### 五、控制权转移\nExpress支持同一路径绑定多个响应函数\n```javascript\napp.all('test/:user',function(req,res,next){\n    res.send(\"all method is call\");\n    next();\n});\n\napp.get('/test/:user',function(req,res){\n    res.send(\"user: \" + req.params.user); \n});\n```\n但是我们访问都只会返回一次。\nExpress提供了路由控制权转移的方法，即next()函数，通过调用则将控制权交给后面的规则","slug":"nodeJsStudy11","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ewu000her2zyyofply2","content":"<h3 id=\"一、工作原理\">一、工作原理</h3><p>当访问<a href=\"http://localhost:3000，\" target=\"_blank\" rel=\"external\">http://localhost:3000，</a> 浏览器会向服务器发送请求，包括请求的方法、路径、HTTP协议版本和请求头信息。app会解析请求的路径，调用相应的逻辑，route/index.js中有 <code>router.get(&#39;/&#39;,function(){})</code>通过<code>res.render(&#39;index&#39;,{title:&quot;cky&quot;})</code>调用视图模板index，传递title变量，最终生成HTML页面，返回给浏览器。<br>浏览器收到内容后，通过分析需要获取/stylesheet/style.css，因此会再次向服务器发起请求，app.js并没有一个路由指派到/stylesheets/style.css，但app通过<code>app.use(express.static(__dirname+&#39;/public&#39;))</code>配置了静态文件服务器，因此会定向到app.js所在目录下的/public/stylesheets/style.css拿取这个文件。</p>\n<p>这是一个典型的MVC架构，浏览器发送请求，由路由控制接收，根据不同的路径定向到不同的服务器，控制器处理用户具体的请求，可能会访问数据库中的对象，即模型部分，生成视图的HTML，最后再由控制器返回给浏览器，完成一次请求。</p>\n<h3 id=\"二、创建路由规则\">二、创建路由规则</h3><p>当我们在浏览器访问<a href=\"http://localhost:3000/cky\" target=\"_blank\" rel=\"external\">http://localhost:3000/cky</a> 的时候，服务器响应头返回404 NOT FOUND的错误，这是因为/cky是一个不存在的路由规则，而且它也不是一个public目录下的文件，所以响应404。<br>假设我们创建一个/cky的路由规则<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.get(<span class=\"string\">'/cky'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  res.send(<span class=\"string\">\"cky route\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>即可访问。<br>服务器开始监听之前，设置好了所有的路由规则，当请求到来时直接分配到相应的函数，app.get是路由规则创建函数。</p>\n<h3 id=\"三、路径匹配\">三、路径匹配</h3><p>上面讲到了为固定的路径设置路由规则，Express还提供了更高级的路径匹配模式。<br>1.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.get(<span class=\"string\">'/user/:username'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    res.send(<span class=\"string\">'user:'</span> +req.params.username);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>访问结果：<br><img src=\"http://i4.tietuku.com/52a6b8b573c8450b.jpg\" alt=\"\"><br>路径规则/user/username会自动编译成正则表达式，类似于\\/user\\/([^\\/]+)\\/?这样的形式，路径参数可以在相应函数中通过req.params的属性访问。</p>\n<ol>\n<li>路径规则同样支持javascript正则表达式，例如<code>router.get(\\/user\\/([^\\/]+)\\/?,callback)</code>这样的好处在于可以定义更加复杂的路径规则，不同之处是配置的参数是匿名的，因此需要通过req.params[0]这样的形式访问。</li>\n</ol>\n<h3 id=\"四、REST风格的路由规则\">四、REST风格的路由规则</h3><p>Express支持REST风格的请求方式，REST意思是表征状态转移，它是一种基于HTTP协议的网络应用的接口风格，充分利用HTTP的方法实现了统一风格的接口服务，HTTP协议定义了以下8个标准方法：</p>\n<table>\n<thead>\n<tr>\n<th>请求方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>请求获取的资源 获取</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>向指定资源提交数据 新增</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>请求服务器删除指定资源 删除</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>请求服务器存储一个资源 更新</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>请求指定资源的响应头</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>回显服务器数到的请求，主要用户测试或诊断</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>返回服务器支持HTTP请求方法</td>\n</tr>\n</tbody>\n</table>\n<p>Express对每种HTTP请求方法都设计了不同的路由绑定函数 </p>\n<ul>\n<li>GET : app.get(path,callback);</li>\n<li>POST: app.post(path,callback);</li>\n<li>PUT : app.put(path,callback);</li>\n<li>DELETE: app.delete(path,callback);<br>…<br>…<br>所有方法 app.all(path,callback);<br>app.all函数，它支持把所有的请求方法绑定到同一个相应函数，是一个非常灵活的函数。</li>\n</ul>\n<h3 id=\"五、控制权转移\">五、控制权转移</h3><p>Express支持同一路径绑定多个响应函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.all(<span class=\"string\">'test/:user'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</div><div class=\"line\">    res.send(<span class=\"string\">\"all method is call\"</span>);</div><div class=\"line\">    next();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/test/:user'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    res.send(<span class=\"string\">\"user: \"</span> + req.params.user); </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>但是我们访问都只会返回一次。<br>Express提供了路由控制权转移的方法，即next()函数，通过调用则将控制权交给后面的规则</p>\n","excerpt":"","more":"<h3 id=\"一、工作原理\">一、工作原理</h3><p>当访问<a href=\"http://localhost:3000，\">http://localhost:3000，</a> 浏览器会向服务器发送请求，包括请求的方法、路径、HTTP协议版本和请求头信息。app会解析请求的路径，调用相应的逻辑，route/index.js中有 <code>router.get(&#39;/&#39;,function(){})</code>通过<code>res.render(&#39;index&#39;,{title:&quot;cky&quot;})</code>调用视图模板index，传递title变量，最终生成HTML页面，返回给浏览器。<br>浏览器收到内容后，通过分析需要获取/stylesheet/style.css，因此会再次向服务器发起请求，app.js并没有一个路由指派到/stylesheets/style.css，但app通过<code>app.use(express.static(__dirname+&#39;/public&#39;))</code>配置了静态文件服务器，因此会定向到app.js所在目录下的/public/stylesheets/style.css拿取这个文件。</p>\n<p>这是一个典型的MVC架构，浏览器发送请求，由路由控制接收，根据不同的路径定向到不同的服务器，控制器处理用户具体的请求，可能会访问数据库中的对象，即模型部分，生成视图的HTML，最后再由控制器返回给浏览器，完成一次请求。</p>\n<h3 id=\"二、创建路由规则\">二、创建路由规则</h3><p>当我们在浏览器访问<a href=\"http://localhost:3000/cky\">http://localhost:3000/cky</a> 的时候，服务器响应头返回404 NOT FOUND的错误，这是因为/cky是一个不存在的路由规则，而且它也不是一个public目录下的文件，所以响应404。<br>假设我们创建一个/cky的路由规则<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.get(<span class=\"string\">'/cky'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  res.send(<span class=\"string\">\"cky route\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>即可访问。<br>服务器开始监听之前，设置好了所有的路由规则，当请求到来时直接分配到相应的函数，app.get是路由规则创建函数。</p>\n<h3 id=\"三、路径匹配\">三、路径匹配</h3><p>上面讲到了为固定的路径设置路由规则，Express还提供了更高级的路径匹配模式。<br>1.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.get(<span class=\"string\">'/user/:username'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    res.send(<span class=\"string\">'user:'</span> +req.params.username);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>访问结果：<br><img src=\"http://i4.tietuku.com/52a6b8b573c8450b.jpg\" alt=\"\"><br>路径规则/user/username会自动编译成正则表达式，类似于\\/user\\/([^\\/]+)\\/?这样的形式，路径参数可以在相应函数中通过req.params的属性访问。</p>\n<ol>\n<li>路径规则同样支持javascript正则表达式，例如<code>router.get(\\/user\\/([^\\/]+)\\/?,callback)</code>这样的好处在于可以定义更加复杂的路径规则，不同之处是配置的参数是匿名的，因此需要通过req.params[0]这样的形式访问。</li>\n</ol>\n<h3 id=\"四、REST风格的路由规则\">四、REST风格的路由规则</h3><p>Express支持REST风格的请求方式，REST意思是表征状态转移，它是一种基于HTTP协议的网络应用的接口风格，充分利用HTTP的方法实现了统一风格的接口服务，HTTP协议定义了以下8个标准方法：</p>\n<table>\n<thead>\n<tr>\n<th>请求方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>请求获取的资源 获取</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>向指定资源提交数据 新增</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>请求服务器删除指定资源 删除</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>请求服务器存储一个资源 更新</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>请求指定资源的响应头</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>回显服务器数到的请求，主要用户测试或诊断</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>返回服务器支持HTTP请求方法</td>\n</tr>\n</tbody>\n</table>\n<p>Express对每种HTTP请求方法都设计了不同的路由绑定函数 </p>\n<ul>\n<li>GET : app.get(path,callback);</li>\n<li>POST: app.post(path,callback);</li>\n<li>PUT : app.put(path,callback);</li>\n<li>DELETE: app.delete(path,callback);<br>…<br>…<br>所有方法 app.all(path,callback);<br>app.all函数，它支持把所有的请求方法绑定到同一个相应函数，是一个非常灵活的函数。</li>\n</ul>\n<h3 id=\"五、控制权转移\">五、控制权转移</h3><p>Express支持同一路径绑定多个响应函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.all(<span class=\"string\">'test/:user'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res,next</span>)</span>&#123;</div><div class=\"line\">    res.send(<span class=\"string\">\"all method is call\"</span>);</div><div class=\"line\">    next();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/test/:user'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    res.send(<span class=\"string\">\"user: \"</span> + req.params.user); </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>但是我们访问都只会返回一次。<br>Express提供了路由控制权转移的方法，即next()函数，通过调用则将控制权交给后面的规则</p>\n"},{"title":"node.js学习笔记(一)——node.js异步式I/O与事件编程","date":"2015-12-01T02:17:50.000Z","_content":"Node.js最大的特性就是**异步式IO**与**事件**紧密结合的编程模式，这种模式与传统的同步式I/O线性的编程思路有很大的不同，因为控制流很大程度上靠事件和回调函数来组织。\n\n### 阻塞与线程\n#### 1.同步式I/O(阻塞式I/O)：\n线程在执行过程中如果遇到磁盘读写或网络通信，通常要耗费较长的时间。这时操作系统会剥夺这个线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞。当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。\n\n#### 2. 异步式I/O(非阻塞式I/O)\n针对所有的I/O操作不采用阻塞策略，当线程遇到I/O操作时，不会以阻塞的方式等待I/O操作的完成或数据的返回，而只是将I/O请求发给操作系统，继续执行下一句语句，当操作系统完成I/O操作时，以事件的形式通知执行I/O操作的线程，线程会在特定时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。\n\n#### 3.非阻塞与阻塞模式的区别\n非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的CPU核心利用率永远是100%，I/O以事件的方式通知。\n阻塞模式下，多线程往往能提高系统的吞吐量，因为一个线程阻塞还有其他线程在工作，多线程可以让CPU资源不被阻塞中的线程浪费。\n\n#### 4. 同步式I/O与异步式I/O区别\n|同步式I/O(阻塞式)|异步式I/O(非阻塞)|\n|---|:---\n|利用多线程提供吞吐量|单线程即可实现高吞吐量|\n|通过事件片分隔和线程调度利用多核CPU|通过功能划分利用多核|\n|需要由操作系统调度多线程使用多核CPU|可以将单线程绑定到单核CPU|\n|难以充分利用CPU资源|可以充分利用CPU资源|\n|内存轨迹大，数据局部性弱|内存轨迹小，数据局部性强|\n|符合线性的编程思维|不符合传统编程思维|","source":"_posts/nodeJsStudy1.md","raw":"title: node.js学习笔记(一)——node.js异步式I/O与事件编程\ndate: 2015-12-01 10:17:50\ntags: node.js学习笔记\n---\nNode.js最大的特性就是**异步式IO**与**事件**紧密结合的编程模式，这种模式与传统的同步式I/O线性的编程思路有很大的不同，因为控制流很大程度上靠事件和回调函数来组织。\n\n### 阻塞与线程\n#### 1.同步式I/O(阻塞式I/O)：\n线程在执行过程中如果遇到磁盘读写或网络通信，通常要耗费较长的时间。这时操作系统会剥夺这个线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞。当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。\n\n#### 2. 异步式I/O(非阻塞式I/O)\n针对所有的I/O操作不采用阻塞策略，当线程遇到I/O操作时，不会以阻塞的方式等待I/O操作的完成或数据的返回，而只是将I/O请求发给操作系统，继续执行下一句语句，当操作系统完成I/O操作时，以事件的形式通知执行I/O操作的线程，线程会在特定时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。\n\n#### 3.非阻塞与阻塞模式的区别\n非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的CPU核心利用率永远是100%，I/O以事件的方式通知。\n阻塞模式下，多线程往往能提高系统的吞吐量，因为一个线程阻塞还有其他线程在工作，多线程可以让CPU资源不被阻塞中的线程浪费。\n\n#### 4. 同步式I/O与异步式I/O区别\n|同步式I/O(阻塞式)|异步式I/O(非阻塞)|\n|---|:---\n|利用多线程提供吞吐量|单线程即可实现高吞吐量|\n|通过事件片分隔和线程调度利用多核CPU|通过功能划分利用多核|\n|需要由操作系统调度多线程使用多核CPU|可以将单线程绑定到单核CPU|\n|难以充分利用CPU资源|可以充分利用CPU资源|\n|内存轨迹大，数据局部性弱|内存轨迹小，数据局部性强|\n|符合线性的编程思维|不符合传统编程思维|","slug":"nodeJsStudy1","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489eww000jer2z8kk3nrgz","content":"<p>Node.js最大的特性就是<strong>异步式IO</strong>与<strong>事件</strong>紧密结合的编程模式，这种模式与传统的同步式I/O线性的编程思路有很大的不同，因为控制流很大程度上靠事件和回调函数来组织。</p>\n<h3 id=\"阻塞与线程\">阻塞与线程</h3><h4 id=\"1-同步式I/O(阻塞式I/O)：\">1.同步式I/O(阻塞式I/O)：</h4><p>线程在执行过程中如果遇到磁盘读写或网络通信，通常要耗费较长的时间。这时操作系统会剥夺这个线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞。当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。</p>\n<h4 id=\"2-_异步式I/O(非阻塞式I/O)\">2. 异步式I/O(非阻塞式I/O)</h4><p>针对所有的I/O操作不采用阻塞策略，当线程遇到I/O操作时，不会以阻塞的方式等待I/O操作的完成或数据的返回，而只是将I/O请求发给操作系统，继续执行下一句语句，当操作系统完成I/O操作时，以事件的形式通知执行I/O操作的线程，线程会在特定时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。</p>\n<h4 id=\"3-非阻塞与阻塞模式的区别\">3.非阻塞与阻塞模式的区别</h4><p>非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的CPU核心利用率永远是100%，I/O以事件的方式通知。<br>阻塞模式下，多线程往往能提高系统的吞吐量，因为一个线程阻塞还有其他线程在工作，多线程可以让CPU资源不被阻塞中的线程浪费。</p>\n<h4 id=\"4-_同步式I/O与异步式I/O区别\">4. 同步式I/O与异步式I/O区别</h4><table>\n<thead>\n<tr>\n<th>同步式I/O(阻塞式)</th>\n<th style=\"text-align:left\">异步式I/O(非阻塞)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>利用多线程提供吞吐量</td>\n<td style=\"text-align:left\">单线程即可实现高吞吐量</td>\n</tr>\n<tr>\n<td>通过事件片分隔和线程调度利用多核CPU</td>\n<td style=\"text-align:left\">通过功能划分利用多核</td>\n</tr>\n<tr>\n<td>需要由操作系统调度多线程使用多核CPU</td>\n<td style=\"text-align:left\">可以将单线程绑定到单核CPU</td>\n</tr>\n<tr>\n<td>难以充分利用CPU资源</td>\n<td style=\"text-align:left\">可以充分利用CPU资源</td>\n</tr>\n<tr>\n<td>内存轨迹大，数据局部性弱</td>\n<td style=\"text-align:left\">内存轨迹小，数据局部性强</td>\n</tr>\n<tr>\n<td>符合线性的编程思维</td>\n<td style=\"text-align:left\">不符合传统编程思维</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<p>Node.js最大的特性就是<strong>异步式IO</strong>与<strong>事件</strong>紧密结合的编程模式，这种模式与传统的同步式I/O线性的编程思路有很大的不同，因为控制流很大程度上靠事件和回调函数来组织。</p>\n<h3 id=\"阻塞与线程\">阻塞与线程</h3><h4 id=\"1-同步式I/O(阻塞式I/O)：\">1.同步式I/O(阻塞式I/O)：</h4><p>线程在执行过程中如果遇到磁盘读写或网络通信，通常要耗费较长的时间。这时操作系统会剥夺这个线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞。当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。</p>\n<h4 id=\"2-_异步式I/O(非阻塞式I/O)\">2. 异步式I/O(非阻塞式I/O)</h4><p>针对所有的I/O操作不采用阻塞策略，当线程遇到I/O操作时，不会以阻塞的方式等待I/O操作的完成或数据的返回，而只是将I/O请求发给操作系统，继续执行下一句语句，当操作系统完成I/O操作时，以事件的形式通知执行I/O操作的线程，线程会在特定时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。</p>\n<h4 id=\"3-非阻塞与阻塞模式的区别\">3.非阻塞与阻塞模式的区别</h4><p>非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的CPU核心利用率永远是100%，I/O以事件的方式通知。<br>阻塞模式下，多线程往往能提高系统的吞吐量，因为一个线程阻塞还有其他线程在工作，多线程可以让CPU资源不被阻塞中的线程浪费。</p>\n<h4 id=\"4-_同步式I/O与异步式I/O区别\">4. 同步式I/O与异步式I/O区别</h4><table>\n<thead>\n<tr>\n<th>同步式I/O(阻塞式)</th>\n<th style=\"text-align:left\">异步式I/O(非阻塞)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>利用多线程提供吞吐量</td>\n<td style=\"text-align:left\">单线程即可实现高吞吐量</td>\n</tr>\n<tr>\n<td>通过事件片分隔和线程调度利用多核CPU</td>\n<td style=\"text-align:left\">通过功能划分利用多核</td>\n</tr>\n<tr>\n<td>需要由操作系统调度多线程使用多核CPU</td>\n<td style=\"text-align:left\">可以将单线程绑定到单核CPU</td>\n</tr>\n<tr>\n<td>难以充分利用CPU资源</td>\n<td style=\"text-align:left\">可以充分利用CPU资源</td>\n</tr>\n<tr>\n<td>内存轨迹大，数据局部性弱</td>\n<td style=\"text-align:left\">内存轨迹小，数据局部性强</td>\n</tr>\n<tr>\n<td>符合线性的编程思维</td>\n<td style=\"text-align:left\">不符合传统编程思维</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"2016年总结和2017年目标","date":"2016-12-19T12:51:02.000Z","_content":"好久没更新博客了，上一次的博客都要追溯到4月份了，真是惭愧。\n今天工作需求测试阶段基本快告一段落，而且今天正好部门前端开了个总结会，想想2016年过去了，趁着现在有时间，也该来写一下2016年的总结和规划规划2017年的目标了。\n<!-- more -->\n## 2016回顾\n在2016年开年的时候，我也写过一篇2016年的目标，现在来回顾一下吧。\n\n>1.无特殊情况，每天晚上睡前做半个小时以上运动。\n>2.无特殊情况，每天晚上睡前看半个小时以上书，看完书单上的书。\n\n这两条目标，果然对我来说还是太难了- - 睡前运动间歇性坚持了2个月，7月正式工作后也坚持了一段时间，但是自从开始养猫之后，每天晚上回家的大部分时间花在了撸猫上。运动什么的也荒废了。看书也是，虽然2016年看了几本书，但是每天睡前看书还是没有坚持。\n\n>拿驾照 (已完成)\n>完成毕业设计期间学习，达成学习目标（部分完成）\n>存钱毕业旅行 (已完成)\n>存钱买mac pro (已完成)\n\n驾照拿的很轻松啊，不过没车也没啥用- -。\n毕业设计期间用node+express+leancloud写了一个社团管理系统，对于node写web系统算是有了一个经验，对于之后工作也有了帮助。\n毕业旅行去了三亚，也算是达成了我一个内陆人士的看海成就。\nmac pro已买，在9月份生日的时候买给自己当生日礼物，对于写代码的幸福感还是有所提高的 2333。\n\n综上，除了1.2条以外，基本还是完成了（懒癌没救-。-）。\n\n另外，2016年还有一些其他收获。\n运气很好，抱养了一只喵，每天回家开门的时候，就能听见它喵喵的叫，跑到门口来迎接我（我认为的），有时候手一伸过去，它就歪着倒下去，肚子朝上卖萌了等抚摸了。现在天冷了，它会趴在你枕头旁边望着你，一直望到你把被子拉开让它进来和你一起睡。真是每天都会被它萌到。\n\n7月份正式开始猪八戒工作了，参与了好几个比较大的公司级项目，虽然有时候加班比较多，但是完成了项目的时候还是很有成就感的。\n也用node.js作为controller层调soa服务的形式，开发了2个公司比较重要的功能，虽然是新人，但是能够独立开发这么大的模块，感觉责任和成就感并存。\n\n喜欢上了狼人杀，结识了一群杀友，有时候下班就会组织杀一把。作为公司狼人杀小分队老司机的一员，感觉这个组织非常有爱。\n\n## 2017年目标\n\n定一下2017年的目标吧，毕竟2017年的鸡血还是要打一打的。\n\n1. 深入学习，积累15篇以上博客，n篇笔记。\n2. 今年有年假了，也办了护照，是该达成一波出国成就了。\n3. 每周抽个3.5个小时看书吧，写读书笔记。吸取去年的经验，不平均到每天了。\n4. 存钱，4w以上，不能再月光了。\n5. 每个月买一个自己购物愿望清单上的东西。（啊，这条其实和4有点冲突，但是为了提升自己的幸福感，存钱好难，嘤嘤嘤。）\n6. 待定\n\n\n最后放萌猫一只。\n![](http://ww2.sinaimg.cn/mw690/680ee472gw1fawjr222kbj20qo0zk114.jpg)","source":"_posts/my2016and2017.md","raw":"title: 2016年总结和2017年目标\ndate: 2016-01-05 16：31\ntags: 生活琐事\n---\n好久没更新博客了，上一次的博客都要追溯到4月份了，真是惭愧。\n今天工作需求测试阶段基本快告一段落，而且今天正好部门前端开了个总结会，想想2016年过去了，趁着现在有时间，也该来写一下2016年的总结和规划规划2017年的目标了。\n<!-- more -->\n## 2016回顾\n在2016年开年的时候，我也写过一篇2016年的目标，现在来回顾一下吧。\n\n>1.无特殊情况，每天晚上睡前做半个小时以上运动。\n>2.无特殊情况，每天晚上睡前看半个小时以上书，看完书单上的书。\n\n这两条目标，果然对我来说还是太难了- - 睡前运动间歇性坚持了2个月，7月正式工作后也坚持了一段时间，但是自从开始养猫之后，每天晚上回家的大部分时间花在了撸猫上。运动什么的也荒废了。看书也是，虽然2016年看了几本书，但是每天睡前看书还是没有坚持。\n\n>拿驾照 (已完成)\n>完成毕业设计期间学习，达成学习目标（部分完成）\n>存钱毕业旅行 (已完成)\n>存钱买mac pro (已完成)\n\n驾照拿的很轻松啊，不过没车也没啥用- -。\n毕业设计期间用node+express+leancloud写了一个社团管理系统，对于node写web系统算是有了一个经验，对于之后工作也有了帮助。\n毕业旅行去了三亚，也算是达成了我一个内陆人士的看海成就。\nmac pro已买，在9月份生日的时候买给自己当生日礼物，对于写代码的幸福感还是有所提高的 2333。\n\n综上，除了1.2条以外，基本还是完成了（懒癌没救-。-）。\n\n另外，2016年还有一些其他收获。\n运气很好，抱养了一只喵，每天回家开门的时候，就能听见它喵喵的叫，跑到门口来迎接我（我认为的），有时候手一伸过去，它就歪着倒下去，肚子朝上卖萌了等抚摸了。现在天冷了，它会趴在你枕头旁边望着你，一直望到你把被子拉开让它进来和你一起睡。真是每天都会被它萌到。\n\n7月份正式开始猪八戒工作了，参与了好几个比较大的公司级项目，虽然有时候加班比较多，但是完成了项目的时候还是很有成就感的。\n也用node.js作为controller层调soa服务的形式，开发了2个公司比较重要的功能，虽然是新人，但是能够独立开发这么大的模块，感觉责任和成就感并存。\n\n喜欢上了狼人杀，结识了一群杀友，有时候下班就会组织杀一把。作为公司狼人杀小分队老司机的一员，感觉这个组织非常有爱。\n\n## 2017年目标\n\n定一下2017年的目标吧，毕竟2017年的鸡血还是要打一打的。\n\n1. 深入学习，积累15篇以上博客，n篇笔记。\n2. 今年有年假了，也办了护照，是该达成一波出国成就了。\n3. 每周抽个3.5个小时看书吧，写读书笔记。吸取去年的经验，不平均到每天了。\n4. 存钱，4w以上，不能再月光了。\n5. 每个月买一个自己购物愿望清单上的东西。（啊，这条其实和4有点冲突，但是为了提升自己的幸福感，存钱好难，嘤嘤嘤。）\n6. 待定\n\n\n最后放萌猫一只。\n![](http://ww2.sinaimg.cn/mw690/680ee472gw1fawjr222kbj20qo0zk114.jpg)","slug":"my2016and2017","published":1,"updated":"2017-03-01T02:01:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ewz000ler2zufb145a1","content":"<p>好久没更新博客了，上一次的博客都要追溯到4月份了，真是惭愧。<br>今天工作需求测试阶段基本快告一段落，而且今天正好部门前端开了个总结会，想想2016年过去了，趁着现在有时间，也该来写一下2016年的总结和规划规划2017年的目标了。<br><a id=\"more\"></a></p>\n<h2 id=\"2016回顾\">2016回顾</h2><p>在2016年开年的时候，我也写过一篇2016年的目标，现在来回顾一下吧。</p>\n<blockquote>\n<p>1.无特殊情况，每天晚上睡前做半个小时以上运动。<br>2.无特殊情况，每天晚上睡前看半个小时以上书，看完书单上的书。</p>\n</blockquote>\n<p>这两条目标，果然对我来说还是太难了- - 睡前运动间歇性坚持了2个月，7月正式工作后也坚持了一段时间，但是自从开始养猫之后，每天晚上回家的大部分时间花在了撸猫上。运动什么的也荒废了。看书也是，虽然2016年看了几本书，但是每天睡前看书还是没有坚持。</p>\n<blockquote>\n<p>拿驾照 (已完成)<br>完成毕业设计期间学习，达成学习目标（部分完成）<br>存钱毕业旅行 (已完成)<br>存钱买mac pro (已完成)</p>\n</blockquote>\n<p>驾照拿的很轻松啊，不过没车也没啥用- -。<br>毕业设计期间用node+express+leancloud写了一个社团管理系统，对于node写web系统算是有了一个经验，对于之后工作也有了帮助。<br>毕业旅行去了三亚，也算是达成了我一个内陆人士的看海成就。<br>mac pro已买，在9月份生日的时候买给自己当生日礼物，对于写代码的幸福感还是有所提高的 2333。</p>\n<p>综上，除了1.2条以外，基本还是完成了（懒癌没救-。-）。</p>\n<p>另外，2016年还有一些其他收获。<br>运气很好，抱养了一只喵，每天回家开门的时候，就能听见它喵喵的叫，跑到门口来迎接我（我认为的），有时候手一伸过去，它就歪着倒下去，肚子朝上卖萌了等抚摸了。现在天冷了，它会趴在你枕头旁边望着你，一直望到你把被子拉开让它进来和你一起睡。真是每天都会被它萌到。</p>\n<p>7月份正式开始猪八戒工作了，参与了好几个比较大的公司级项目，虽然有时候加班比较多，但是完成了项目的时候还是很有成就感的。<br>也用node.js作为controller层调soa服务的形式，开发了2个公司比较重要的功能，虽然是新人，但是能够独立开发这么大的模块，感觉责任和成就感并存。</p>\n<p>喜欢上了狼人杀，结识了一群杀友，有时候下班就会组织杀一把。作为公司狼人杀小分队老司机的一员，感觉这个组织非常有爱。</p>\n<h2 id=\"2017年目标\">2017年目标</h2><p>定一下2017年的目标吧，毕竟2017年的鸡血还是要打一打的。</p>\n<ol>\n<li>深入学习，积累15篇以上博客，n篇笔记。</li>\n<li>今年有年假了，也办了护照，是该达成一波出国成就了。</li>\n<li>每周抽个3.5个小时看书吧，写读书笔记。吸取去年的经验，不平均到每天了。</li>\n<li>存钱，4w以上，不能再月光了。</li>\n<li>每个月买一个自己购物愿望清单上的东西。（啊，这条其实和4有点冲突，但是为了提升自己的幸福感，存钱好难，嘤嘤嘤。）</li>\n<li>待定</li>\n</ol>\n<p>最后放萌猫一只。<br><img src=\"http://ww2.sinaimg.cn/mw690/680ee472gw1fawjr222kbj20qo0zk114.jpg\" alt=\"\"></p>\n","excerpt":"<p>好久没更新博客了，上一次的博客都要追溯到4月份了，真是惭愧。<br>今天工作需求测试阶段基本快告一段落，而且今天正好部门前端开了个总结会，想想2016年过去了，趁着现在有时间，也该来写一下2016年的总结和规划规划2017年的目标了。<br>","more":"</p>\n<h2 id=\"2016回顾\">2016回顾</h2><p>在2016年开年的时候，我也写过一篇2016年的目标，现在来回顾一下吧。</p>\n<blockquote>\n<p>1.无特殊情况，每天晚上睡前做半个小时以上运动。<br>2.无特殊情况，每天晚上睡前看半个小时以上书，看完书单上的书。</p>\n</blockquote>\n<p>这两条目标，果然对我来说还是太难了- - 睡前运动间歇性坚持了2个月，7月正式工作后也坚持了一段时间，但是自从开始养猫之后，每天晚上回家的大部分时间花在了撸猫上。运动什么的也荒废了。看书也是，虽然2016年看了几本书，但是每天睡前看书还是没有坚持。</p>\n<blockquote>\n<p>拿驾照 (已完成)<br>完成毕业设计期间学习，达成学习目标（部分完成）<br>存钱毕业旅行 (已完成)<br>存钱买mac pro (已完成)</p>\n</blockquote>\n<p>驾照拿的很轻松啊，不过没车也没啥用- -。<br>毕业设计期间用node+express+leancloud写了一个社团管理系统，对于node写web系统算是有了一个经验，对于之后工作也有了帮助。<br>毕业旅行去了三亚，也算是达成了我一个内陆人士的看海成就。<br>mac pro已买，在9月份生日的时候买给自己当生日礼物，对于写代码的幸福感还是有所提高的 2333。</p>\n<p>综上，除了1.2条以外，基本还是完成了（懒癌没救-。-）。</p>\n<p>另外，2016年还有一些其他收获。<br>运气很好，抱养了一只喵，每天回家开门的时候，就能听见它喵喵的叫，跑到门口来迎接我（我认为的），有时候手一伸过去，它就歪着倒下去，肚子朝上卖萌了等抚摸了。现在天冷了，它会趴在你枕头旁边望着你，一直望到你把被子拉开让它进来和你一起睡。真是每天都会被它萌到。</p>\n<p>7月份正式开始猪八戒工作了，参与了好几个比较大的公司级项目，虽然有时候加班比较多，但是完成了项目的时候还是很有成就感的。<br>也用node.js作为controller层调soa服务的形式，开发了2个公司比较重要的功能，虽然是新人，但是能够独立开发这么大的模块，感觉责任和成就感并存。</p>\n<p>喜欢上了狼人杀，结识了一群杀友，有时候下班就会组织杀一把。作为公司狼人杀小分队老司机的一员，感觉这个组织非常有爱。</p>\n<h2 id=\"2017年目标\">2017年目标</h2><p>定一下2017年的目标吧，毕竟2017年的鸡血还是要打一打的。</p>\n<ol>\n<li>深入学习，积累15篇以上博客，n篇笔记。</li>\n<li>今年有年假了，也办了护照，是该达成一波出国成就了。</li>\n<li>每周抽个3.5个小时看书吧，写读书笔记。吸取去年的经验，不平均到每天了。</li>\n<li>存钱，4w以上，不能再月光了。</li>\n<li>每个月买一个自己购物愿望清单上的东西。（啊，这条其实和4有点冲突，但是为了提升自己的幸福感，存钱好难，嘤嘤嘤。）</li>\n<li>待定</li>\n</ol>\n<p>最后放萌猫一只。<br><img src=\"http://ww2.sinaimg.cn/mw690/680ee472gw1fawjr222kbj20qo0zk114.jpg\" alt=\"\"></p>"},{"title":"node.js学习笔记(四)——全局对象与全局变量","date":"2015-12-11T02:17:50.000Z","_content":"所有属性都可以在程序的任何地方访问，即全局变量。在javascript中，通常window是全局对象，而node.js的全局对象是global，所有全局变量都是global对象的属性，如：console、process等。\n<!-- more -->\n### 一、全局对象与全局变量\n global最根本的作用是作为全局变量的宿主。满足以下条件成为全局变量。\n 1. 在最外层定义的变量\n 2. 全局对象的属性\n 3. 隐式定义的变量（未定义直接赋值的变量）\n node.js中不可能在最外层定义变量，因为所有的用户代码都是属于当前模块的，而模块本身不是最外层上下文。node.js中也不提倡自定义全局变量。\n\n__Node提供以下几个全局对象，它们是所有模块都可以调用的__。\n- global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。\n\n- process：该对象表示Node所处的当前进程，允许开发者与该进程互动。\n- console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。\n\n__Node还提供一些全局函数__。\n\n- setTimeout()：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。\n- clearTimeout()：用于终止一个setTimeout方法新建的定时器。\n- setInterval()：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。\n- clearInterval()：终止一个用setInterval方法新建的定时器。\n- require()：用于加载模块。\n- Buffer()：用于操作二进制数据。\n\n__Node提供两个全局变量，都以两个下划线开头__。\n\n_filename：指向当前运行的脚本文件名。\n_dirname：指向当前运行的脚本所在的目录。\n除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。\n\n### 二、 process\n 它用于描述当前Node.js进程状态的对象。提供了一个与操作系统的简单接口，通常写本地命令行程序的时候，会用到它。\n 例：\n ```javascript\n//命令行输入 node argv.js 'cky' 1993\n//argv.js\nconsole.log(process.argv);\nprocess.stdout.write('cky');\n ```\n 运行结果：\n ```javascript\n[ 'E:\\\\下载的东西\\\\node\\\\node.exe',\n  'D:\\\\myStudy\\\\nodeJsStudy\\\\process\\\\argv.js',\n  'cky',\n  '1993' ]\ncky\n ```\n 1. process.argv是命令行参数数组，第一个输出是node程序所在位置，第二个输出是脚本文件所在位置，第三个输出开始是运行参数。\n 2. process.stdout是标准输出流，通常我们使用的console.log()其底层是用process.stdout.write()实现的。\n 3. process.stdin是标准的输入流，在初识时他是被暂停的。要想从标准输入流读取数据，必须恢复流，并手动编写流的事件的相应函数。\n ```javascript\n //恢复流\nprocess.stdin.resume();\nprocess.stdin.on('data',function(data){\n    process.stdout.write('read form' +data.toString());\n});\n```\n 执行结果：\n![](http://i12.tietuku.com/1c4b90d94b2fb0e7.png)\n\n 4. process.nextTick(callback)的功能是为事件循环设置一项任务。Node.js会在下次事件循环调用callback。\nNode.js适合IO密集型的应用，而不是计算密集型的应用。process.nextTick()提供了一个这样的工具，可以把复杂的工作拆散，变为较小的事件。将一个回调函数放在下次事件循环的顶部。\n ```javascript\nfunction compute(){\n    console.log('I am a compute method');\n}\nfunction somethingComplited(args){\n    console.log('I am somthingComplited method');\n    console.log(args);\n}\nfunction doSomething(args,callback){\n    somethingComplited(args);\n    callback();\n}\ndoSomething('12345',function onEnd(){\n    compute();\n});\n ```\n 如果假设compute()和somethingComplited()是两个较为耗时的函数。以上的程序在调用doSomething时会先执行somethingComplited(args)后立即调用回调函数，在onEnd()中又会执行compute()，改写为：\n\n ```javascript\nfunction doSomething(args,callback){\n    somethingComplited(args);\n    process.nextTick(callback);\n}\n ```\n 使用process.nextTick()后，改写后的程序会把上面耗时的操作拆分为两个事件，减少每个事件的执行事件，提高事件响应速度。\n更多process API可参考 [参考链接1](http://www.css88.com/archives/4548)，[参考链接2](http://www.nodejs.net/a/20121231/083747.html)\n\n### 三、console\n用于提供控制台的标准输出，node.js沿用了这个标准，提供与习惯行为一致的console对象。\n1. `console.log()` 向标准输出流打印字符并以换行符结束。\n案例：\n```javascript\nconsole.log(\"hello\");\nconsole.log(\"hello%cky\");\nconsole.log(\"hello%cky\",\"cky\");\n```\n2. `console.error()`用法与标准console.log()相同，只是向标准错误流输出。\n3. `console.trace()`向标准错误流输出当前的调用栈。","source":"_posts/nodeJsStudy4.md","raw":"title: node.js学习笔记(四)——全局对象与全局变量\ndate: 2015-12-11 10:17:50\ntags: node.js学习笔记\n---\n所有属性都可以在程序的任何地方访问，即全局变量。在javascript中，通常window是全局对象，而node.js的全局对象是global，所有全局变量都是global对象的属性，如：console、process等。\n<!-- more -->\n### 一、全局对象与全局变量\n global最根本的作用是作为全局变量的宿主。满足以下条件成为全局变量。\n 1. 在最外层定义的变量\n 2. 全局对象的属性\n 3. 隐式定义的变量（未定义直接赋值的变量）\n node.js中不可能在最外层定义变量，因为所有的用户代码都是属于当前模块的，而模块本身不是最外层上下文。node.js中也不提倡自定义全局变量。\n\n__Node提供以下几个全局对象，它们是所有模块都可以调用的__。\n- global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。\n\n- process：该对象表示Node所处的当前进程，允许开发者与该进程互动。\n- console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。\n\n__Node还提供一些全局函数__。\n\n- setTimeout()：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。\n- clearTimeout()：用于终止一个setTimeout方法新建的定时器。\n- setInterval()：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。\n- clearInterval()：终止一个用setInterval方法新建的定时器。\n- require()：用于加载模块。\n- Buffer()：用于操作二进制数据。\n\n__Node提供两个全局变量，都以两个下划线开头__。\n\n_filename：指向当前运行的脚本文件名。\n_dirname：指向当前运行的脚本所在的目录。\n除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。\n\n### 二、 process\n 它用于描述当前Node.js进程状态的对象。提供了一个与操作系统的简单接口，通常写本地命令行程序的时候，会用到它。\n 例：\n ```javascript\n//命令行输入 node argv.js 'cky' 1993\n//argv.js\nconsole.log(process.argv);\nprocess.stdout.write('cky');\n ```\n 运行结果：\n ```javascript\n[ 'E:\\\\下载的东西\\\\node\\\\node.exe',\n  'D:\\\\myStudy\\\\nodeJsStudy\\\\process\\\\argv.js',\n  'cky',\n  '1993' ]\ncky\n ```\n 1. process.argv是命令行参数数组，第一个输出是node程序所在位置，第二个输出是脚本文件所在位置，第三个输出开始是运行参数。\n 2. process.stdout是标准输出流，通常我们使用的console.log()其底层是用process.stdout.write()实现的。\n 3. process.stdin是标准的输入流，在初识时他是被暂停的。要想从标准输入流读取数据，必须恢复流，并手动编写流的事件的相应函数。\n ```javascript\n //恢复流\nprocess.stdin.resume();\nprocess.stdin.on('data',function(data){\n    process.stdout.write('read form' +data.toString());\n});\n```\n 执行结果：\n![](http://i12.tietuku.com/1c4b90d94b2fb0e7.png)\n\n 4. process.nextTick(callback)的功能是为事件循环设置一项任务。Node.js会在下次事件循环调用callback。\nNode.js适合IO密集型的应用，而不是计算密集型的应用。process.nextTick()提供了一个这样的工具，可以把复杂的工作拆散，变为较小的事件。将一个回调函数放在下次事件循环的顶部。\n ```javascript\nfunction compute(){\n    console.log('I am a compute method');\n}\nfunction somethingComplited(args){\n    console.log('I am somthingComplited method');\n    console.log(args);\n}\nfunction doSomething(args,callback){\n    somethingComplited(args);\n    callback();\n}\ndoSomething('12345',function onEnd(){\n    compute();\n});\n ```\n 如果假设compute()和somethingComplited()是两个较为耗时的函数。以上的程序在调用doSomething时会先执行somethingComplited(args)后立即调用回调函数，在onEnd()中又会执行compute()，改写为：\n\n ```javascript\nfunction doSomething(args,callback){\n    somethingComplited(args);\n    process.nextTick(callback);\n}\n ```\n 使用process.nextTick()后，改写后的程序会把上面耗时的操作拆分为两个事件，减少每个事件的执行事件，提高事件响应速度。\n更多process API可参考 [参考链接1](http://www.css88.com/archives/4548)，[参考链接2](http://www.nodejs.net/a/20121231/083747.html)\n\n### 三、console\n用于提供控制台的标准输出，node.js沿用了这个标准，提供与习惯行为一致的console对象。\n1. `console.log()` 向标准输出流打印字符并以换行符结束。\n案例：\n```javascript\nconsole.log(\"hello\");\nconsole.log(\"hello%cky\");\nconsole.log(\"hello%cky\",\"cky\");\n```\n2. `console.error()`用法与标准console.log()相同，只是向标准错误流输出。\n3. `console.trace()`向标准错误流输出当前的调用栈。","slug":"nodeJsStudy4","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ex4000ner2z2cjal4me","content":"<p>所有属性都可以在程序的任何地方访问，即全局变量。在javascript中，通常window是全局对象，而node.js的全局对象是global，所有全局变量都是global对象的属性，如：console、process等。<br><a id=\"more\"></a></p>\n<h3 id=\"一、全局对象与全局变量\">一、全局对象与全局变量</h3><p> global最根本的作用是作为全局变量的宿主。满足以下条件成为全局变量。</p>\n<ol>\n<li>在最外层定义的变量</li>\n<li>全局对象的属性</li>\n<li>隐式定义的变量（未定义直接赋值的变量）<br>node.js中不可能在最外层定义变量，因为所有的用户代码都是属于当前模块的，而模块本身不是最外层上下文。node.js中也不提倡自定义全局变量。</li>\n</ol>\n<p><strong>Node提供以下几个全局对象，它们是所有模块都可以调用的</strong>。</p>\n<ul>\n<li><p>global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。</p>\n</li>\n<li><p>process：该对象表示Node所处的当前进程，允许开发者与该进程互动。</p>\n</li>\n<li>console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。</li>\n</ul>\n<p><strong>Node还提供一些全局函数</strong>。</p>\n<ul>\n<li>setTimeout()：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。</li>\n<li>clearTimeout()：用于终止一个setTimeout方法新建的定时器。</li>\n<li>setInterval()：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。</li>\n<li>clearInterval()：终止一个用setInterval方法新建的定时器。</li>\n<li>require()：用于加载模块。</li>\n<li>Buffer()：用于操作二进制数据。</li>\n</ul>\n<p><strong>Node提供两个全局变量，都以两个下划线开头</strong>。</p>\n<p>_filename：指向当前运行的脚本文件名。<br>_dirname：指向当前运行的脚本所在的目录。<br>除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。</p>\n<h3 id=\"二、_process\">二、 process</h3><p> 它用于描述当前Node.js进程状态的对象。提供了一个与操作系统的简单接口，通常写本地命令行程序的时候，会用到它。<br> 例：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//命令行输入 node argv.js 'cky' 1993</span></div><div class=\"line\"><span class=\"comment\">//argv.js</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(process.argv);</div><div class=\"line\">process.stdout.write(<span class=\"string\">'cky'</span>);</div></pre></td></tr></table></figure></p>\n<p> 运行结果：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ <span class=\"string\">'E:\\\\下载的东西\\\\node\\\\node.exe'</span>,</div><div class=\"line\">  <span class=\"string\">'D:\\\\myStudy\\\\nodeJsStudy\\\\process\\\\argv.js'</span>,</div><div class=\"line\">  <span class=\"string\">'cky'</span>,</div><div class=\"line\">  <span class=\"string\">'1993'</span> ]</div><div class=\"line\">cky</div></pre></td></tr></table></figure></p>\n<ol>\n<li>process.argv是命令行参数数组，第一个输出是node程序所在位置，第二个输出是脚本文件所在位置，第三个输出开始是运行参数。</li>\n<li>process.stdout是标准输出流，通常我们使用的console.log()其底层是用process.stdout.write()实现的。</li>\n<li><p>process.stdin是标准的输入流，在初识时他是被暂停的。要想从标准输入流读取数据，必须恢复流，并手动编写流的事件的相应函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//恢复流</span></div><div class=\"line\">process.stdin.resume();</div><div class=\"line\">process.stdin.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    process.stdout.write(<span class=\"string\">'read form'</span> +data.toString());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>执行结果：<br><img src=\"http://i12.tietuku.com/1c4b90d94b2fb0e7.png\" alt=\"\"></p>\n</li>\n<li><p>process.nextTick(callback)的功能是为事件循环设置一项任务。Node.js会在下次事件循环调用callback。<br>Node.js适合IO密集型的应用，而不是计算密集型的应用。process.nextTick()提供了一个这样的工具，可以把复杂的工作拆散，变为较小的事件。将一个回调函数放在下次事件循环的顶部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compute</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am a compute method'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">somethingComplited</span>(<span class=\"params\">args</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am somthingComplited method'</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(args);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">args,callback</span>)</span>&#123;</div><div class=\"line\">    somethingComplited(args);</div><div class=\"line\">    callback();</div><div class=\"line\">&#125;</div><div class=\"line\">doSomething(<span class=\"string\">'12345'</span>,<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onEnd</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    compute();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果假设compute()和somethingComplited()是两个较为耗时的函数。以上的程序在调用doSomething时会先执行somethingComplited(args)后立即调用回调函数，在onEnd()中又会执行compute()，改写为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">args,callback</span>)</span>&#123;</div><div class=\"line\">    somethingComplited(args);</div><div class=\"line\">    process.nextTick(callback);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用process.nextTick()后，改写后的程序会把上面耗时的操作拆分为两个事件，减少每个事件的执行事件，提高事件响应速度。<br>更多process API可参考 <a href=\"http://www.css88.com/archives/4548\" target=\"_blank\" rel=\"external\">参考链接1</a>，<a href=\"http://www.nodejs.net/a/20121231/083747.html\" target=\"_blank\" rel=\"external\">参考链接2</a></p>\n</li>\n</ol>\n<h3 id=\"三、console\">三、console</h3><p>用于提供控制台的标准输出，node.js沿用了这个标准，提供与习惯行为一致的console对象。</p>\n<ol>\n<li><p><code>console.log()</code> 向标准输出流打印字符并以换行符结束。<br>案例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello%cky\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello%cky\"</span>,<span class=\"string\">\"cky\"</span>);</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>console.error()</code>用法与标准console.log()相同，只是向标准错误流输出。</p>\n</li>\n<li><code>console.trace()</code>向标准错误流输出当前的调用栈。</li>\n</ol>\n","excerpt":"<p>所有属性都可以在程序的任何地方访问，即全局变量。在javascript中，通常window是全局对象，而node.js的全局对象是global，所有全局变量都是global对象的属性，如：console、process等。<br>","more":"</p>\n<h3 id=\"一、全局对象与全局变量\">一、全局对象与全局变量</h3><p> global最根本的作用是作为全局变量的宿主。满足以下条件成为全局变量。</p>\n<ol>\n<li>在最外层定义的变量</li>\n<li>全局对象的属性</li>\n<li>隐式定义的变量（未定义直接赋值的变量）<br>node.js中不可能在最外层定义变量，因为所有的用户代码都是属于当前模块的，而模块本身不是最外层上下文。node.js中也不提倡自定义全局变量。</li>\n</ol>\n<p><strong>Node提供以下几个全局对象，它们是所有模块都可以调用的</strong>。</p>\n<ul>\n<li><p>global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。</p>\n</li>\n<li><p>process：该对象表示Node所处的当前进程，允许开发者与该进程互动。</p>\n</li>\n<li>console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。</li>\n</ul>\n<p><strong>Node还提供一些全局函数</strong>。</p>\n<ul>\n<li>setTimeout()：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。</li>\n<li>clearTimeout()：用于终止一个setTimeout方法新建的定时器。</li>\n<li>setInterval()：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。</li>\n<li>clearInterval()：终止一个用setInterval方法新建的定时器。</li>\n<li>require()：用于加载模块。</li>\n<li>Buffer()：用于操作二进制数据。</li>\n</ul>\n<p><strong>Node提供两个全局变量，都以两个下划线开头</strong>。</p>\n<p>_filename：指向当前运行的脚本文件名。<br>_dirname：指向当前运行的脚本所在的目录。<br>除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。</p>\n<h3 id=\"二、_process\">二、 process</h3><p> 它用于描述当前Node.js进程状态的对象。提供了一个与操作系统的简单接口，通常写本地命令行程序的时候，会用到它。<br> 例：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//命令行输入 node argv.js 'cky' 1993</span></div><div class=\"line\"><span class=\"comment\">//argv.js</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(process.argv);</div><div class=\"line\">process.stdout.write(<span class=\"string\">'cky'</span>);</div></pre></td></tr></table></figure></p>\n<p> 运行结果：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ <span class=\"string\">'E:\\\\下载的东西\\\\node\\\\node.exe'</span>,</div><div class=\"line\">  <span class=\"string\">'D:\\\\myStudy\\\\nodeJsStudy\\\\process\\\\argv.js'</span>,</div><div class=\"line\">  <span class=\"string\">'cky'</span>,</div><div class=\"line\">  <span class=\"string\">'1993'</span> ]</div><div class=\"line\">cky</div></pre></td></tr></table></figure></p>\n<ol>\n<li>process.argv是命令行参数数组，第一个输出是node程序所在位置，第二个输出是脚本文件所在位置，第三个输出开始是运行参数。</li>\n<li>process.stdout是标准输出流，通常我们使用的console.log()其底层是用process.stdout.write()实现的。</li>\n<li><p>process.stdin是标准的输入流，在初识时他是被暂停的。要想从标准输入流读取数据，必须恢复流，并手动编写流的事件的相应函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//恢复流</span></div><div class=\"line\">process.stdin.resume();</div><div class=\"line\">process.stdin.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    process.stdout.write(<span class=\"string\">'read form'</span> +data.toString());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>执行结果：<br><img src=\"http://i12.tietuku.com/1c4b90d94b2fb0e7.png\" alt=\"\"></p>\n</li>\n<li><p>process.nextTick(callback)的功能是为事件循环设置一项任务。Node.js会在下次事件循环调用callback。<br>Node.js适合IO密集型的应用，而不是计算密集型的应用。process.nextTick()提供了一个这样的工具，可以把复杂的工作拆散，变为较小的事件。将一个回调函数放在下次事件循环的顶部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compute</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am a compute method'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">somethingComplited</span>(<span class=\"params\">args</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am somthingComplited method'</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(args);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">args,callback</span>)</span>&#123;</div><div class=\"line\">    somethingComplited(args);</div><div class=\"line\">    callback();</div><div class=\"line\">&#125;</div><div class=\"line\">doSomething(<span class=\"string\">'12345'</span>,<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onEnd</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    compute();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果假设compute()和somethingComplited()是两个较为耗时的函数。以上的程序在调用doSomething时会先执行somethingComplited(args)后立即调用回调函数，在onEnd()中又会执行compute()，改写为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">args,callback</span>)</span>&#123;</div><div class=\"line\">    somethingComplited(args);</div><div class=\"line\">    process.nextTick(callback);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用process.nextTick()后，改写后的程序会把上面耗时的操作拆分为两个事件，减少每个事件的执行事件，提高事件响应速度。<br>更多process API可参考 <a href=\"http://www.css88.com/archives/4548\">参考链接1</a>，<a href=\"http://www.nodejs.net/a/20121231/083747.html\">参考链接2</a></p>\n</li>\n</ol>\n<h3 id=\"三、console\">三、console</h3><p>用于提供控制台的标准输出，node.js沿用了这个标准，提供与习惯行为一致的console对象。</p>\n<ol>\n<li><p><code>console.log()</code> 向标准输出流打印字符并以换行符结束。<br>案例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello%cky\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello%cky\"</span>,<span class=\"string\">\"cky\"</span>);</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>console.error()</code>用法与标准console.log()相同，只是向标准错误流输出。</p>\n</li>\n<li><code>console.trace()</code>向标准错误流输出当前的调用栈。</li>\n</ol>"},{"title":"node.js学习笔记(二)——node.js回调函数与事件","date":"2015-12-02T02:17:50.000Z","_content":"### 一、回调函数\n#### 1.异步读取文件\n```javascript\nvar fs = require('fs');\nfs.readFile('file.txt','utf-8',function(err,data){\n    if(err){\n        console.log(err);\n    }else{\n        console.log(data);\n    }\n});\nconsole.log('end');\n```\n运行结果：\n```\n\"end\"\n\"fileContent\"\n```\n\n#### 2.同步式读取文件\n```javascript\nvar fs = require('fs');\nvar data = fs.readFileSync('file.txt','utf-8');\nconsole.log(data);\nconsole.log('end');\n```\n运行结果:\n```\n\"fileContent\"\n\"end\"\n```\n#### 3.分析\n异步调用时所做的工作只是将异步式I/O请求发送给了操作系统，然后立即返回并执行后面的语句，执行完以后进入事件循环监听事件，当fs接收到I/O请求完成的事件时，事件循环会主动调用回调函数完成后续工作。\n同步则是阻塞等待完成后，继续执行。\n\n### 事件\n#### 1.普通事件的使用\n```javascript\n//声明事件对象\nvar EventEmitter = require('events').EventEmitter;\nvar event1 = new EventEmitter();\n//注册事件\nevent1.on('cky_event',function(){\n    console.log('这是一个自定义事件');\n});\n//触发事件\nsetTimeout(function(){\n    event1.emit('cky_event');\n}, 1000);\n```\n执行结果：\n```\n//1s后\n\"这是一个自定义事件\"\n```\n\n#### 2. node.js的事件循环机制\n1. Node.js在什么时候进入事件循环呢？\n答案是Node.js程序是由事件循环开始，一直在寻找有没有新的没有处理的事件，然后一次去执行处理，直到事件循环结束，所有的逻辑都是事件的回调函数。\n\n2. 如何使用自定义事件呢？\n事件的回调函数在执行过程中，可能会发出IO请求或直接发射(emit)事件，执行完成后再返回这个事件的循环。","source":"_posts/nodeJsStudy2.md","raw":"title: node.js学习笔记(二)——node.js回调函数与事件\ndate: 2015-12-02 10:17:50\ntags: node.js学习笔记\n---\n### 一、回调函数\n#### 1.异步读取文件\n```javascript\nvar fs = require('fs');\nfs.readFile('file.txt','utf-8',function(err,data){\n    if(err){\n        console.log(err);\n    }else{\n        console.log(data);\n    }\n});\nconsole.log('end');\n```\n运行结果：\n```\n\"end\"\n\"fileContent\"\n```\n\n#### 2.同步式读取文件\n```javascript\nvar fs = require('fs');\nvar data = fs.readFileSync('file.txt','utf-8');\nconsole.log(data);\nconsole.log('end');\n```\n运行结果:\n```\n\"fileContent\"\n\"end\"\n```\n#### 3.分析\n异步调用时所做的工作只是将异步式I/O请求发送给了操作系统，然后立即返回并执行后面的语句，执行完以后进入事件循环监听事件，当fs接收到I/O请求完成的事件时，事件循环会主动调用回调函数完成后续工作。\n同步则是阻塞等待完成后，继续执行。\n\n### 事件\n#### 1.普通事件的使用\n```javascript\n//声明事件对象\nvar EventEmitter = require('events').EventEmitter;\nvar event1 = new EventEmitter();\n//注册事件\nevent1.on('cky_event',function(){\n    console.log('这是一个自定义事件');\n});\n//触发事件\nsetTimeout(function(){\n    event1.emit('cky_event');\n}, 1000);\n```\n执行结果：\n```\n//1s后\n\"这是一个自定义事件\"\n```\n\n#### 2. node.js的事件循环机制\n1. Node.js在什么时候进入事件循环呢？\n答案是Node.js程序是由事件循环开始，一直在寻找有没有新的没有处理的事件，然后一次去执行处理，直到事件循环结束，所有的逻辑都是事件的回调函数。\n\n2. 如何使用自定义事件呢？\n事件的回调函数在执行过程中，可能会发出IO请求或直接发射(emit)事件，执行完成后再返回这个事件的循环。","slug":"nodeJsStudy2","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ex9000qer2zojv6x34v","content":"<h3 id=\"一、回调函数\">一、回调函数</h3><h4 id=\"1-异步读取文件\">1.异步读取文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.readFile(<span class=\"string\">'file.txt'</span>,<span class=\"string\">'utf-8'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure>\n<p>运行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"end\"</span></div><div class=\"line\"><span class=\"string\">\"fileContent\"</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"2-同步式读取文件\">2.同步式读取文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'file.txt'</span>,<span class=\"string\">'utf-8'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(data);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure>\n<p>运行结果:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"fileContent\"</span></div><div class=\"line\"><span class=\"string\">\"end\"</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"3-分析\">3.分析</h4><p>异步调用时所做的工作只是将异步式I/O请求发送给了操作系统，然后立即返回并执行后面的语句，执行完以后进入事件循环监听事件，当fs接收到I/O请求完成的事件时，事件循环会主动调用回调函数完成后续工作。<br>同步则是阻塞等待完成后，继续执行。</p>\n<h3 id=\"事件\">事件</h3><h4 id=\"1-普通事件的使用\">1.普通事件的使用</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//声明事件对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>).EventEmitter;</div><div class=\"line\"><span class=\"keyword\">var</span> event1 = <span class=\"keyword\">new</span> EventEmitter();</div><div class=\"line\"><span class=\"comment\">//注册事件</span></div><div class=\"line\">event1.on(<span class=\"string\">'cky_event'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这是一个自定义事件'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//触发事件</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    event1.emit(<span class=\"string\">'cky_event'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1s后</span></div><div class=\"line\"><span class=\"string\">\"这是一个自定义事件\"</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"2-_node-js的事件循环机制\">2. node.js的事件循环机制</h4><ol>\n<li><p>Node.js在什么时候进入事件循环呢？<br>答案是Node.js程序是由事件循环开始，一直在寻找有没有新的没有处理的事件，然后一次去执行处理，直到事件循环结束，所有的逻辑都是事件的回调函数。</p>\n</li>\n<li><p>如何使用自定义事件呢？<br>事件的回调函数在执行过程中，可能会发出IO请求或直接发射(emit)事件，执行完成后再返回这个事件的循环。</p>\n</li>\n</ol>\n","excerpt":"","more":"<h3 id=\"一、回调函数\">一、回调函数</h3><h4 id=\"1-异步读取文件\">1.异步读取文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.readFile(<span class=\"string\">'file.txt'</span>,<span class=\"string\">'utf-8'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure>\n<p>运行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"end\"</span></div><div class=\"line\"><span class=\"string\">\"fileContent\"</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"2-同步式读取文件\">2.同步式读取文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'file.txt'</span>,<span class=\"string\">'utf-8'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(data);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure>\n<p>运行结果:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"fileContent\"</span></div><div class=\"line\"><span class=\"string\">\"end\"</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"3-分析\">3.分析</h4><p>异步调用时所做的工作只是将异步式I/O请求发送给了操作系统，然后立即返回并执行后面的语句，执行完以后进入事件循环监听事件，当fs接收到I/O请求完成的事件时，事件循环会主动调用回调函数完成后续工作。<br>同步则是阻塞等待完成后，继续执行。</p>\n<h3 id=\"事件\">事件</h3><h4 id=\"1-普通事件的使用\">1.普通事件的使用</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//声明事件对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>).EventEmitter;</div><div class=\"line\"><span class=\"keyword\">var</span> event1 = <span class=\"keyword\">new</span> EventEmitter();</div><div class=\"line\"><span class=\"comment\">//注册事件</span></div><div class=\"line\">event1.on(<span class=\"string\">'cky_event'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这是一个自定义事件'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//触发事件</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    event1.emit(<span class=\"string\">'cky_event'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//1s后</span></div><div class=\"line\"><span class=\"string\">\"这是一个自定义事件\"</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"2-_node-js的事件循环机制\">2. node.js的事件循环机制</h4><ol>\n<li><p>Node.js在什么时候进入事件循环呢？<br>答案是Node.js程序是由事件循环开始，一直在寻找有没有新的没有处理的事件，然后一次去执行处理，直到事件循环结束，所有的逻辑都是事件的回调函数。</p>\n</li>\n<li><p>如何使用自定义事件呢？<br>事件的回调函数在执行过程中，可能会发出IO请求或直接发射(emit)事件，执行完成后再返回这个事件的循环。</p>\n</li>\n</ol>\n"},{"title":"node.js学习笔记(三)——模块与包","date":"2015-12-03T02:17:50.000Z","_content":"模块(Module)和包(package)是Node.js最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、分装、然后组合起来。模块正是为了实现这种方式而诞生，而浏览器JavaScript中，脚本模块的拆分和组合通常使用HTML的script标签来实现，Node.js提供了require函数来调用其他模块，而且**模块都是基于文件**，机制非常简单，模块和包的区别是透明的，因此经常不做区分。\n<!-- more  -->\n### 一、模块\n1. #### 什么是模块\n模块和文件是一一对应的。一个Node.js文件就是一个模块，这个文件可能是JavaSript代码、JSON或者编译过的C/C++扩展。\n`var http = require('http')`，其中的`http`是Node.js的一个核心模块，通过require函数获取这个模块，然后使用其中的对象。\n\n2. #### 创建及加载模块\n (1). 创建模块\n Node.js提供了exports和require两个对象，其中exports是模块公开的接口，require用于从外部获取一个模块的接口，即获取模块的exports对象。\n ```javascript\n //module.js\nvar name;\nexports.setName = function(theName){\n    name = theName;\n};\nexports.sayHello = function(){\n    console.log('hello '+ name);\n};\n ```\n ```javascript\n //getModule.js\nvar myModule = require('./module');\nmyModule.setName('cky');\nmyModule.sayHello();\n ```\n 执行getModule.js结果：\n```javascript\n\"hello cky\"\n```\n (2). 单次加载\n  ```javascript\n //getModule2.js\nvar myModule1 = require('./module');\nmyModule1.setName('cky1');\nvar myModule2 = require('./module');\nmyModule2.setName('cky2');\nmyModule1.sayHello();\n```\n 执行getModule2.js结果：\n```javascript\n\"hello cky2\"\n```\n  以上的例子类似创建对象，但是和创建对象有本质区别。因为**require不会重复加载模块**，也就是无论调用多少次require，所获取到的模块都是同一个(见第四点说到的require查找策略)。\n\n (3). 覆盖exports\n 有时候我们只是想把一个对象封装到模块中，就可以这样：\n ```javascript\n //singleObject.js\nfunction hello(){\n    var name;\n    this.setName = function(theName){\n        name = theName;\n    };\n    this.sayHello = function(){\n        console.log('hello' + name);\n    };\n}\nmodule.exports = hello;\n ```\n ```javascript\n //getSingleObject.js\nvar hello = require('./singleObject');\nvar he1 = new hello();\nhe1.setName('cky1');\nhe1.sayHello();\nvar he2 = new hello();\nhe2.setName('cky2');\nhe2.sayHello();\n ```\n 执行getSingleObject.js结果：\n```javascript\n\"hello cky1\"\n\"hello cky2\"\n```\n\n3. #### 模块分类\n Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。\n\n 在文件模块中，又分为3类模块。这三类文件模块以后缀来区分，Node.js会根据后缀名来决定加载方法。\n\n - .js。通过fs模块同步读取js文件并编译执行。\n - .node。通过C/C++进行编写的Addon。通过dlopen方法进行加载。\n - .json。读取文件，调用JSON.parse解析加载。\n\n Node.提供了exports和require两个对象,其中exports是模块公开的接口,require用于从外部获取一个模块接口,即所获取模块的exports对象.\n\n4. #### require查找策略\n __原生模块__在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类__文件模块__是动态加载的，加载速度比原生模块慢。但是Node.js对原生模块和文件模块都进行了缓存，于是在第二次require时，是不会有重复开销的。尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。\n ![require查找策略](http://i12.tietuku.com/c914066941701bb7.jpg)\n\n require方法接受以下几种参数的传递：\n\n - http、fs、path等原生模块。\n - ./mod或../mod，相对路径的文件模块。\n - /pathtomodule/mod，绝对路径的文件模块。\n - mod，非原生模块的文件模块。\n\n 当require一个文件模块时,从当前文件目录开始查找node_modules目录；然后依次进入父目录，查找父目录下的node_modules目录；依次迭代，直到根目录下的node_modules目录。\n\n 简而言之，如果require绝对路径的文件，查找时不会去遍历每一个node_modules目录，其速度最快。其余流程如下：\n\n 1. 从module path数组中取出第一个目录作为查找基准。\n 2. 直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。\n尝试添加.js、.json、.node后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。\n 3. 尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得main参数指定的文件。\n 4. 尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第3条查找。\n 5. 如果继续失败，则取出module path数组中的下一个目录作为基准查找，循环第1至5个步骤。\n 6. 如果继续失败，循环第1至6个步骤，直到module path中的最后一个值。\n 7. 如果仍然失败，则抛出异常。\n\n### 二、包\n1. 包的概念\n    包是在模块基础上更深一步的抽象，Node.js的包类似于C/C++的函数库或者java的类库，他将某个独立的功能封装起来，用于发布、更新、依赖管理的版本控制。开发了npm来解决了包的发布和获取需求。\n\n这个待我之后补充。- -","source":"_posts/nodeJsStudy3.md","raw":"title: node.js学习笔记(三)——模块与包\ndate: 2015-12-03 10:17:50\ntags: node.js学习笔记\n---\n模块(Module)和包(package)是Node.js最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、分装、然后组合起来。模块正是为了实现这种方式而诞生，而浏览器JavaScript中，脚本模块的拆分和组合通常使用HTML的script标签来实现，Node.js提供了require函数来调用其他模块，而且**模块都是基于文件**，机制非常简单，模块和包的区别是透明的，因此经常不做区分。\n<!-- more  -->\n### 一、模块\n1. #### 什么是模块\n模块和文件是一一对应的。一个Node.js文件就是一个模块，这个文件可能是JavaSript代码、JSON或者编译过的C/C++扩展。\n`var http = require('http')`，其中的`http`是Node.js的一个核心模块，通过require函数获取这个模块，然后使用其中的对象。\n\n2. #### 创建及加载模块\n (1). 创建模块\n Node.js提供了exports和require两个对象，其中exports是模块公开的接口，require用于从外部获取一个模块的接口，即获取模块的exports对象。\n ```javascript\n //module.js\nvar name;\nexports.setName = function(theName){\n    name = theName;\n};\nexports.sayHello = function(){\n    console.log('hello '+ name);\n};\n ```\n ```javascript\n //getModule.js\nvar myModule = require('./module');\nmyModule.setName('cky');\nmyModule.sayHello();\n ```\n 执行getModule.js结果：\n```javascript\n\"hello cky\"\n```\n (2). 单次加载\n  ```javascript\n //getModule2.js\nvar myModule1 = require('./module');\nmyModule1.setName('cky1');\nvar myModule2 = require('./module');\nmyModule2.setName('cky2');\nmyModule1.sayHello();\n```\n 执行getModule2.js结果：\n```javascript\n\"hello cky2\"\n```\n  以上的例子类似创建对象，但是和创建对象有本质区别。因为**require不会重复加载模块**，也就是无论调用多少次require，所获取到的模块都是同一个(见第四点说到的require查找策略)。\n\n (3). 覆盖exports\n 有时候我们只是想把一个对象封装到模块中，就可以这样：\n ```javascript\n //singleObject.js\nfunction hello(){\n    var name;\n    this.setName = function(theName){\n        name = theName;\n    };\n    this.sayHello = function(){\n        console.log('hello' + name);\n    };\n}\nmodule.exports = hello;\n ```\n ```javascript\n //getSingleObject.js\nvar hello = require('./singleObject');\nvar he1 = new hello();\nhe1.setName('cky1');\nhe1.sayHello();\nvar he2 = new hello();\nhe2.setName('cky2');\nhe2.sayHello();\n ```\n 执行getSingleObject.js结果：\n```javascript\n\"hello cky1\"\n\"hello cky2\"\n```\n\n3. #### 模块分类\n Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。\n\n 在文件模块中，又分为3类模块。这三类文件模块以后缀来区分，Node.js会根据后缀名来决定加载方法。\n\n - .js。通过fs模块同步读取js文件并编译执行。\n - .node。通过C/C++进行编写的Addon。通过dlopen方法进行加载。\n - .json。读取文件，调用JSON.parse解析加载。\n\n Node.提供了exports和require两个对象,其中exports是模块公开的接口,require用于从外部获取一个模块接口,即所获取模块的exports对象.\n\n4. #### require查找策略\n __原生模块__在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类__文件模块__是动态加载的，加载速度比原生模块慢。但是Node.js对原生模块和文件模块都进行了缓存，于是在第二次require时，是不会有重复开销的。尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。\n ![require查找策略](http://i12.tietuku.com/c914066941701bb7.jpg)\n\n require方法接受以下几种参数的传递：\n\n - http、fs、path等原生模块。\n - ./mod或../mod，相对路径的文件模块。\n - /pathtomodule/mod，绝对路径的文件模块。\n - mod，非原生模块的文件模块。\n\n 当require一个文件模块时,从当前文件目录开始查找node_modules目录；然后依次进入父目录，查找父目录下的node_modules目录；依次迭代，直到根目录下的node_modules目录。\n\n 简而言之，如果require绝对路径的文件，查找时不会去遍历每一个node_modules目录，其速度最快。其余流程如下：\n\n 1. 从module path数组中取出第一个目录作为查找基准。\n 2. 直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。\n尝试添加.js、.json、.node后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。\n 3. 尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得main参数指定的文件。\n 4. 尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第3条查找。\n 5. 如果继续失败，则取出module path数组中的下一个目录作为基准查找，循环第1至5个步骤。\n 6. 如果继续失败，循环第1至6个步骤，直到module path中的最后一个值。\n 7. 如果仍然失败，则抛出异常。\n\n### 二、包\n1. 包的概念\n    包是在模块基础上更深一步的抽象，Node.js的包类似于C/C++的函数库或者java的类库，他将某个独立的功能封装起来，用于发布、更新、依赖管理的版本控制。开发了npm来解决了包的发布和获取需求。\n\n这个待我之后补充。- -","slug":"nodeJsStudy3","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489exa000ser2z28vmmaq8","content":"<p>模块(Module)和包(package)是Node.js最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、分装、然后组合起来。模块正是为了实现这种方式而诞生，而浏览器JavaScript中，脚本模块的拆分和组合通常使用HTML的script标签来实现，Node.js提供了require函数来调用其他模块，而且<strong>模块都是基于文件</strong>，机制非常简单，模块和包的区别是透明的，因此经常不做区分。<br><a id=\"more\"></a></p>\n<h3 id=\"一、模块\">一、模块</h3><ol>\n<li><h4 id=\"什么是模块\">什么是模块</h4><p>模块和文件是一一对应的。一个Node.js文件就是一个模块，这个文件可能是JavaSript代码、JSON或者编译过的C/C++扩展。<br><code>var http = require(&#39;http&#39;)</code>，其中的<code>http</code>是Node.js的一个核心模块，通过require函数获取这个模块，然后使用其中的对象。</p>\n</li>\n<li><h4 id=\"创建及加载模块\">创建及加载模块</h4><p>(1). 创建模块<br>Node.js提供了exports和require两个对象，其中exports是模块公开的接口，require用于从外部获取一个模块的接口，即获取模块的exports对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//module.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> name;</div><div class=\"line\">exports.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">theName</span>)</span>&#123;</div><div class=\"line\">    name = theName;</div><div class=\"line\">&#125;;</div><div class=\"line\">exports.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span>+ name);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//getModule.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> myModule = <span class=\"built_in\">require</span>(<span class=\"string\">'./module'</span>);</div><div class=\"line\">myModule.setName(<span class=\"string\">'cky'</span>);</div><div class=\"line\">myModule.sayHello();</div></pre></td></tr></table></figure>\n<p>执行getModule.js结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello cky\"</span></div></pre></td></tr></table></figure>\n<p>(2). 单次加载</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//getModule2.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> myModule1 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module'</span>);</div><div class=\"line\">myModule1.setName(<span class=\"string\">'cky1'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> myModule2 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module'</span>);</div><div class=\"line\">myModule2.setName(<span class=\"string\">'cky2'</span>);</div><div class=\"line\">myModule1.sayHello();</div></pre></td></tr></table></figure>\n<p>执行getModule2.js结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello cky2\"</span></div></pre></td></tr></table></figure>\n<p>以上的例子类似创建对象，但是和创建对象有本质区别。因为<strong>require不会重复加载模块</strong>，也就是无论调用多少次require，所获取到的模块都是同一个(见第四点说到的require查找策略)。</p>\n<p>(3). 覆盖exports<br>有时候我们只是想把一个对象封装到模块中，就可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//singleObject.js</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">theName</span>)</span>&#123;</div><div class=\"line\">        name = theName;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span> + name);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = hello;</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//getSingleObject.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> hello = <span class=\"built_in\">require</span>(<span class=\"string\">'./singleObject'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> he1 = <span class=\"keyword\">new</span> hello();</div><div class=\"line\">he1.setName(<span class=\"string\">'cky1'</span>);</div><div class=\"line\">he1.sayHello();</div><div class=\"line\"><span class=\"keyword\">var</span> he2 = <span class=\"keyword\">new</span> hello();</div><div class=\"line\">he2.setName(<span class=\"string\">'cky2'</span>);</div><div class=\"line\">he2.sayHello();</div></pre></td></tr></table></figure>\n<p>执行getSingleObject.js结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello cky1\"</span></div><div class=\"line\"><span class=\"string\">\"hello cky2\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"模块分类\">模块分类</h4><p>Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。</p>\n<p>在文件模块中，又分为3类模块。这三类文件模块以后缀来区分，Node.js会根据后缀名来决定加载方法。</p>\n<ul>\n<li>.js。通过fs模块同步读取js文件并编译执行。</li>\n<li>.node。通过C/C++进行编写的Addon。通过dlopen方法进行加载。</li>\n<li>.json。读取文件，调用JSON.parse解析加载。</li>\n</ul>\n<p>Node.提供了exports和require两个对象,其中exports是模块公开的接口,require用于从外部获取一个模块接口,即所获取模块的exports对象.</p>\n</li>\n<li><h4 id=\"require查找策略\">require查找策略</h4><p><strong>原生模块</strong>在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类<strong>文件模块</strong>是动态加载的，加载速度比原生模块慢。但是Node.js对原生模块和文件模块都进行了缓存，于是在第二次require时，是不会有重复开销的。尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。<br><img src=\"http://i12.tietuku.com/c914066941701bb7.jpg\" alt=\"require查找策略\"></p>\n<p>require方法接受以下几种参数的传递：</p>\n<ul>\n<li>http、fs、path等原生模块。</li>\n<li>./mod或../mod，相对路径的文件模块。</li>\n<li>/pathtomodule/mod，绝对路径的文件模块。</li>\n<li>mod，非原生模块的文件模块。</li>\n</ul>\n<p>当require一个文件模块时,从当前文件目录开始查找node_modules目录；然后依次进入父目录，查找父目录下的node_modules目录；依次迭代，直到根目录下的node_modules目录。</p>\n<p>简而言之，如果require绝对路径的文件，查找时不会去遍历每一个node_modules目录，其速度最快。其余流程如下：</p>\n<ol>\n<li>从module path数组中取出第一个目录作为查找基准。</li>\n<li>直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。<br>尝试添加.js、.json、.node后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。</li>\n<li>尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得main参数指定的文件。</li>\n<li>尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第3条查找。</li>\n<li>如果继续失败，则取出module path数组中的下一个目录作为基准查找，循环第1至5个步骤。</li>\n<li>如果继续失败，循环第1至6个步骤，直到module path中的最后一个值。</li>\n<li>如果仍然失败，则抛出异常。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"二、包\">二、包</h3><ol>\n<li>包的概念<br> 包是在模块基础上更深一步的抽象，Node.js的包类似于C/C++的函数库或者java的类库，他将某个独立的功能封装起来，用于发布、更新、依赖管理的版本控制。开发了npm来解决了包的发布和获取需求。</li>\n</ol>\n<p>这个待我之后补充。- -</p>\n","excerpt":"<p>模块(Module)和包(package)是Node.js最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、分装、然后组合起来。模块正是为了实现这种方式而诞生，而浏览器JavaScript中，脚本模块的拆分和组合通常使用HTML的script标签来实现，Node.js提供了require函数来调用其他模块，而且<strong>模块都是基于文件</strong>，机制非常简单，模块和包的区别是透明的，因此经常不做区分。<br>","more":"</p>\n<h3 id=\"一、模块\">一、模块</h3><ol>\n<li><h4 id=\"什么是模块\">什么是模块</h4><p>模块和文件是一一对应的。一个Node.js文件就是一个模块，这个文件可能是JavaSript代码、JSON或者编译过的C/C++扩展。<br><code>var http = require(&#39;http&#39;)</code>，其中的<code>http</code>是Node.js的一个核心模块，通过require函数获取这个模块，然后使用其中的对象。</p>\n</li>\n<li><h4 id=\"创建及加载模块\">创建及加载模块</h4><p>(1). 创建模块<br>Node.js提供了exports和require两个对象，其中exports是模块公开的接口，require用于从外部获取一个模块的接口，即获取模块的exports对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//module.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> name;</div><div class=\"line\">exports.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">theName</span>)</span>&#123;</div><div class=\"line\">    name = theName;</div><div class=\"line\">&#125;;</div><div class=\"line\">exports.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span>+ name);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//getModule.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> myModule = <span class=\"built_in\">require</span>(<span class=\"string\">'./module'</span>);</div><div class=\"line\">myModule.setName(<span class=\"string\">'cky'</span>);</div><div class=\"line\">myModule.sayHello();</div></pre></td></tr></table></figure>\n<p>执行getModule.js结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello cky\"</span></div></pre></td></tr></table></figure>\n<p>(2). 单次加载</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//getModule2.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> myModule1 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module'</span>);</div><div class=\"line\">myModule1.setName(<span class=\"string\">'cky1'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> myModule2 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module'</span>);</div><div class=\"line\">myModule2.setName(<span class=\"string\">'cky2'</span>);</div><div class=\"line\">myModule1.sayHello();</div></pre></td></tr></table></figure>\n<p>执行getModule2.js结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello cky2\"</span></div></pre></td></tr></table></figure>\n<p>以上的例子类似创建对象，但是和创建对象有本质区别。因为<strong>require不会重复加载模块</strong>，也就是无论调用多少次require，所获取到的模块都是同一个(见第四点说到的require查找策略)。</p>\n<p>(3). 覆盖exports<br>有时候我们只是想把一个对象封装到模块中，就可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//singleObject.js</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">theName</span>)</span>&#123;</div><div class=\"line\">        name = theName;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span> + name);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = hello;</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//getSingleObject.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> hello = <span class=\"built_in\">require</span>(<span class=\"string\">'./singleObject'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> he1 = <span class=\"keyword\">new</span> hello();</div><div class=\"line\">he1.setName(<span class=\"string\">'cky1'</span>);</div><div class=\"line\">he1.sayHello();</div><div class=\"line\"><span class=\"keyword\">var</span> he2 = <span class=\"keyword\">new</span> hello();</div><div class=\"line\">he2.setName(<span class=\"string\">'cky2'</span>);</div><div class=\"line\">he2.sayHello();</div></pre></td></tr></table></figure>\n<p>执行getSingleObject.js结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"hello cky1\"</span></div><div class=\"line\"><span class=\"string\">\"hello cky2\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"模块分类\">模块分类</h4><p>Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。</p>\n<p>在文件模块中，又分为3类模块。这三类文件模块以后缀来区分，Node.js会根据后缀名来决定加载方法。</p>\n<ul>\n<li>.js。通过fs模块同步读取js文件并编译执行。</li>\n<li>.node。通过C/C++进行编写的Addon。通过dlopen方法进行加载。</li>\n<li>.json。读取文件，调用JSON.parse解析加载。</li>\n</ul>\n<p>Node.提供了exports和require两个对象,其中exports是模块公开的接口,require用于从外部获取一个模块接口,即所获取模块的exports对象.</p>\n</li>\n<li><h4 id=\"require查找策略\">require查找策略</h4><p><strong>原生模块</strong>在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类<strong>文件模块</strong>是动态加载的，加载速度比原生模块慢。但是Node.js对原生模块和文件模块都进行了缓存，于是在第二次require时，是不会有重复开销的。尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。<br><img src=\"http://i12.tietuku.com/c914066941701bb7.jpg\" alt=\"require查找策略\"></p>\n<p>require方法接受以下几种参数的传递：</p>\n<ul>\n<li>http、fs、path等原生模块。</li>\n<li>./mod或../mod，相对路径的文件模块。</li>\n<li>/pathtomodule/mod，绝对路径的文件模块。</li>\n<li>mod，非原生模块的文件模块。</li>\n</ul>\n<p>当require一个文件模块时,从当前文件目录开始查找node_modules目录；然后依次进入父目录，查找父目录下的node_modules目录；依次迭代，直到根目录下的node_modules目录。</p>\n<p>简而言之，如果require绝对路径的文件，查找时不会去遍历每一个node_modules目录，其速度最快。其余流程如下：</p>\n<ol>\n<li>从module path数组中取出第一个目录作为查找基准。</li>\n<li>直接从目录中查找该文件，如果存在，则结束查找。如果不存在，则进行下一条查找。<br>尝试添加.js、.json、.node后缀后查找，如果存在文件，则结束查找。如果不存在，则进行下一条。</li>\n<li>尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得main参数指定的文件。</li>\n<li>尝试查找该文件，如果存在，则结束查找。如果不存在，则进行第3条查找。</li>\n<li>如果继续失败，则取出module path数组中的下一个目录作为基准查找，循环第1至5个步骤。</li>\n<li>如果继续失败，循环第1至6个步骤，直到module path中的最后一个值。</li>\n<li>如果仍然失败，则抛出异常。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"二、包\">二、包</h3><ol>\n<li>包的概念<br> 包是在模块基础上更深一步的抽象，Node.js的包类似于C/C++的函数库或者java的类库，他将某个独立的功能封装起来，用于发布、更新、依赖管理的版本控制。开发了npm来解决了包的发布和获取需求。</li>\n</ol>\n<p>这个待我之后补充。- -</p>"},{"title":"node.js学习笔记(八)——HTTP客户端","date":"2016-01-06T02:19:50.000Z","_content":"### 一、http模块提供了两个函数http.request和http.get。\n功能是作为客户端向HTTP服务器发起请求。\n#### 1. http.request(options,callback)\nhttp.request发起HTTP请求，接受两个参数，option是一个类似关联数组的对象，表示请求的参数，callback是请求的回调函数，option常用的参数如下：\n\n|参数 |含义|\n|------|-----|\n|host |请求网站的域名或IP地址|\n|port |请求网站的端口，默认是80|\n|method |请求方法，比如GET、POST|\n|path|请求的相对于根的路径，默认是\"/\"。QueryString应该包含在其中，例如/search?query=cky|\n|header |一个关联数组对象，为请求头的内容|\ncallback传递一个参数，为http.ClientResponse的实例。\nhttp.request返回一个http.ClientRequest的实例。\n\n例：\n```javascript\n//clientRequest.js\nvar http = require('http');\nvar querystring = require('querystring');\n//启动服务\nhttp.createServer(function(req,res){\n\tconsole.log('请求到了，解析参数');\n\tvar post = '';\n\treq.on('data',function(chunk){\n\t\tpost+=chunk;\n\t});\n\treq.on('end',function(){\n\t\tpost = querystring.parse(post);\n\t\t//解析完成\n\t\tconsole.log(\"参数解析完成，返回给客户端name参数\");\n\t\tres.end(post.address);\n\t});\n}).listen(3000);\n\n//客户端请求\nvar contents = querystring.stringify({//将JSON对象转换成JSON字符串\n\tname:'cky',\n\tage:21,\n\taddress:'重庆'\n});\nvar options = {\n\thost:'localhost',\n\tpath:'/',\n\tport:3000,\n\tmethod:'POST',\n\theaders:{\n\t\t'Content-Type':'application/x-www-form-urlencoded',\n\t\t'Content-Length':contents.length\n\t}\n}\n//发送请求\nvar req = http.request(options,function(res){\n\tres.setEncoding('utf-8');\n\tres.on('data',function(data){\n\t\tconsole.log('后端返回数据');\n\t\tconsole.log(data);\n\t});\n});\nreq.write(contents);\n//必须调end()\nreq.end();\n```\n执行结果：\n```javascript\n请求到了，解析参数\n参数解析完成，返回给客户端name参数\n后端返回数据\ncky\n```\n#### 2. http.get(options,callback)\n http模块还提供了一个更加简便的方法——http.get。它是http.request的简化版，唯一的区别在于http.get自动将请求方法设为GET请求，同时不需要手动调用req.end()；\n\n 例：\n ```javascript\n//clientGet.js\nvar http = require('http');\nvar url = require('url');\nvar util = require('util');\n//启动服务\nhttp.createServer(function(req,res){\n\tconsole.log('请求到了，解析参数');\n\tvar params = url.parse(req.url,true);\n\tconsole.log('解析完成');\n\tconsole.log(util.inspect(params));\n\tconsole.log('向客户端返回');\n\tres.end(params.query.name);\n}).listen(3000);\n\n//客户端请求\nhttp.get({\n\t'host':'localhost',\n\tpath:'/user?name=cky&age=21',\n\tport:3000},function(res){\n\t\tres.setEncoding('utf-8');\n\t\tres.on('data',function(data){\n\t\t\tconsole.log('服务器端返回来的是：'+ data);\n\t\t});\n\t}\n);\n\n ```\n 执行结果：\n ```javascript\n请求到了，解析参数\n解析完成\nUrl {\n  protocol: null,\n  slashes: null,\n  auth: null,\n  host: null,\n  port: null,\n  hostname: null,\n  hash: null,\n  search: '?name=cky&age=21\n  query: { name: 'cky', age\n  pathname: '/user',\n  path: '/user?name=cky&age\n  href: '/user?name=cky&age\n向客户端返回\n服务器端返回来的是：cky\n ```\n ### 二、http.ClientRequest\n 该对象是由`http.request`或`http.get`返回产生的对象，表示一个已经产生而且正在进行的http请求，它提供了response事件，即`http.request`或`http.get`第二个参数指定的回调函数的绑定对象，__请求必须调用end方法结束请求__\n 提供的函数：\n `request.abort()` 终止正在发送的请求\n `request.setTimeOut(time,[callback])`设置请求超时事件。\n 更多请参考 ：[api文档](http://nodeapi.ucdok.com/#/api/http.html)\n\n ### 三、http.ClientResponse\n`http.ClientResponse`是与`http.Response`相似，提供三个事件，data、end和close，分别在数据到达、传输结束、连接结束时触发。其中data事件传递一个参数chunk，表示接受到的数据。\n res的属性（表示请求的结果状态）：\n\n||\n|-|\n|statusCode|http状态码|\n|httpVersion|http协议版本|\n|headers|HTTP请求头|\n|trailers|HTTP请求尾|\n\nres函数：\n`response.setEncoding([encoding]):`设置默认的编码，当data事件被触发时，数据将以encoding编码，默认为null,以buffer形式储存。\n`response.parse()`:暂停接收数据和发送事件，方便实现下载功能\n`renspose.resume()`:以暂停状态恢复。","source":"_posts/nodeJsStudy8.md","raw":"title: node.js学习笔记(八)——HTTP客户端\ndate: 2016-01-06 10:19:50\ntags: node.js学习笔记\n---\n### 一、http模块提供了两个函数http.request和http.get。\n功能是作为客户端向HTTP服务器发起请求。\n#### 1. http.request(options,callback)\nhttp.request发起HTTP请求，接受两个参数，option是一个类似关联数组的对象，表示请求的参数，callback是请求的回调函数，option常用的参数如下：\n\n|参数 |含义|\n|------|-----|\n|host |请求网站的域名或IP地址|\n|port |请求网站的端口，默认是80|\n|method |请求方法，比如GET、POST|\n|path|请求的相对于根的路径，默认是\"/\"。QueryString应该包含在其中，例如/search?query=cky|\n|header |一个关联数组对象，为请求头的内容|\ncallback传递一个参数，为http.ClientResponse的实例。\nhttp.request返回一个http.ClientRequest的实例。\n\n例：\n```javascript\n//clientRequest.js\nvar http = require('http');\nvar querystring = require('querystring');\n//启动服务\nhttp.createServer(function(req,res){\n\tconsole.log('请求到了，解析参数');\n\tvar post = '';\n\treq.on('data',function(chunk){\n\t\tpost+=chunk;\n\t});\n\treq.on('end',function(){\n\t\tpost = querystring.parse(post);\n\t\t//解析完成\n\t\tconsole.log(\"参数解析完成，返回给客户端name参数\");\n\t\tres.end(post.address);\n\t});\n}).listen(3000);\n\n//客户端请求\nvar contents = querystring.stringify({//将JSON对象转换成JSON字符串\n\tname:'cky',\n\tage:21,\n\taddress:'重庆'\n});\nvar options = {\n\thost:'localhost',\n\tpath:'/',\n\tport:3000,\n\tmethod:'POST',\n\theaders:{\n\t\t'Content-Type':'application/x-www-form-urlencoded',\n\t\t'Content-Length':contents.length\n\t}\n}\n//发送请求\nvar req = http.request(options,function(res){\n\tres.setEncoding('utf-8');\n\tres.on('data',function(data){\n\t\tconsole.log('后端返回数据');\n\t\tconsole.log(data);\n\t});\n});\nreq.write(contents);\n//必须调end()\nreq.end();\n```\n执行结果：\n```javascript\n请求到了，解析参数\n参数解析完成，返回给客户端name参数\n后端返回数据\ncky\n```\n#### 2. http.get(options,callback)\n http模块还提供了一个更加简便的方法——http.get。它是http.request的简化版，唯一的区别在于http.get自动将请求方法设为GET请求，同时不需要手动调用req.end()；\n\n 例：\n ```javascript\n//clientGet.js\nvar http = require('http');\nvar url = require('url');\nvar util = require('util');\n//启动服务\nhttp.createServer(function(req,res){\n\tconsole.log('请求到了，解析参数');\n\tvar params = url.parse(req.url,true);\n\tconsole.log('解析完成');\n\tconsole.log(util.inspect(params));\n\tconsole.log('向客户端返回');\n\tres.end(params.query.name);\n}).listen(3000);\n\n//客户端请求\nhttp.get({\n\t'host':'localhost',\n\tpath:'/user?name=cky&age=21',\n\tport:3000},function(res){\n\t\tres.setEncoding('utf-8');\n\t\tres.on('data',function(data){\n\t\t\tconsole.log('服务器端返回来的是：'+ data);\n\t\t});\n\t}\n);\n\n ```\n 执行结果：\n ```javascript\n请求到了，解析参数\n解析完成\nUrl {\n  protocol: null,\n  slashes: null,\n  auth: null,\n  host: null,\n  port: null,\n  hostname: null,\n  hash: null,\n  search: '?name=cky&age=21\n  query: { name: 'cky', age\n  pathname: '/user',\n  path: '/user?name=cky&age\n  href: '/user?name=cky&age\n向客户端返回\n服务器端返回来的是：cky\n ```\n ### 二、http.ClientRequest\n 该对象是由`http.request`或`http.get`返回产生的对象，表示一个已经产生而且正在进行的http请求，它提供了response事件，即`http.request`或`http.get`第二个参数指定的回调函数的绑定对象，__请求必须调用end方法结束请求__\n 提供的函数：\n `request.abort()` 终止正在发送的请求\n `request.setTimeOut(time,[callback])`设置请求超时事件。\n 更多请参考 ：[api文档](http://nodeapi.ucdok.com/#/api/http.html)\n\n ### 三、http.ClientResponse\n`http.ClientResponse`是与`http.Response`相似，提供三个事件，data、end和close，分别在数据到达、传输结束、连接结束时触发。其中data事件传递一个参数chunk，表示接受到的数据。\n res的属性（表示请求的结果状态）：\n\n||\n|-|\n|statusCode|http状态码|\n|httpVersion|http协议版本|\n|headers|HTTP请求头|\n|trailers|HTTP请求尾|\n\nres函数：\n`response.setEncoding([encoding]):`设置默认的编码，当data事件被触发时，数据将以encoding编码，默认为null,以buffer形式储存。\n`response.parse()`:暂停接收数据和发送事件，方便实现下载功能\n`renspose.resume()`:以暂停状态恢复。","slug":"nodeJsStudy8","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489exc000uer2zsb0v8ml6","content":"<h3 id=\"一、http模块提供了两个函数http-request和http-get。\">一、http模块提供了两个函数http.request和http.get。</h3><p>功能是作为客户端向HTTP服务器发起请求。</p>\n<h4 id=\"1-_http-request(options,callback)\">1. http.request(options,callback)</h4><p>http.request发起HTTP请求，接受两个参数，option是一个类似关联数组的对象，表示请求的参数，callback是请求的回调函数，option常用的参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>host</td>\n<td>请求网站的域名或IP地址</td>\n</tr>\n<tr>\n<td>port</td>\n<td>请求网站的端口，默认是80</td>\n</tr>\n<tr>\n<td>method</td>\n<td>请求方法，比如GET、POST</td>\n</tr>\n<tr>\n<td>path</td>\n<td>请求的相对于根的路径，默认是”/“。QueryString应该包含在其中，例如/search?query=cky</td>\n</tr>\n<tr>\n<td>header</td>\n<td>一个关联数组对象，为请求头的内容</td>\n</tr>\n</tbody>\n</table>\n<p>callback传递一个参数，为http.ClientResponse的实例。<br>http.request返回一个http.ClientRequest的实例。</p>\n<p>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//clientRequest.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</div><div class=\"line\"><span class=\"comment\">//启动服务</span></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'请求到了，解析参数'</span>);</div><div class=\"line\">\t<span class=\"keyword\">var</span> post = <span class=\"string\">''</span>;</div><div class=\"line\">\treq.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk</span>)</span>&#123;</div><div class=\"line\">\t\tpost+=chunk;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\treq.on(<span class=\"string\">'end'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\tpost = querystring.parse(post);</div><div class=\"line\">\t\t<span class=\"comment\">//解析完成</span></div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"参数解析完成，返回给客户端name参数\"</span>);</div><div class=\"line\">\t\tres.end(post.address);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//客户端请求</span></div><div class=\"line\"><span class=\"keyword\">var</span> contents = querystring.stringify(&#123;<span class=\"comment\">//将JSON对象转换成JSON字符串</span></div><div class=\"line\">\tname:<span class=\"string\">'cky'</span>,</div><div class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">21</span>,</div><div class=\"line\">\t<span class=\"attr\">address</span>:<span class=\"string\">'重庆'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> options = &#123;</div><div class=\"line\">\t<span class=\"attr\">host</span>:<span class=\"string\">'localhost'</span>,</div><div class=\"line\">\t<span class=\"attr\">path</span>:<span class=\"string\">'/'</span>,</div><div class=\"line\">\t<span class=\"attr\">port</span>:<span class=\"number\">3000</span>,</div><div class=\"line\">\t<span class=\"attr\">method</span>:<span class=\"string\">'POST'</span>,</div><div class=\"line\">\t<span class=\"attr\">headers</span>:&#123;</div><div class=\"line\">\t\t<span class=\"string\">'Content-Type'</span>:<span class=\"string\">'application/x-www-form-urlencoded'</span>,</div><div class=\"line\">\t\t<span class=\"string\">'Content-Length'</span>:contents.length</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//发送请求</span></div><div class=\"line\"><span class=\"keyword\">var</span> req = http.request(options,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</div><div class=\"line\">\tres.setEncoding(<span class=\"string\">'utf-8'</span>);</div><div class=\"line\">\tres.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'后端返回数据'</span>);</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">req.write(contents);</div><div class=\"line\"><span class=\"comment\">//必须调end()</span></div><div class=\"line\">req.end();</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">请求到了，解析参数</div><div class=\"line\">参数解析完成，返回给客户端name参数</div><div class=\"line\">后端返回数据</div><div class=\"line\">cky</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-_http-get(options,callback)\">2. http.get(options,callback)</h4><p> http模块还提供了一个更加简便的方法——http.get。它是http.request的简化版，唯一的区别在于http.get自动将请求方法设为GET请求，同时不需要手动调用req.end()；</p>\n<p> 例：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//clientGet.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\"><span class=\"comment\">//启动服务</span></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'请求到了，解析参数'</span>);</div><div class=\"line\">\t<span class=\"keyword\">var</span> params = url.parse(req.url,<span class=\"literal\">true</span>);</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'解析完成'</span>);</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(util.inspect(params));</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'向客户端返回'</span>);</div><div class=\"line\">\tres.end(params.query.name);</div><div class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//客户端请求</span></div><div class=\"line\">http.get(&#123;</div><div class=\"line\">\t<span class=\"string\">'host'</span>:<span class=\"string\">'localhost'</span>,</div><div class=\"line\">\t<span class=\"attr\">path</span>:<span class=\"string\">'/user?name=cky&amp;age=21'</span>,</div><div class=\"line\">\t<span class=\"attr\">port</span>:<span class=\"number\">3000</span>&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</div><div class=\"line\">\t\tres.setEncoding(<span class=\"string\">'utf-8'</span>);</div><div class=\"line\">\t\tres.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'服务器端返回来的是：'</span>+ data);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p> 执行结果：<br> <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">请求到了，解析参数</div><div class=\"line\">解析完成</div><div class=\"line\">Url &#123;</div><div class=\"line\">  protocol: null,</div><div class=\"line\">  slashes: null,</div><div class=\"line\">  auth: null,</div><div class=\"line\">  host: null,</div><div class=\"line\">  port: null,</div><div class=\"line\">  hostname: null,</div><div class=\"line\">  hash: null,</div><div class=\"line\">  search: '?name=cky&amp;age=21</div><div class=\"line\">  query: &#123; name: 'cky', age</div><div class=\"line\">  pathname: '/user',</div><div class=\"line\">  path: '/user?name=cky&amp;age</div><div class=\"line\">  href: '/user?name=cky&amp;age</div><div class=\"line\">向客户端返回</div><div class=\"line\">服务器端返回来的是：cky</div></pre></td></tr></table></figure></p>\n<h3 id=\"二、http-ClientRequest\">二、http.ClientRequest</h3><p> 该对象是由<code>http.request</code>或<code>http.get</code>返回产生的对象，表示一个已经产生而且正在进行的http请求，它提供了response事件，即<code>http.request</code>或<code>http.get</code>第二个参数指定的回调函数的绑定对象，<strong>请求必须调用end方法结束请求</strong><br> 提供的函数：<br> <code>request.abort()</code> 终止正在发送的请求<br> <code>request.setTimeOut(time,[callback])</code>设置请求超时事件。<br> 更多请参考 ：<a href=\"http://nodeapi.ucdok.com/#/api/http.html\" target=\"_blank\" rel=\"external\">api文档</a></p>\n<h3 id=\"三、http-ClientResponse\">三、http.ClientResponse</h3><p><code>http.ClientResponse</code>是与<code>http.Response</code>相似，提供三个事件，data、end和close，分别在数据到达、传输结束、连接结束时触发。其中data事件传递一个参数chunk，表示接受到的数据。<br> res的属性（表示请求的结果状态）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>statusCode</td>\n<td>http状态码</td>\n</tr>\n<tr>\n<td>httpVersion</td>\n<td>http协议版本</td>\n</tr>\n<tr>\n<td>headers</td>\n<td>HTTP请求头</td>\n</tr>\n<tr>\n<td>trailers</td>\n<td>HTTP请求尾</td>\n</tr>\n</tbody>\n</table>\n<p>res函数：<br><code>response.setEncoding([encoding]):</code>设置默认的编码，当data事件被触发时，数据将以encoding编码，默认为null,以buffer形式储存。<br><code>response.parse()</code>:暂停接收数据和发送事件，方便实现下载功能<br><code>renspose.resume()</code>:以暂停状态恢复。</p>\n","excerpt":"","more":"<h3 id=\"一、http模块提供了两个函数http-request和http-get。\">一、http模块提供了两个函数http.request和http.get。</h3><p>功能是作为客户端向HTTP服务器发起请求。</p>\n<h4 id=\"1-_http-request(options,callback)\">1. http.request(options,callback)</h4><p>http.request发起HTTP请求，接受两个参数，option是一个类似关联数组的对象，表示请求的参数，callback是请求的回调函数，option常用的参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>host</td>\n<td>请求网站的域名或IP地址</td>\n</tr>\n<tr>\n<td>port</td>\n<td>请求网站的端口，默认是80</td>\n</tr>\n<tr>\n<td>method</td>\n<td>请求方法，比如GET、POST</td>\n</tr>\n<tr>\n<td>path</td>\n<td>请求的相对于根的路径，默认是”/“。QueryString应该包含在其中，例如/search?query=cky</td>\n</tr>\n<tr>\n<td>header</td>\n<td>一个关联数组对象，为请求头的内容</td>\n</tr>\n</tbody>\n</table>\n<p>callback传递一个参数，为http.ClientResponse的实例。<br>http.request返回一个http.ClientRequest的实例。</p>\n<p>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//clientRequest.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</div><div class=\"line\"><span class=\"comment\">//启动服务</span></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'请求到了，解析参数'</span>);</div><div class=\"line\">\t<span class=\"keyword\">var</span> post = <span class=\"string\">''</span>;</div><div class=\"line\">\treq.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk</span>)</span>&#123;</div><div class=\"line\">\t\tpost+=chunk;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\treq.on(<span class=\"string\">'end'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\tpost = querystring.parse(post);</div><div class=\"line\">\t\t<span class=\"comment\">//解析完成</span></div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"参数解析完成，返回给客户端name参数\"</span>);</div><div class=\"line\">\t\tres.end(post.address);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//客户端请求</span></div><div class=\"line\"><span class=\"keyword\">var</span> contents = querystring.stringify(&#123;<span class=\"comment\">//将JSON对象转换成JSON字符串</span></div><div class=\"line\">\tname:<span class=\"string\">'cky'</span>,</div><div class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">21</span>,</div><div class=\"line\">\t<span class=\"attr\">address</span>:<span class=\"string\">'重庆'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> options = &#123;</div><div class=\"line\">\t<span class=\"attr\">host</span>:<span class=\"string\">'localhost'</span>,</div><div class=\"line\">\t<span class=\"attr\">path</span>:<span class=\"string\">'/'</span>,</div><div class=\"line\">\t<span class=\"attr\">port</span>:<span class=\"number\">3000</span>,</div><div class=\"line\">\t<span class=\"attr\">method</span>:<span class=\"string\">'POST'</span>,</div><div class=\"line\">\t<span class=\"attr\">headers</span>:&#123;</div><div class=\"line\">\t\t<span class=\"string\">'Content-Type'</span>:<span class=\"string\">'application/x-www-form-urlencoded'</span>,</div><div class=\"line\">\t\t<span class=\"string\">'Content-Length'</span>:contents.length</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//发送请求</span></div><div class=\"line\"><span class=\"keyword\">var</span> req = http.request(options,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</div><div class=\"line\">\tres.setEncoding(<span class=\"string\">'utf-8'</span>);</div><div class=\"line\">\tres.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'后端返回数据'</span>);</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">req.write(contents);</div><div class=\"line\"><span class=\"comment\">//必须调end()</span></div><div class=\"line\">req.end();</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">请求到了，解析参数</div><div class=\"line\">参数解析完成，返回给客户端name参数</div><div class=\"line\">后端返回数据</div><div class=\"line\">cky</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-_http-get(options,callback)\">2. http.get(options,callback)</h4><p> http模块还提供了一个更加简便的方法——http.get。它是http.request的简化版，唯一的区别在于http.get自动将请求方法设为GET请求，同时不需要手动调用req.end()；</p>\n<p> 例：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//clientGet.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\"><span class=\"comment\">//启动服务</span></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'请求到了，解析参数'</span>);</div><div class=\"line\">\t<span class=\"keyword\">var</span> params = url.parse(req.url,<span class=\"literal\">true</span>);</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'解析完成'</span>);</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(util.inspect(params));</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'向客户端返回'</span>);</div><div class=\"line\">\tres.end(params.query.name);</div><div class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//客户端请求</span></div><div class=\"line\">http.get(&#123;</div><div class=\"line\">\t<span class=\"string\">'host'</span>:<span class=\"string\">'localhost'</span>,</div><div class=\"line\">\t<span class=\"attr\">path</span>:<span class=\"string\">'/user?name=cky&amp;age=21'</span>,</div><div class=\"line\">\t<span class=\"attr\">port</span>:<span class=\"number\">3000</span>&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</div><div class=\"line\">\t\tres.setEncoding(<span class=\"string\">'utf-8'</span>);</div><div class=\"line\">\t\tres.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'服务器端返回来的是：'</span>+ data);</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">);</div></pre></td></tr></table></figure></p>\n<p> 执行结果：<br> <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">请求到了，解析参数</div><div class=\"line\">解析完成</div><div class=\"line\">Url &#123;</div><div class=\"line\">  protocol: null,</div><div class=\"line\">  slashes: null,</div><div class=\"line\">  auth: null,</div><div class=\"line\">  host: null,</div><div class=\"line\">  port: null,</div><div class=\"line\">  hostname: null,</div><div class=\"line\">  hash: null,</div><div class=\"line\">  search: '?name=cky&amp;age=21</div><div class=\"line\">  query: &#123; name: 'cky', age</div><div class=\"line\">  pathname: '/user',</div><div class=\"line\">  path: '/user?name=cky&amp;age</div><div class=\"line\">  href: '/user?name=cky&amp;age</div><div class=\"line\">向客户端返回</div><div class=\"line\">服务器端返回来的是：cky</div></pre></td></tr></table></figure></p>\n<h3 id=\"二、http-ClientRequest\">二、http.ClientRequest</h3><p> 该对象是由<code>http.request</code>或<code>http.get</code>返回产生的对象，表示一个已经产生而且正在进行的http请求，它提供了response事件，即<code>http.request</code>或<code>http.get</code>第二个参数指定的回调函数的绑定对象，<strong>请求必须调用end方法结束请求</strong><br> 提供的函数：<br> <code>request.abort()</code> 终止正在发送的请求<br> <code>request.setTimeOut(time,[callback])</code>设置请求超时事件。<br> 更多请参考 ：<a href=\"http://nodeapi.ucdok.com/#/api/http.html\">api文档</a></p>\n<h3 id=\"三、http-ClientResponse\">三、http.ClientResponse</h3><p><code>http.ClientResponse</code>是与<code>http.Response</code>相似，提供三个事件，data、end和close，分别在数据到达、传输结束、连接结束时触发。其中data事件传递一个参数chunk，表示接受到的数据。<br> res的属性（表示请求的结果状态）：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>statusCode</td>\n<td>http状态码</td>\n</tr>\n<tr>\n<td>httpVersion</td>\n<td>http协议版本</td>\n</tr>\n<tr>\n<td>headers</td>\n<td>HTTP请求头</td>\n</tr>\n<tr>\n<td>trailers</td>\n<td>HTTP请求尾</td>\n</tr>\n</tbody>\n</table>\n<p>res函数：<br><code>response.setEncoding([encoding]):</code>设置默认的编码，当data事件被触发时，数据将以encoding编码，默认为null,以buffer形式储存。<br><code>response.parse()</code>:暂停接收数据和发送事件，方便实现下载功能<br><code>renspose.resume()</code>:以暂停状态恢复。</p>\n"},{"title":"node.js学习笔记(六)——文件操作","date":"2016-01-04T02:18:50.000Z","_content":"fs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接POSIX文件系统操作。与其他模块不同的是，*fs模块中的所有操作都提供了异步和同步两个版本，*例如读取文件内容函数的异步方法：readFile(),同步方法readFileSync()。\n<!-- more -->\n#### 一、`fs.readFile(filename,[encoding],[callback(err,data)])`是最简单的读取文件函数。\n参数：\nfilename：读取的文件名。\nencoding：文件的字符编码。 \ncallback 回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。如果指定了encoding，data是一个解析后的字符串，否则将会以buffer形式表示的二进制数据。\n例1：\n```javascript\n//异步读取文件\n//file.txt内容为\"哈哈哈\"\nvar fs = require('fs');\nfs.readFile('file.txt','utf-8',function(err,data){\n    if(err){\n        console.log(err);\n    }else{\n        console.log(data);\n    }\n});\nconsole.log('end');\n```\n执行结果：\n```javascript\nend\n哈哈哈\n```\n#### 二、fs.readFileSync(filename,[encoding])\n同步读取文件接受的参数和fs.readFile()相同，而读取到的文件内容会以函数返回值的形式返回，如果有错误发生，fs将抛出异常，你需要try和catch捕获并处理异常。\n例2；\n```javascript\n//同步读取文件\nvar fs = require('fs');\ntry{\n    var data = fs.readFileSync('file1.txt','utf-8');\n    console.log(data);\n    console.log('end');\n}catch(e){\n    console.log(e);\n}\n\n```\n执行结果：\n```javascript\n哈哈哈\nend\n```\n#### 三、fs.open(path,flags,[mode],[callback(err,fd)])\n是POSIXopen函数的封装，与C语言标准库中的fopen函数类似，它接受两个必选参数。\npath为文件路径，\nflag可以为以下值：\n\n| 值       | 作用           |\n| ---------|-------------| \n| r  | 以只读模式打开文件 | \n| r+ | 以读写模式打开文件 |\n| w  | 以写入模式打开文件，如果文件不存在则创建 |\n| w+ | 以读写模式打开文件，如果文件不存在则创建 | \n| a  | 以追加模式打开文件，如果文件不存在则创建 |\n| a+ | 以读取追加模式打开文件，如果文件不存在则创建 |\n\nmode:用于创建文件时给文件指定权限，默认是0666，回调函数将会传递一个文件描述符fd。\n0666:文件权限值POSIX系统中对文件读取和访问权限的范围，通常用八进制数表示。0754表示文件所有者权限是7（读、写、执行），同组用户权限是5（读、执行），其他用户的权限是4（读）。\nfd:文件描述是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引。\n\n#### 四、fs.read(fd,buffer,offset,length,position,[callback(err,bytesRead,buffer)])\n是POSIX中read函数的封装，相比readFild()提供了更底层的接口，从指定的文件描述fd中读取数据并写入。\nfd:指定的文件描述\nbuffer:指向的缓存区对象，\noffset:是buffer的写入偏量值\nlength:读取的字节数\nposition:文件读取的起始数，如果为null，则从当前文件指针读取。\n回调函数传递err,bytesRead和buffer，分别表示读取的字节数和缓冲区对象。\n例：\n```javascript\nvar fs = require('fs');\nfs.open('file.txt','r',function(err,fd){\n    if(err){\n        console.log(err);\n        return;\n    }\n    var buf = new Buffer(8);\n    fs.read(fd,buf,0,8,null,function(err,bytesRead,buffer){\n        if(err){\n            console.log(err);\n            return;\n        }\n        console.log('bytesRead '+bytesRead);\n        console.log(buffer);\n    });\n});\n\n```\n执行结果：\n```javascript\nbytesRead 8\n<Buffer e5 95 a6 e5 95 a6 e5 95>\n```\n更多内容请参考[api手册](http://nodeapi.ucdok.com/#/api/fs.html)","source":"_posts/nodeJsStudy6.md","raw":"title: node.js学习笔记(六)——文件操作\ndate: 2016-01-04 10:18:50\ntags: node.js学习笔记\n---\nfs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接POSIX文件系统操作。与其他模块不同的是，*fs模块中的所有操作都提供了异步和同步两个版本，*例如读取文件内容函数的异步方法：readFile(),同步方法readFileSync()。\n<!-- more -->\n#### 一、`fs.readFile(filename,[encoding],[callback(err,data)])`是最简单的读取文件函数。\n参数：\nfilename：读取的文件名。\nencoding：文件的字符编码。 \ncallback 回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。如果指定了encoding，data是一个解析后的字符串，否则将会以buffer形式表示的二进制数据。\n例1：\n```javascript\n//异步读取文件\n//file.txt内容为\"哈哈哈\"\nvar fs = require('fs');\nfs.readFile('file.txt','utf-8',function(err,data){\n    if(err){\n        console.log(err);\n    }else{\n        console.log(data);\n    }\n});\nconsole.log('end');\n```\n执行结果：\n```javascript\nend\n哈哈哈\n```\n#### 二、fs.readFileSync(filename,[encoding])\n同步读取文件接受的参数和fs.readFile()相同，而读取到的文件内容会以函数返回值的形式返回，如果有错误发生，fs将抛出异常，你需要try和catch捕获并处理异常。\n例2；\n```javascript\n//同步读取文件\nvar fs = require('fs');\ntry{\n    var data = fs.readFileSync('file1.txt','utf-8');\n    console.log(data);\n    console.log('end');\n}catch(e){\n    console.log(e);\n}\n\n```\n执行结果：\n```javascript\n哈哈哈\nend\n```\n#### 三、fs.open(path,flags,[mode],[callback(err,fd)])\n是POSIXopen函数的封装，与C语言标准库中的fopen函数类似，它接受两个必选参数。\npath为文件路径，\nflag可以为以下值：\n\n| 值       | 作用           |\n| ---------|-------------| \n| r  | 以只读模式打开文件 | \n| r+ | 以读写模式打开文件 |\n| w  | 以写入模式打开文件，如果文件不存在则创建 |\n| w+ | 以读写模式打开文件，如果文件不存在则创建 | \n| a  | 以追加模式打开文件，如果文件不存在则创建 |\n| a+ | 以读取追加模式打开文件，如果文件不存在则创建 |\n\nmode:用于创建文件时给文件指定权限，默认是0666，回调函数将会传递一个文件描述符fd。\n0666:文件权限值POSIX系统中对文件读取和访问权限的范围，通常用八进制数表示。0754表示文件所有者权限是7（读、写、执行），同组用户权限是5（读、执行），其他用户的权限是4（读）。\nfd:文件描述是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引。\n\n#### 四、fs.read(fd,buffer,offset,length,position,[callback(err,bytesRead,buffer)])\n是POSIX中read函数的封装，相比readFild()提供了更底层的接口，从指定的文件描述fd中读取数据并写入。\nfd:指定的文件描述\nbuffer:指向的缓存区对象，\noffset:是buffer的写入偏量值\nlength:读取的字节数\nposition:文件读取的起始数，如果为null，则从当前文件指针读取。\n回调函数传递err,bytesRead和buffer，分别表示读取的字节数和缓冲区对象。\n例：\n```javascript\nvar fs = require('fs');\nfs.open('file.txt','r',function(err,fd){\n    if(err){\n        console.log(err);\n        return;\n    }\n    var buf = new Buffer(8);\n    fs.read(fd,buf,0,8,null,function(err,bytesRead,buffer){\n        if(err){\n            console.log(err);\n            return;\n        }\n        console.log('bytesRead '+bytesRead);\n        console.log(buffer);\n    });\n});\n\n```\n执行结果：\n```javascript\nbytesRead 8\n<Buffer e5 95 a6 e5 95 a6 e5 95>\n```\n更多内容请参考[api手册](http://nodeapi.ucdok.com/#/api/fs.html)","slug":"nodeJsStudy6","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489exd000wer2z6inz343u","content":"<p>fs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接POSIX文件系统操作。与其他模块不同的是，<em>fs模块中的所有操作都提供了异步和同步两个版本，</em>例如读取文件内容函数的异步方法：readFile(),同步方法readFileSync()。<br><a id=\"more\"></a></p>\n<h4 id=\"一、fs-readFile(filename,[encoding],[callback(err,data)])是最简单的读取文件函数。\">一、<code>fs.readFile(filename,[encoding],[callback(err,data)])</code>是最简单的读取文件函数。</h4><p>参数：<br>filename：读取的文件名。<br>encoding：文件的字符编码。<br>callback 回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。如果指定了encoding，data是一个解析后的字符串，否则将会以buffer形式表示的二进制数据。<br>例1：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//异步读取文件</span></div><div class=\"line\"><span class=\"comment\">//file.txt内容为\"哈哈哈\"</span></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.readFile(<span class=\"string\">'file.txt'</span>,<span class=\"string\">'utf-8'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">end</div><div class=\"line\">哈哈哈</div></pre></td></tr></table></figure></p>\n<h4 id=\"二、fs-readFileSync(filename,[encoding])\">二、fs.readFileSync(filename,[encoding])</h4><p>同步读取文件接受的参数和fs.readFile()相同，而读取到的文件内容会以函数返回值的形式返回，如果有错误发生，fs将抛出异常，你需要try和catch捕获并处理异常。<br>例2；<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//同步读取文件</span></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'file1.txt'</span>,<span class=\"string\">'utf-8'</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(e)&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(e);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">哈哈哈</div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<h4 id=\"三、fs-open(path,flags,[mode],[callback(err,fd)])\">三、fs.open(path,flags,[mode],[callback(err,fd)])</h4><p>是POSIXopen函数的封装，与C语言标准库中的fopen函数类似，它接受两个必选参数。<br>path为文件路径，<br>flag可以为以下值：</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>r</td>\n<td>以只读模式打开文件</td>\n</tr>\n<tr>\n<td>r+</td>\n<td>以读写模式打开文件</td>\n</tr>\n<tr>\n<td>w</td>\n<td>以写入模式打开文件，如果文件不存在则创建</td>\n</tr>\n<tr>\n<td>w+</td>\n<td>以读写模式打开文件，如果文件不存在则创建</td>\n</tr>\n<tr>\n<td>a</td>\n<td>以追加模式打开文件，如果文件不存在则创建</td>\n</tr>\n<tr>\n<td>a+</td>\n<td>以读取追加模式打开文件，如果文件不存在则创建</td>\n</tr>\n</tbody>\n</table>\n<p>mode:用于创建文件时给文件指定权限，默认是0666，回调函数将会传递一个文件描述符fd。<br>0666:文件权限值POSIX系统中对文件读取和访问权限的范围，通常用八进制数表示。0754表示文件所有者权限是7（读、写、执行），同组用户权限是5（读、执行），其他用户的权限是4（读）。<br>fd:文件描述是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引。</p>\n<h4 id=\"四、fs-read(fd,buffer,offset,length,position,[callback(err,bytesRead,buffer)])\">四、fs.read(fd,buffer,offset,length,position,[callback(err,bytesRead,buffer)])</h4><p>是POSIX中read函数的封装，相比readFild()提供了更底层的接口，从指定的文件描述fd中读取数据并写入。<br>fd:指定的文件描述<br>buffer:指向的缓存区对象，<br>offset:是buffer的写入偏量值<br>length:读取的字节数<br>position:文件读取的起始数，如果为null，则从当前文件指针读取。<br>回调函数传递err,bytesRead和buffer，分别表示读取的字节数和缓冲区对象。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.open(<span class=\"string\">'file.txt'</span>,<span class=\"string\">'r'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,fd</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">8</span>);</div><div class=\"line\">    fs.read(fd,buf,<span class=\"number\">0</span>,<span class=\"number\">8</span>,<span class=\"literal\">null</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,bytesRead,buffer</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'bytesRead '</span>+bytesRead);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(buffer);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">bytesRead <span class=\"number\">8</span></div><div class=\"line\">&lt;Buffer e5 <span class=\"number\">95</span> a6 e5 <span class=\"number\">95</span> a6 e5 <span class=\"number\">95</span>&gt;</div></pre></td></tr></table></figure></p>\n<p>更多内容请参考<a href=\"http://nodeapi.ucdok.com/#/api/fs.html\" target=\"_blank\" rel=\"external\">api手册</a></p>\n","excerpt":"<p>fs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接POSIX文件系统操作。与其他模块不同的是，<em>fs模块中的所有操作都提供了异步和同步两个版本，</em>例如读取文件内容函数的异步方法：readFile(),同步方法readFileSync()。<br>","more":"</p>\n<h4 id=\"一、fs-readFile(filename,[encoding],[callback(err,data)])是最简单的读取文件函数。\">一、<code>fs.readFile(filename,[encoding],[callback(err,data)])</code>是最简单的读取文件函数。</h4><p>参数：<br>filename：读取的文件名。<br>encoding：文件的字符编码。<br>callback 回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。如果指定了encoding，data是一个解析后的字符串，否则将会以buffer形式表示的二进制数据。<br>例1：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//异步读取文件</span></div><div class=\"line\"><span class=\"comment\">//file.txt内容为\"哈哈哈\"</span></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.readFile(<span class=\"string\">'file.txt'</span>,<span class=\"string\">'utf-8'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">end</div><div class=\"line\">哈哈哈</div></pre></td></tr></table></figure></p>\n<h4 id=\"二、fs-readFileSync(filename,[encoding])\">二、fs.readFileSync(filename,[encoding])</h4><p>同步读取文件接受的参数和fs.readFile()相同，而读取到的文件内容会以函数返回值的形式返回，如果有错误发生，fs将抛出异常，你需要try和catch捕获并处理异常。<br>例2；<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//同步读取文件</span></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'file1.txt'</span>,<span class=\"string\">'utf-8'</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(e)&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(e);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">哈哈哈</div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<h4 id=\"三、fs-open(path,flags,[mode],[callback(err,fd)])\">三、fs.open(path,flags,[mode],[callback(err,fd)])</h4><p>是POSIXopen函数的封装，与C语言标准库中的fopen函数类似，它接受两个必选参数。<br>path为文件路径，<br>flag可以为以下值：</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>r</td>\n<td>以只读模式打开文件</td>\n</tr>\n<tr>\n<td>r+</td>\n<td>以读写模式打开文件</td>\n</tr>\n<tr>\n<td>w</td>\n<td>以写入模式打开文件，如果文件不存在则创建</td>\n</tr>\n<tr>\n<td>w+</td>\n<td>以读写模式打开文件，如果文件不存在则创建</td>\n</tr>\n<tr>\n<td>a</td>\n<td>以追加模式打开文件，如果文件不存在则创建</td>\n</tr>\n<tr>\n<td>a+</td>\n<td>以读取追加模式打开文件，如果文件不存在则创建</td>\n</tr>\n</tbody>\n</table>\n<p>mode:用于创建文件时给文件指定权限，默认是0666，回调函数将会传递一个文件描述符fd。<br>0666:文件权限值POSIX系统中对文件读取和访问权限的范围，通常用八进制数表示。0754表示文件所有者权限是7（读、写、执行），同组用户权限是5（读、执行），其他用户的权限是4（读）。<br>fd:文件描述是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引。</p>\n<h4 id=\"四、fs-read(fd,buffer,offset,length,position,[callback(err,bytesRead,buffer)])\">四、fs.read(fd,buffer,offset,length,position,[callback(err,bytesRead,buffer)])</h4><p>是POSIX中read函数的封装，相比readFild()提供了更底层的接口，从指定的文件描述fd中读取数据并写入。<br>fd:指定的文件描述<br>buffer:指向的缓存区对象，<br>offset:是buffer的写入偏量值<br>length:读取的字节数<br>position:文件读取的起始数，如果为null，则从当前文件指针读取。<br>回调函数传递err,bytesRead和buffer，分别表示读取的字节数和缓冲区对象。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.open(<span class=\"string\">'file.txt'</span>,<span class=\"string\">'r'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,fd</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">8</span>);</div><div class=\"line\">    fs.read(fd,buf,<span class=\"number\">0</span>,<span class=\"number\">8</span>,<span class=\"literal\">null</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,bytesRead,buffer</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(err)&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'bytesRead '</span>+bytesRead);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(buffer);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">bytesRead <span class=\"number\">8</span></div><div class=\"line\">&lt;Buffer e5 <span class=\"number\">95</span> a6 e5 <span class=\"number\">95</span> a6 e5 <span class=\"number\">95</span>&gt;</div></pre></td></tr></table></figure></p>\n<p>更多内容请参考<a href=\"http://nodeapi.ucdok.com/#/api/fs.html\">api手册</a></p>"},{"title":"node.js学习笔记(七)——HTTP服务器","date":"2016-01-06T02:17:50.000Z","_content":"node.js提供了http模块。其中封装了一个高效的HTTP服务器和一个简易的HTTP客户端。\nhttp.server是一个基于事件的HTTP服务器。内部有C++实现。接口由javascript封装。\nhttp.request则是一个HTTP客户端工具。用户向服务器发送请求。\n<!-- more -->\n### 一、HTTP服务器\nhttp.Server实现的，它提供了一套封装级别很低的API，仅仅是流控制和简单的解析，所有的高层功能都要通过它的接口。\n例：\n```javascript\n//引入模块\nvar http = require('http');\n//创建服务\nhttp.createServer(function(req,res){\n    //响应头\n    res.writeHead(200,{'Content-Type':'text/html'});\n    //响应内容\n    res.write(\"<h1>Node.wqewqewqjs</h1>\");\n    //结束响应\n    res.end('<p>PCAT</p>');\n//监听端口\n}).listen('3000');\nconsole.log('HTTP server is listening at port 3000');\n```\n执行后访问结果：\n![](http://i4.tietuku.com/7ef205ca829b96f0.png)\n\n代码分析：\nhttp.creatServer()创建了一个http.Server的实例，将一个函数作为HTTP请求处理函数。这个函数接受两个参数，请求对象req和响应对象res。res显式地写入了响应代码200（表示请求成功），指定响应头，写入响应体，调用end结束并发送。该实例调用listen函数，启动服务器并监听3000端口。\n#### 1.http.server事件\nhttp.server是一个基于事件的HTTP服务器，所有请求都被封装成独立的事件，开发者只要对它的事件编写相应的函数即可实现HTTP服务器的所有功能，它继承于EventEmitter，提供了以下事件：\n**request**：当客户端请求到来时，该事件被触发，提供两个参数req和res，分别是http.ServerRequest和http.ServerResponse的实例，表示请求和响应信息。\n例：\n在上面代码的`http.creatServer()`回调函数中，加入一句`console.log(req.url);`\n当在浏览器中输入路径`http://localhost:3000/user?name=cky`时。\n结果：\n![](http://i4.tietuku.com/3316acda98d8a698.jpg)\n**connection**：当TCP连接建立时，该事件被触发，提供了一个参数socket，为net.Socket的实例（底层协议对象）。\n**close**：当服务器关闭时，该事件被触发。\n最常用和关心的是：request事件，http提供了一个捷径：http.createServer()方法。不需要原生创建。\n原生创建方法：\n```javascript\nvar http = require('http');\nvar server = new http.Server();\nserver.on('request',function(req,res){\n    res.writeHead(200,{'Content-Type':'text/html'});\n    res.write(\"<h1>Node.wqewqewqjs</h1>\");\n    res.end('<p>PCAT</p>');\n});\nserver.listen('3000')\n```\n更多详细内容，见[api文档](http://nodeapi.ucdok.com/#/api/http.html);\n\n#### 2.http.ServerRequest，请求的信息\n此对象是后端开发者最关注的内容，它一般由http.Server的request事件发送，作为第一个参数传递，通常简写成request或req。HTTP请求分为两部分：请求头和请求体。请求内容短的直接在请求头解析完成后立即读取，而请求体可能相对较长，需要一定时间传输，因此提供了三个时间用于控制请求体传输。\n- data:当请求体数据到来时，该事件被触发，该事件有一个参数chunk,表示接收到的数据。\n- end：当请求体数据传输完成时，该事件被触发，伺候将不会再有数据到来，\n- close: 用户当前请求结束时，该事件被触发，不同于end，如果用户强制终止了传输，也会触发close。\n\n__ServerRequest的属性：__\n\n| 属性       | 含义           |\n| ---------|-------------| \n| complete  | 客户端请求是否已经发送完成 | \n| httpVersion | HTTP协议版本，通常是1.0或1.1 |\n| method  | HTTP请求方法，如GET,POST |\n| url | 原始的请求路径 | \n| headers | HTTP请求头 |\n| trailers| HTTP请求尾（不常见） |\n| connection | 当前HTTP连接套接字，为net.Socket的实例 | \n| socket | connection属性的别名 |\n| client| client属性的别名 |\n\n#### 3.获取GET请求内容\n由于GET请求直接被嵌入在路径中，URL完成的请求路径，包括了？后面的部分，因此你可以手动解析。node.js的url模块中的parse函数也提供了这个功能。\n例：\n```javascript\n//引入模块\nvar http = require('http');\nvar urls = require('url');\nvar util = require('util');\n//创建服务\nhttp.createServer(function(req,res){\n    res.writeHead(2000,{'Content-Type':'text/plain'});\n    //解析并打成字符串返回给客户端\n    res.end(util.inspect(urls.parse(req.url,true)));\n}).listen(3000);\n```\n执行结果：\n![](http://i4.tietuku.com/6703100aee0d87f1.jpg)\n\n#### 4.获取POST请求的内容\nPOST请求的内容全部都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。譬如上传文件。恶意的POST请求会大大消耗服务器的资源。所以Node.js是不会解析请求体，当你需要的时候，需要手动来做。\n例：\n```javascript\nvar http = require('http');\nvar querystring = require('querystring');\nvar util = require('util');\nhttp.createServer(function(req,res){\n    var post = '';\n    //注册data事件监听函数，每当接收请求体的数据\n    req.on('data',function(chunk){\n        post+=chunk;\n    });\n    req.on('end',function(){\n        //将字符串解析为一个JSON对象\n        post = querystring.parse(post);\n        //向前端返回\n        res.end(util.inspect(post));\n    });\n}).listen(3000);\n```\n\n#### 5.http.serverResponse，返回给客户端的信息\n决定了用户最终得到的结果，它是由http.Server的request事件发送的，作为第二个参数传递。一般为response或res。\n主要的三个函数：\n- response.writeHead(statusCode,[headers]);向请求的客户端发送响应头。\n    - statusCode是HTTP状态码，如200位成功，404为未找到等。\n    - headers是一个类似关联数组的对象，表示响应头的每个属性。\n- response.write(data,[encoding])向请求客户端发送相应的内容，data是buffer或字符串，encoding为编码。\n- response.end([data],[encoding])结束响应，告知用户所有发送已经完成，当所有要返回的内容发送完毕，该函数必须被调用一次，如果不调用，客户端永远处于等待状态。","source":"_posts/nodeJsStudy7.md","raw":"title: node.js学习笔记(七)——HTTP服务器\ndate: 2016-01-06 10:17:50\ntags: node.js学习笔记\n---\nnode.js提供了http模块。其中封装了一个高效的HTTP服务器和一个简易的HTTP客户端。\nhttp.server是一个基于事件的HTTP服务器。内部有C++实现。接口由javascript封装。\nhttp.request则是一个HTTP客户端工具。用户向服务器发送请求。\n<!-- more -->\n### 一、HTTP服务器\nhttp.Server实现的，它提供了一套封装级别很低的API，仅仅是流控制和简单的解析，所有的高层功能都要通过它的接口。\n例：\n```javascript\n//引入模块\nvar http = require('http');\n//创建服务\nhttp.createServer(function(req,res){\n    //响应头\n    res.writeHead(200,{'Content-Type':'text/html'});\n    //响应内容\n    res.write(\"<h1>Node.wqewqewqjs</h1>\");\n    //结束响应\n    res.end('<p>PCAT</p>');\n//监听端口\n}).listen('3000');\nconsole.log('HTTP server is listening at port 3000');\n```\n执行后访问结果：\n![](http://i4.tietuku.com/7ef205ca829b96f0.png)\n\n代码分析：\nhttp.creatServer()创建了一个http.Server的实例，将一个函数作为HTTP请求处理函数。这个函数接受两个参数，请求对象req和响应对象res。res显式地写入了响应代码200（表示请求成功），指定响应头，写入响应体，调用end结束并发送。该实例调用listen函数，启动服务器并监听3000端口。\n#### 1.http.server事件\nhttp.server是一个基于事件的HTTP服务器，所有请求都被封装成独立的事件，开发者只要对它的事件编写相应的函数即可实现HTTP服务器的所有功能，它继承于EventEmitter，提供了以下事件：\n**request**：当客户端请求到来时，该事件被触发，提供两个参数req和res，分别是http.ServerRequest和http.ServerResponse的实例，表示请求和响应信息。\n例：\n在上面代码的`http.creatServer()`回调函数中，加入一句`console.log(req.url);`\n当在浏览器中输入路径`http://localhost:3000/user?name=cky`时。\n结果：\n![](http://i4.tietuku.com/3316acda98d8a698.jpg)\n**connection**：当TCP连接建立时，该事件被触发，提供了一个参数socket，为net.Socket的实例（底层协议对象）。\n**close**：当服务器关闭时，该事件被触发。\n最常用和关心的是：request事件，http提供了一个捷径：http.createServer()方法。不需要原生创建。\n原生创建方法：\n```javascript\nvar http = require('http');\nvar server = new http.Server();\nserver.on('request',function(req,res){\n    res.writeHead(200,{'Content-Type':'text/html'});\n    res.write(\"<h1>Node.wqewqewqjs</h1>\");\n    res.end('<p>PCAT</p>');\n});\nserver.listen('3000')\n```\n更多详细内容，见[api文档](http://nodeapi.ucdok.com/#/api/http.html);\n\n#### 2.http.ServerRequest，请求的信息\n此对象是后端开发者最关注的内容，它一般由http.Server的request事件发送，作为第一个参数传递，通常简写成request或req。HTTP请求分为两部分：请求头和请求体。请求内容短的直接在请求头解析完成后立即读取，而请求体可能相对较长，需要一定时间传输，因此提供了三个时间用于控制请求体传输。\n- data:当请求体数据到来时，该事件被触发，该事件有一个参数chunk,表示接收到的数据。\n- end：当请求体数据传输完成时，该事件被触发，伺候将不会再有数据到来，\n- close: 用户当前请求结束时，该事件被触发，不同于end，如果用户强制终止了传输，也会触发close。\n\n__ServerRequest的属性：__\n\n| 属性       | 含义           |\n| ---------|-------------| \n| complete  | 客户端请求是否已经发送完成 | \n| httpVersion | HTTP协议版本，通常是1.0或1.1 |\n| method  | HTTP请求方法，如GET,POST |\n| url | 原始的请求路径 | \n| headers | HTTP请求头 |\n| trailers| HTTP请求尾（不常见） |\n| connection | 当前HTTP连接套接字，为net.Socket的实例 | \n| socket | connection属性的别名 |\n| client| client属性的别名 |\n\n#### 3.获取GET请求内容\n由于GET请求直接被嵌入在路径中，URL完成的请求路径，包括了？后面的部分，因此你可以手动解析。node.js的url模块中的parse函数也提供了这个功能。\n例：\n```javascript\n//引入模块\nvar http = require('http');\nvar urls = require('url');\nvar util = require('util');\n//创建服务\nhttp.createServer(function(req,res){\n    res.writeHead(2000,{'Content-Type':'text/plain'});\n    //解析并打成字符串返回给客户端\n    res.end(util.inspect(urls.parse(req.url,true)));\n}).listen(3000);\n```\n执行结果：\n![](http://i4.tietuku.com/6703100aee0d87f1.jpg)\n\n#### 4.获取POST请求的内容\nPOST请求的内容全部都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。譬如上传文件。恶意的POST请求会大大消耗服务器的资源。所以Node.js是不会解析请求体，当你需要的时候，需要手动来做。\n例：\n```javascript\nvar http = require('http');\nvar querystring = require('querystring');\nvar util = require('util');\nhttp.createServer(function(req,res){\n    var post = '';\n    //注册data事件监听函数，每当接收请求体的数据\n    req.on('data',function(chunk){\n        post+=chunk;\n    });\n    req.on('end',function(){\n        //将字符串解析为一个JSON对象\n        post = querystring.parse(post);\n        //向前端返回\n        res.end(util.inspect(post));\n    });\n}).listen(3000);\n```\n\n#### 5.http.serverResponse，返回给客户端的信息\n决定了用户最终得到的结果，它是由http.Server的request事件发送的，作为第二个参数传递。一般为response或res。\n主要的三个函数：\n- response.writeHead(statusCode,[headers]);向请求的客户端发送响应头。\n    - statusCode是HTTP状态码，如200位成功，404为未找到等。\n    - headers是一个类似关联数组的对象，表示响应头的每个属性。\n- response.write(data,[encoding])向请求客户端发送相应的内容，data是buffer或字符串，encoding为编码。\n- response.end([data],[encoding])结束响应，告知用户所有发送已经完成，当所有要返回的内容发送完毕，该函数必须被调用一次，如果不调用，客户端永远处于等待状态。","slug":"nodeJsStudy7","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489exf000xer2ztvaxk7re","content":"<p>node.js提供了http模块。其中封装了一个高效的HTTP服务器和一个简易的HTTP客户端。<br>http.server是一个基于事件的HTTP服务器。内部有C++实现。接口由javascript封装。<br>http.request则是一个HTTP客户端工具。用户向服务器发送请求。<br><a id=\"more\"></a></p>\n<h3 id=\"一、HTTP服务器\">一、HTTP服务器</h3><p>http.Server实现的，它提供了一套封装级别很低的API，仅仅是流控制和简单的解析，所有的高层功能都要通过它的接口。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//引入模块</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"comment\">//创建服务</span></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//响应头</span></div><div class=\"line\">    res.writeHead(<span class=\"number\">200</span>,&#123;<span class=\"string\">'Content-Type'</span>:<span class=\"string\">'text/html'</span>&#125;);</div><div class=\"line\">    <span class=\"comment\">//响应内容</span></div><div class=\"line\">    res.write(<span class=\"string\">\"&lt;h1&gt;Node.wqewqewqjs&lt;/h1&gt;\"</span>);</div><div class=\"line\">    <span class=\"comment\">//结束响应</span></div><div class=\"line\">    res.end(<span class=\"string\">'&lt;p&gt;PCAT&lt;/p&gt;'</span>);</div><div class=\"line\"><span class=\"comment\">//监听端口</span></div><div class=\"line\">&#125;).listen(<span class=\"string\">'3000'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'HTTP server is listening at port 3000'</span>);</div></pre></td></tr></table></figure></p>\n<p>执行后访问结果：<br><img src=\"http://i4.tietuku.com/7ef205ca829b96f0.png\" alt=\"\"></p>\n<p>代码分析：<br>http.creatServer()创建了一个http.Server的实例，将一个函数作为HTTP请求处理函数。这个函数接受两个参数，请求对象req和响应对象res。res显式地写入了响应代码200（表示请求成功），指定响应头，写入响应体，调用end结束并发送。该实例调用listen函数，启动服务器并监听3000端口。</p>\n<h4 id=\"1-http-server事件\">1.http.server事件</h4><p>http.server是一个基于事件的HTTP服务器，所有请求都被封装成独立的事件，开发者只要对它的事件编写相应的函数即可实现HTTP服务器的所有功能，它继承于EventEmitter，提供了以下事件：<br><strong>request</strong>：当客户端请求到来时，该事件被触发，提供两个参数req和res，分别是http.ServerRequest和http.ServerResponse的实例，表示请求和响应信息。<br>例：<br>在上面代码的<code>http.creatServer()</code>回调函数中，加入一句<code>console.log(req.url);</code><br>当在浏览器中输入路径<code>http://localhost:3000/user?name=cky</code>时。<br>结果：<br><img src=\"http://i4.tietuku.com/3316acda98d8a698.jpg\" alt=\"\"><br><strong>connection</strong>：当TCP连接建立时，该事件被触发，提供了一个参数socket，为net.Socket的实例（底层协议对象）。<br><strong>close</strong>：当服务器关闭时，该事件被触发。<br>最常用和关心的是：request事件，http提供了一个捷径：http.createServer()方法。不需要原生创建。<br>原生创建方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"keyword\">new</span> http.Server();</div><div class=\"line\">server.on(<span class=\"string\">'request'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    res.writeHead(<span class=\"number\">200</span>,&#123;<span class=\"string\">'Content-Type'</span>:<span class=\"string\">'text/html'</span>&#125;);</div><div class=\"line\">    res.write(<span class=\"string\">\"&lt;h1&gt;Node.wqewqewqjs&lt;/h1&gt;\"</span>);</div><div class=\"line\">    res.end(<span class=\"string\">'&lt;p&gt;PCAT&lt;/p&gt;'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\">server.listen(<span class=\"string\">'3000'</span>)</div></pre></td></tr></table></figure></p>\n<p>更多详细内容，见<a href=\"http://nodeapi.ucdok.com/#/api/http.html\" target=\"_blank\" rel=\"external\">api文档</a>;</p>\n<h4 id=\"2-http-ServerRequest，请求的信息\">2.http.ServerRequest，请求的信息</h4><p>此对象是后端开发者最关注的内容，它一般由http.Server的request事件发送，作为第一个参数传递，通常简写成request或req。HTTP请求分为两部分：请求头和请求体。请求内容短的直接在请求头解析完成后立即读取，而请求体可能相对较长，需要一定时间传输，因此提供了三个时间用于控制请求体传输。</p>\n<ul>\n<li>data:当请求体数据到来时，该事件被触发，该事件有一个参数chunk,表示接收到的数据。</li>\n<li>end：当请求体数据传输完成时，该事件被触发，伺候将不会再有数据到来，</li>\n<li>close: 用户当前请求结束时，该事件被触发，不同于end，如果用户强制终止了传输，也会触发close。</li>\n</ul>\n<p><strong>ServerRequest的属性：</strong></p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>complete</td>\n<td>客户端请求是否已经发送完成</td>\n</tr>\n<tr>\n<td>httpVersion</td>\n<td>HTTP协议版本，通常是1.0或1.1</td>\n</tr>\n<tr>\n<td>method</td>\n<td>HTTP请求方法，如GET,POST</td>\n</tr>\n<tr>\n<td>url</td>\n<td>原始的请求路径</td>\n</tr>\n<tr>\n<td>headers</td>\n<td>HTTP请求头</td>\n</tr>\n<tr>\n<td>trailers</td>\n<td>HTTP请求尾（不常见）</td>\n</tr>\n<tr>\n<td>connection</td>\n<td>当前HTTP连接套接字，为net.Socket的实例</td>\n</tr>\n<tr>\n<td>socket</td>\n<td>connection属性的别名</td>\n</tr>\n<tr>\n<td>client</td>\n<td>client属性的别名</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-获取GET请求内容\">3.获取GET请求内容</h4><p>由于GET请求直接被嵌入在路径中，URL完成的请求路径，包括了？后面的部分，因此你可以手动解析。node.js的url模块中的parse函数也提供了这个功能。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//引入模块</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> urls = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\"><span class=\"comment\">//创建服务</span></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    res.writeHead(<span class=\"number\">2000</span>,&#123;<span class=\"string\">'Content-Type'</span>:<span class=\"string\">'text/plain'</span>&#125;);</div><div class=\"line\">    <span class=\"comment\">//解析并打成字符串返回给客户端</span></div><div class=\"line\">    res.end(util.inspect(urls.parse(req.url,<span class=\"literal\">true</span>)));</div><div class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><img src=\"http://i4.tietuku.com/6703100aee0d87f1.jpg\" alt=\"\"></p>\n<h4 id=\"4-获取POST请求的内容\">4.获取POST请求的内容</h4><p>POST请求的内容全部都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。譬如上传文件。恶意的POST请求会大大消耗服务器的资源。所以Node.js是不会解析请求体，当你需要的时候，需要手动来做。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> post = <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"comment\">//注册data事件监听函数，每当接收请求体的数据</span></div><div class=\"line\">    req.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk</span>)</span>&#123;</div><div class=\"line\">        post+=chunk;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    req.on(<span class=\"string\">'end'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"comment\">//将字符串解析为一个JSON对象</span></div><div class=\"line\">        post = querystring.parse(post);</div><div class=\"line\">        <span class=\"comment\">//向前端返回</span></div><div class=\"line\">        res.end(util.inspect(post));</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure></p>\n<h4 id=\"5-http-serverResponse，返回给客户端的信息\">5.http.serverResponse，返回给客户端的信息</h4><p>决定了用户最终得到的结果，它是由http.Server的request事件发送的，作为第二个参数传递。一般为response或res。<br>主要的三个函数：</p>\n<ul>\n<li>response.writeHead(statusCode,[headers]);向请求的客户端发送响应头。<ul>\n<li>statusCode是HTTP状态码，如200位成功，404为未找到等。</li>\n<li>headers是一个类似关联数组的对象，表示响应头的每个属性。</li>\n</ul>\n</li>\n<li>response.write(data,[encoding])向请求客户端发送相应的内容，data是buffer或字符串，encoding为编码。</li>\n<li>response.end([data],[encoding])结束响应，告知用户所有发送已经完成，当所有要返回的内容发送完毕，该函数必须被调用一次，如果不调用，客户端永远处于等待状态。</li>\n</ul>\n","excerpt":"<p>node.js提供了http模块。其中封装了一个高效的HTTP服务器和一个简易的HTTP客户端。<br>http.server是一个基于事件的HTTP服务器。内部有C++实现。接口由javascript封装。<br>http.request则是一个HTTP客户端工具。用户向服务器发送请求。<br>","more":"</p>\n<h3 id=\"一、HTTP服务器\">一、HTTP服务器</h3><p>http.Server实现的，它提供了一套封装级别很低的API，仅仅是流控制和简单的解析，所有的高层功能都要通过它的接口。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//引入模块</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"comment\">//创建服务</span></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//响应头</span></div><div class=\"line\">    res.writeHead(<span class=\"number\">200</span>,&#123;<span class=\"string\">'Content-Type'</span>:<span class=\"string\">'text/html'</span>&#125;);</div><div class=\"line\">    <span class=\"comment\">//响应内容</span></div><div class=\"line\">    res.write(<span class=\"string\">\"&lt;h1&gt;Node.wqewqewqjs&lt;/h1&gt;\"</span>);</div><div class=\"line\">    <span class=\"comment\">//结束响应</span></div><div class=\"line\">    res.end(<span class=\"string\">'&lt;p&gt;PCAT&lt;/p&gt;'</span>);</div><div class=\"line\"><span class=\"comment\">//监听端口</span></div><div class=\"line\">&#125;).listen(<span class=\"string\">'3000'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'HTTP server is listening at port 3000'</span>);</div></pre></td></tr></table></figure></p>\n<p>执行后访问结果：<br><img src=\"http://i4.tietuku.com/7ef205ca829b96f0.png\" alt=\"\"></p>\n<p>代码分析：<br>http.creatServer()创建了一个http.Server的实例，将一个函数作为HTTP请求处理函数。这个函数接受两个参数，请求对象req和响应对象res。res显式地写入了响应代码200（表示请求成功），指定响应头，写入响应体，调用end结束并发送。该实例调用listen函数，启动服务器并监听3000端口。</p>\n<h4 id=\"1-http-server事件\">1.http.server事件</h4><p>http.server是一个基于事件的HTTP服务器，所有请求都被封装成独立的事件，开发者只要对它的事件编写相应的函数即可实现HTTP服务器的所有功能，它继承于EventEmitter，提供了以下事件：<br><strong>request</strong>：当客户端请求到来时，该事件被触发，提供两个参数req和res，分别是http.ServerRequest和http.ServerResponse的实例，表示请求和响应信息。<br>例：<br>在上面代码的<code>http.creatServer()</code>回调函数中，加入一句<code>console.log(req.url);</code><br>当在浏览器中输入路径<code>http://localhost:3000/user?name=cky</code>时。<br>结果：<br><img src=\"http://i4.tietuku.com/3316acda98d8a698.jpg\" alt=\"\"><br><strong>connection</strong>：当TCP连接建立时，该事件被触发，提供了一个参数socket，为net.Socket的实例（底层协议对象）。<br><strong>close</strong>：当服务器关闭时，该事件被触发。<br>最常用和关心的是：request事件，http提供了一个捷径：http.createServer()方法。不需要原生创建。<br>原生创建方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"keyword\">new</span> http.Server();</div><div class=\"line\">server.on(<span class=\"string\">'request'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    res.writeHead(<span class=\"number\">200</span>,&#123;<span class=\"string\">'Content-Type'</span>:<span class=\"string\">'text/html'</span>&#125;);</div><div class=\"line\">    res.write(<span class=\"string\">\"&lt;h1&gt;Node.wqewqewqjs&lt;/h1&gt;\"</span>);</div><div class=\"line\">    res.end(<span class=\"string\">'&lt;p&gt;PCAT&lt;/p&gt;'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\">server.listen(<span class=\"string\">'3000'</span>)</div></pre></td></tr></table></figure></p>\n<p>更多详细内容，见<a href=\"http://nodeapi.ucdok.com/#/api/http.html\">api文档</a>;</p>\n<h4 id=\"2-http-ServerRequest，请求的信息\">2.http.ServerRequest，请求的信息</h4><p>此对象是后端开发者最关注的内容，它一般由http.Server的request事件发送，作为第一个参数传递，通常简写成request或req。HTTP请求分为两部分：请求头和请求体。请求内容短的直接在请求头解析完成后立即读取，而请求体可能相对较长，需要一定时间传输，因此提供了三个时间用于控制请求体传输。</p>\n<ul>\n<li>data:当请求体数据到来时，该事件被触发，该事件有一个参数chunk,表示接收到的数据。</li>\n<li>end：当请求体数据传输完成时，该事件被触发，伺候将不会再有数据到来，</li>\n<li>close: 用户当前请求结束时，该事件被触发，不同于end，如果用户强制终止了传输，也会触发close。</li>\n</ul>\n<p><strong>ServerRequest的属性：</strong></p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>complete</td>\n<td>客户端请求是否已经发送完成</td>\n</tr>\n<tr>\n<td>httpVersion</td>\n<td>HTTP协议版本，通常是1.0或1.1</td>\n</tr>\n<tr>\n<td>method</td>\n<td>HTTP请求方法，如GET,POST</td>\n</tr>\n<tr>\n<td>url</td>\n<td>原始的请求路径</td>\n</tr>\n<tr>\n<td>headers</td>\n<td>HTTP请求头</td>\n</tr>\n<tr>\n<td>trailers</td>\n<td>HTTP请求尾（不常见）</td>\n</tr>\n<tr>\n<td>connection</td>\n<td>当前HTTP连接套接字，为net.Socket的实例</td>\n</tr>\n<tr>\n<td>socket</td>\n<td>connection属性的别名</td>\n</tr>\n<tr>\n<td>client</td>\n<td>client属性的别名</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-获取GET请求内容\">3.获取GET请求内容</h4><p>由于GET请求直接被嵌入在路径中，URL完成的请求路径，包括了？后面的部分，因此你可以手动解析。node.js的url模块中的parse函数也提供了这个功能。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//引入模块</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> urls = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\"><span class=\"comment\">//创建服务</span></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    res.writeHead(<span class=\"number\">2000</span>,&#123;<span class=\"string\">'Content-Type'</span>:<span class=\"string\">'text/plain'</span>&#125;);</div><div class=\"line\">    <span class=\"comment\">//解析并打成字符串返回给客户端</span></div><div class=\"line\">    res.end(util.inspect(urls.parse(req.url,<span class=\"literal\">true</span>)));</div><div class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><img src=\"http://i4.tietuku.com/6703100aee0d87f1.jpg\" alt=\"\"></p>\n<h4 id=\"4-获取POST请求的内容\">4.获取POST请求的内容</h4><p>POST请求的内容全部都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。譬如上传文件。恶意的POST请求会大大消耗服务器的资源。所以Node.js是不会解析请求体，当你需要的时候，需要手动来做。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> post = <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"comment\">//注册data事件监听函数，每当接收请求体的数据</span></div><div class=\"line\">    req.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk</span>)</span>&#123;</div><div class=\"line\">        post+=chunk;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    req.on(<span class=\"string\">'end'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"comment\">//将字符串解析为一个JSON对象</span></div><div class=\"line\">        post = querystring.parse(post);</div><div class=\"line\">        <span class=\"comment\">//向前端返回</span></div><div class=\"line\">        res.end(util.inspect(post));</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;).listen(<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure></p>\n<h4 id=\"5-http-serverResponse，返回给客户端的信息\">5.http.serverResponse，返回给客户端的信息</h4><p>决定了用户最终得到的结果，它是由http.Server的request事件发送的，作为第二个参数传递。一般为response或res。<br>主要的三个函数：</p>\n<ul>\n<li>response.writeHead(statusCode,[headers]);向请求的客户端发送响应头。<ul>\n<li>statusCode是HTTP状态码，如200位成功，404为未找到等。</li>\n<li>headers是一个类似关联数组的对象，表示响应头的每个属性。</li>\n</ul>\n</li>\n<li>response.write(data,[encoding])向请求客户端发送相应的内容，data是buffer或字符串，encoding为编码。</li>\n<li>response.end([data],[encoding])结束响应，告知用户所有发送已经完成，当所有要返回的内容发送完毕，该函数必须被调用一次，如果不调用，客户端永远处于等待状态。</li>\n</ul>"},{"title":"node.js学习笔记(九)——Express框架入门介绍","date":"2016-01-06T13:56:50.000Z","_content":"### 一、为什么要用Express框架？\nNode.js由于不需要另外的HTTP服务器，因此减少了一层抽象，给性能带来不少的提升，同时也因此提高了开发难度，实现一个POST数据的表单。例如：\n```html\n<form>\n\t<input type=\"text\" name=\"title\"/>\n\t<input type=\"submit\"/>\n</form>\n```\nPHP中获取POST请求参数可以直接用 `$_POST('title');`\nJAVA语言也可以用`request.getParameter('title')`；\n而Node中获取就比较麻烦了，前几篇文章的例子中可以看到。\nnode.js虽然提供了HTTP模块，却不是让你直接用这个模块进行web开发的。http模块仅仅是一个HTTP服务器内核的封装。\n使用express实现上述案例：\n```javascript\nvar express = require('express');\nvar app = express.createServer();\napp.use(express.bodyParser());\napp.all('/',function(req,res){\n\tres.send(req.body.title);\n});\napp.listen(3000);\n```\n### 二、Express框架\nnpm提供了大量的第三方模块，其中不乏许多Web框架，我们没有必要重复造轮子，因此我们选择Express作为开发框架。\n其提供了更高层的接口外，还实现了许多功能，如：\n路由控制、模板解析支持、动态视图、用户会话、CSRF保护、静态文件服务、错误控制器、访问日志、缓存、插件支持等。\n\n### 三、安装Express\n`npm install -g express`\n安装完成之后使用`express -help` 检测是否安装成功\n如果报错express不是一个命令， 则执行`npm install -g express-generator`即可\nExpress在初始化一个项目的时候需要指定模板引擎，模式支持jade和ejs，为了降低学习难度，建议使用ejs。\n\n### 四、建立工程\nexpress -e pcat\n当前目录出现了子目录pcat并产生了一些文件：\n![](http://i4.tietuku.com/724f4057ebf5adfc.png)\n提示我们进入pcat目录执行npm install命令\n无参数的npm install命令会检查当前目录下的package.json并自动安装所有指定的依赖。\n\n### 五、启动服务器\nwindow环境下：\n执行`set DEBUG=pcat`\n再执行`npm start`\n访问localhost:3000即可访问。\n\n更多介绍见[express官网](http://www.expressjs.com.cn/)","source":"_posts/nodeJsStudy9.md","raw":"title: node.js学习笔记(九)——Express框架入门介绍\ndate: 2016-01-06 21:56:50\ntags: node.js学习笔记\n---\n### 一、为什么要用Express框架？\nNode.js由于不需要另外的HTTP服务器，因此减少了一层抽象，给性能带来不少的提升，同时也因此提高了开发难度，实现一个POST数据的表单。例如：\n```html\n<form>\n\t<input type=\"text\" name=\"title\"/>\n\t<input type=\"submit\"/>\n</form>\n```\nPHP中获取POST请求参数可以直接用 `$_POST('title');`\nJAVA语言也可以用`request.getParameter('title')`；\n而Node中获取就比较麻烦了，前几篇文章的例子中可以看到。\nnode.js虽然提供了HTTP模块，却不是让你直接用这个模块进行web开发的。http模块仅仅是一个HTTP服务器内核的封装。\n使用express实现上述案例：\n```javascript\nvar express = require('express');\nvar app = express.createServer();\napp.use(express.bodyParser());\napp.all('/',function(req,res){\n\tres.send(req.body.title);\n});\napp.listen(3000);\n```\n### 二、Express框架\nnpm提供了大量的第三方模块，其中不乏许多Web框架，我们没有必要重复造轮子，因此我们选择Express作为开发框架。\n其提供了更高层的接口外，还实现了许多功能，如：\n路由控制、模板解析支持、动态视图、用户会话、CSRF保护、静态文件服务、错误控制器、访问日志、缓存、插件支持等。\n\n### 三、安装Express\n`npm install -g express`\n安装完成之后使用`express -help` 检测是否安装成功\n如果报错express不是一个命令， 则执行`npm install -g express-generator`即可\nExpress在初始化一个项目的时候需要指定模板引擎，模式支持jade和ejs，为了降低学习难度，建议使用ejs。\n\n### 四、建立工程\nexpress -e pcat\n当前目录出现了子目录pcat并产生了一些文件：\n![](http://i4.tietuku.com/724f4057ebf5adfc.png)\n提示我们进入pcat目录执行npm install命令\n无参数的npm install命令会检查当前目录下的package.json并自动安装所有指定的依赖。\n\n### 五、启动服务器\nwindow环境下：\n执行`set DEBUG=pcat`\n再执行`npm start`\n访问localhost:3000即可访问。\n\n更多介绍见[express官网](http://www.expressjs.com.cn/)","slug":"nodeJsStudy9","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489exj0010er2zw0o81464","content":"<h3 id=\"一、为什么要用Express框架？\">一、为什么要用Express框架？</h3><p>Node.js由于不需要另外的HTTP服务器，因此减少了一层抽象，给性能带来不少的提升，同时也因此提高了开发难度，实现一个POST数据的表单。例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"title\"</span>/&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>PHP中获取POST请求参数可以直接用 <code>$_POST(&#39;title&#39;);</code><br>JAVA语言也可以用<code>request.getParameter(&#39;title&#39;)</code>；<br>而Node中获取就比较麻烦了，前几篇文章的例子中可以看到。<br>node.js虽然提供了HTTP模块，却不是让你直接用这个模块进行web开发的。http模块仅仅是一个HTTP服务器内核的封装。<br>使用express实现上述案例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> app = express.createServer();</div><div class=\"line\">app.use(express.bodyParser());</div><div class=\"line\">app.all(<span class=\"string\">'/'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">\tres.send(req.body.title);</div><div class=\"line\">&#125;);</div><div class=\"line\">app.listen(<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure></p>\n<h3 id=\"二、Express框架\">二、Express框架</h3><p>npm提供了大量的第三方模块，其中不乏许多Web框架，我们没有必要重复造轮子，因此我们选择Express作为开发框架。<br>其提供了更高层的接口外，还实现了许多功能，如：<br>路由控制、模板解析支持、动态视图、用户会话、CSRF保护、静态文件服务、错误控制器、访问日志、缓存、插件支持等。</p>\n<h3 id=\"三、安装Express\">三、安装Express</h3><p><code>npm install -g express</code><br>安装完成之后使用<code>express -help</code> 检测是否安装成功<br>如果报错express不是一个命令， 则执行<code>npm install -g express-generator</code>即可<br>Express在初始化一个项目的时候需要指定模板引擎，模式支持jade和ejs，为了降低学习难度，建议使用ejs。</p>\n<h3 id=\"四、建立工程\">四、建立工程</h3><p>express -e pcat<br>当前目录出现了子目录pcat并产生了一些文件：<br><img src=\"http://i4.tietuku.com/724f4057ebf5adfc.png\" alt=\"\"><br>提示我们进入pcat目录执行npm install命令<br>无参数的npm install命令会检查当前目录下的package.json并自动安装所有指定的依赖。</p>\n<h3 id=\"五、启动服务器\">五、启动服务器</h3><p>window环境下：<br>执行<code>set DEBUG=pcat</code><br>再执行<code>npm start</code><br>访问localhost:3000即可访问。</p>\n<p>更多介绍见<a href=\"http://www.expressjs.com.cn/\" target=\"_blank\" rel=\"external\">express官网</a></p>\n","excerpt":"","more":"<h3 id=\"一、为什么要用Express框架？\">一、为什么要用Express框架？</h3><p>Node.js由于不需要另外的HTTP服务器，因此减少了一层抽象，给性能带来不少的提升，同时也因此提高了开发难度，实现一个POST数据的表单。例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"title\"</span>/&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>PHP中获取POST请求参数可以直接用 <code>$_POST(&#39;title&#39;);</code><br>JAVA语言也可以用<code>request.getParameter(&#39;title&#39;)</code>；<br>而Node中获取就比较麻烦了，前几篇文章的例子中可以看到。<br>node.js虽然提供了HTTP模块，却不是让你直接用这个模块进行web开发的。http模块仅仅是一个HTTP服务器内核的封装。<br>使用express实现上述案例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> app = express.createServer();</div><div class=\"line\">app.use(express.bodyParser());</div><div class=\"line\">app.all(<span class=\"string\">'/'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>)</span>&#123;</div><div class=\"line\">\tres.send(req.body.title);</div><div class=\"line\">&#125;);</div><div class=\"line\">app.listen(<span class=\"number\">3000</span>);</div></pre></td></tr></table></figure></p>\n<h3 id=\"二、Express框架\">二、Express框架</h3><p>npm提供了大量的第三方模块，其中不乏许多Web框架，我们没有必要重复造轮子，因此我们选择Express作为开发框架。<br>其提供了更高层的接口外，还实现了许多功能，如：<br>路由控制、模板解析支持、动态视图、用户会话、CSRF保护、静态文件服务、错误控制器、访问日志、缓存、插件支持等。</p>\n<h3 id=\"三、安装Express\">三、安装Express</h3><p><code>npm install -g express</code><br>安装完成之后使用<code>express -help</code> 检测是否安装成功<br>如果报错express不是一个命令， 则执行<code>npm install -g express-generator</code>即可<br>Express在初始化一个项目的时候需要指定模板引擎，模式支持jade和ejs，为了降低学习难度，建议使用ejs。</p>\n<h3 id=\"四、建立工程\">四、建立工程</h3><p>express -e pcat<br>当前目录出现了子目录pcat并产生了一些文件：<br><img src=\"http://i4.tietuku.com/724f4057ebf5adfc.png\" alt=\"\"><br>提示我们进入pcat目录执行npm install命令<br>无参数的npm install命令会检查当前目录下的package.json并自动安装所有指定的依赖。</p>\n<h3 id=\"五、启动服务器\">五、启动服务器</h3><p>window环境下：<br>执行<code>set DEBUG=pcat</code><br>再执行<code>npm start</code><br>访问localhost:3000即可访问。</p>\n<p>更多介绍见<a href=\"http://www.expressjs.com.cn/\">express官网</a></p>\n"},{"title":"node.js学习笔记(五)——常用工具util和事件EventEmitter","date":"2016-01-04T02:17:50.000Z","_content":"### 一、util全局变量\n#### 1. `util.inherits(constructor,superConstructor)`\n此方法是一个实现对象间原型继承的函数。javaScript通过原型赋值来实现继承。\n<!-- more -->\n例：\n```javascript\n//inherits.js\nvar util = require('util');\nfunction Base(){\n    this.name = 'base';\n    this.base = 2012;\n    this.sayHello = function(){\n        console.log('hello ' + this.name + ' this year is ' + this.base);\n    };\n}\nBase.prototype.showName = function(){\n    console.log(this.name);\n};\nfunction Sub(){\n    this.name = 'sub';\n}\nutil.inherits(Sub, Base);\n//原有输出\nvar objBase = new Base();\nobjBase.showName();\nobjBase.sayHello();\n\nconsole.log(objBase);\n//继承后的子类输出\nvar objSub = new Sub();\nobjSub.showName();\n//objSub.sayHello(); 报错\nconsole.log(objSub);\n```\n    执行结果：\n    ```javascript\n    base\n    hello base this year is 2012\n    Base { name: 'base', base: 2012, sayHello: [Function] }\n    sub\n    Sub { name: 'sub' }\n    ```\n注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。\n#### 2. `util.inspect(object,[showHidden],[depth],[colors])`\n此方法是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。\nshowHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。\ndepth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。\n特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。\n\n#### 3.`util.isArray(object)`\n如果给定的参数 \"object\" 是一个数组返回true，否则返回false。\n```javascript\nvar util = require('util');\n\nutil.isArray([])\n  // true\nutil.isArray(new Array)\n  // true\nutil.isArray({})\n  // false\n```\n类似的还有`util.isRegExp(object)`、`util.isDate(object)`、`util.isError(object)`\n\n更多api点击[参考链接](http://nodeapi.ucdok.com/#/api/util.html)\n\n### 二、事件驱动\nevents是Node.js最重要的模板，原因是Node.js本身架构就是事件式的，而它提供了唯一的接口。events模块不仅用于用户代码与NOde.js下层事件循环的交互。还几乎被所有的模块依赖。\n#### 1.事件发射器\nevents模块只提供了一个对象——events.EventEmitter。EventEmitter的核心就是事件发射与时间监听器功能的封装。EventEmitter的每个事件由一个事件或若干个参数组成，事件名是一个字符串，通常表达一定的语义，对于每个事件，EventEmitter支持若干个事件监听器。当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。\n例子：\n```javascript\nvar events = require('events');\n//实例化事件对象\nvar emitter = new events.EventEmitter();\n//注册事件监听1\nemitter.on('someEvent',function(arg1,arg2){\n    console.log('Listener1',arg1,arg2);\n});\n//注册事件监听2\nemitter.on('someEvent', function(arg1,arg2){\n    console.log('Listener2',arg1,arg2);\n});\n//触发事件\nemitter.emit('someEvent','cky',1991);\n```\n执行结果：\n```javascript\nListener1 cky 1991\nListener2 cky 1991\n```\n\n更多请参考[api文档](http://nodeapi.ucdok.com/#/api/events.html)\n\n#### 2.error事件\nEventEmitter定义了一个特殊的事件error，它包含错误的定义，我们在遇到异常的时候通常会发射error事件，当error事件被发射时，EventEmitter规定如果没有相应的监听器，Node.js会把它当作异常，退出程序打印调用栈，我们一般要为发射error的事件对象设置监听器，避免遇到错误后整个程序崩溃。\n#### 3.继承Event\n大多数时候我们不会直接使用EventEmitter，而是在对象中继承它，包括fs，net，http在内的。只要是支持事件相应的核心模块都是EventEmiiter的子类。\n为什么这样做呢？\n1. 具有某个实体功能的对象实现事件的符合语义，事件的监听和发射应该是一个对象的方法。\n2. javascript的对象机制是基于原型的，支持部分多重继承，继承EventEmitter不会打乱对象原有的继承关系。","source":"_posts/nodeJsStudy5.md","raw":"title: node.js学习笔记(五)——常用工具util和事件EventEmitter\ndate: 2016-01-04 10:17:50\ntags: node.js学习笔记\n---\n### 一、util全局变量\n#### 1. `util.inherits(constructor,superConstructor)`\n此方法是一个实现对象间原型继承的函数。javaScript通过原型赋值来实现继承。\n<!-- more -->\n例：\n```javascript\n//inherits.js\nvar util = require('util');\nfunction Base(){\n    this.name = 'base';\n    this.base = 2012;\n    this.sayHello = function(){\n        console.log('hello ' + this.name + ' this year is ' + this.base);\n    };\n}\nBase.prototype.showName = function(){\n    console.log(this.name);\n};\nfunction Sub(){\n    this.name = 'sub';\n}\nutil.inherits(Sub, Base);\n//原有输出\nvar objBase = new Base();\nobjBase.showName();\nobjBase.sayHello();\n\nconsole.log(objBase);\n//继承后的子类输出\nvar objSub = new Sub();\nobjSub.showName();\n//objSub.sayHello(); 报错\nconsole.log(objSub);\n```\n    执行结果：\n    ```javascript\n    base\n    hello base this year is 2012\n    Base { name: 'base', base: 2012, sayHello: [Function] }\n    sub\n    Sub { name: 'sub' }\n    ```\n注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。\n#### 2. `util.inspect(object,[showHidden],[depth],[colors])`\n此方法是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。\nshowHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。\ndepth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。\n特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。\n\n#### 3.`util.isArray(object)`\n如果给定的参数 \"object\" 是一个数组返回true，否则返回false。\n```javascript\nvar util = require('util');\n\nutil.isArray([])\n  // true\nutil.isArray(new Array)\n  // true\nutil.isArray({})\n  // false\n```\n类似的还有`util.isRegExp(object)`、`util.isDate(object)`、`util.isError(object)`\n\n更多api点击[参考链接](http://nodeapi.ucdok.com/#/api/util.html)\n\n### 二、事件驱动\nevents是Node.js最重要的模板，原因是Node.js本身架构就是事件式的，而它提供了唯一的接口。events模块不仅用于用户代码与NOde.js下层事件循环的交互。还几乎被所有的模块依赖。\n#### 1.事件发射器\nevents模块只提供了一个对象——events.EventEmitter。EventEmitter的核心就是事件发射与时间监听器功能的封装。EventEmitter的每个事件由一个事件或若干个参数组成，事件名是一个字符串，通常表达一定的语义，对于每个事件，EventEmitter支持若干个事件监听器。当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。\n例子：\n```javascript\nvar events = require('events');\n//实例化事件对象\nvar emitter = new events.EventEmitter();\n//注册事件监听1\nemitter.on('someEvent',function(arg1,arg2){\n    console.log('Listener1',arg1,arg2);\n});\n//注册事件监听2\nemitter.on('someEvent', function(arg1,arg2){\n    console.log('Listener2',arg1,arg2);\n});\n//触发事件\nemitter.emit('someEvent','cky',1991);\n```\n执行结果：\n```javascript\nListener1 cky 1991\nListener2 cky 1991\n```\n\n更多请参考[api文档](http://nodeapi.ucdok.com/#/api/events.html)\n\n#### 2.error事件\nEventEmitter定义了一个特殊的事件error，它包含错误的定义，我们在遇到异常的时候通常会发射error事件，当error事件被发射时，EventEmitter规定如果没有相应的监听器，Node.js会把它当作异常，退出程序打印调用栈，我们一般要为发射error的事件对象设置监听器，避免遇到错误后整个程序崩溃。\n#### 3.继承Event\n大多数时候我们不会直接使用EventEmitter，而是在对象中继承它，包括fs，net，http在内的。只要是支持事件相应的核心模块都是EventEmiiter的子类。\n为什么这样做呢？\n1. 具有某个实体功能的对象实现事件的符合语义，事件的监听和发射应该是一个对象的方法。\n2. javascript的对象机制是基于原型的，支持部分多重继承，继承EventEmitter不会打乱对象原有的继承关系。","slug":"nodeJsStudy5","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489exl0012er2zmkscepoz","content":"<h3 id=\"一、util全局变量\">一、util全局变量</h3><h4 id=\"1-_util-inherits(constructor,superConstructor)\">1. <code>util.inherits(constructor,superConstructor)</code></h4><p>此方法是一个实现对象间原型继承的函数。javaScript通过原型赋值来实现继承。<br><a id=\"more\"></a><br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//inherits.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Base</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'base'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.base = <span class=\"number\">2012</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">' this year is '</span> + <span class=\"keyword\">this</span>.base);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">Base.prototype.showName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'sub'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">util.inherits(Sub, Base);</div><div class=\"line\"><span class=\"comment\">//原有输出</span></div><div class=\"line\"><span class=\"keyword\">var</span> objBase = <span class=\"keyword\">new</span> Base();</div><div class=\"line\">objBase.showName();</div><div class=\"line\">objBase.sayHello();</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(objBase);</div><div class=\"line\"><span class=\"comment\">//继承后的子类输出</span></div><div class=\"line\"><span class=\"keyword\">var</span> objSub = <span class=\"keyword\">new</span> Sub();</div><div class=\"line\">objSub.showName();</div><div class=\"line\"><span class=\"comment\">//objSub.sayHello(); 报错</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(objSub);</div></pre></td></tr></table></figure></p>\n<pre><code>执行结果：\n<span class=\"comment\"><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">base</div><div class=\"line\">hello base <span class=\"keyword\">this</span> year is <span class=\"number\">2012</span></div><div class=\"line\">Base &#123; <span class=\"attr\">name</span>: <span class=\"string\">'base'</span>, <span class=\"attr\">base</span>: <span class=\"number\">2012</span>, <span class=\"attr\">sayHello</span>: [<span class=\"built_in\">Function</span>] &#125;</div><div class=\"line\">sub</div><div class=\"line\">Sub &#123; <span class=\"attr\">name</span>: <span class=\"string\">'sub'</span> &#125;</div></pre></td></tr></table></figure></span>\n</code></pre><p>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。</p>\n<h4 id=\"2-_util-inspect(object,[showHidden],[depth],[colors])\">2. <code>util.inspect(object,[showHidden],[depth],[colors])</code></h4><p>此方法是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。<br>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。<br>depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。<br>特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。</p>\n<h4 id=\"3-util-isArray(object)\">3.<code>util.isArray(object)</code></h4><p>如果给定的参数 “object” 是一个数组返回true，否则返回false。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\"></div><div class=\"line\">util.isArray([])</div><div class=\"line\">  <span class=\"comment\">// true</span></div><div class=\"line\">util.isArray(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>)</div><div class=\"line\">  <span class=\"comment\">// true</span></div><div class=\"line\">util.isArray(&#123;&#125;)</div><div class=\"line\">  <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>类似的还有<code>util.isRegExp(object)</code>、<code>util.isDate(object)</code>、<code>util.isError(object)</code></p>\n<p>更多api点击<a href=\"http://nodeapi.ucdok.com/#/api/util.html\" target=\"_blank\" rel=\"external\">参考链接</a></p>\n<h3 id=\"二、事件驱动\">二、事件驱动</h3><p>events是Node.js最重要的模板，原因是Node.js本身架构就是事件式的，而它提供了唯一的接口。events模块不仅用于用户代码与NOde.js下层事件循环的交互。还几乎被所有的模块依赖。</p>\n<h4 id=\"1-事件发射器\">1.事件发射器</h4><p>events模块只提供了一个对象——events.EventEmitter。EventEmitter的核心就是事件发射与时间监听器功能的封装。EventEmitter的每个事件由一个事件或若干个参数组成，事件名是一个字符串，通常表达一定的语义，对于每个事件，EventEmitter支持若干个事件监听器。当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。<br>例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> events = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>);</div><div class=\"line\"><span class=\"comment\">//实例化事件对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> emitter = <span class=\"keyword\">new</span> events.EventEmitter();</div><div class=\"line\"><span class=\"comment\">//注册事件监听1</span></div><div class=\"line\">emitter.on(<span class=\"string\">'someEvent'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg1,arg2</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listener1'</span>,arg1,arg2);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//注册事件监听2</span></div><div class=\"line\">emitter.on(<span class=\"string\">'someEvent'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg1,arg2</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listener2'</span>,arg1,arg2);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//触发事件</span></div><div class=\"line\">emitter.emit(<span class=\"string\">'someEvent'</span>,<span class=\"string\">'cky'</span>,<span class=\"number\">1991</span>);</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Listener1 cky <span class=\"number\">1991</span></div><div class=\"line\">Listener2 cky <span class=\"number\">1991</span></div></pre></td></tr></table></figure></p>\n<p>更多请参考<a href=\"http://nodeapi.ucdok.com/#/api/events.html\" target=\"_blank\" rel=\"external\">api文档</a></p>\n<h4 id=\"2-error事件\">2.error事件</h4><p>EventEmitter定义了一个特殊的事件error，它包含错误的定义，我们在遇到异常的时候通常会发射error事件，当error事件被发射时，EventEmitter规定如果没有相应的监听器，Node.js会把它当作异常，退出程序打印调用栈，我们一般要为发射error的事件对象设置监听器，避免遇到错误后整个程序崩溃。</p>\n<h4 id=\"3-继承Event\">3.继承Event</h4><p>大多数时候我们不会直接使用EventEmitter，而是在对象中继承它，包括fs，net，http在内的。只要是支持事件相应的核心模块都是EventEmiiter的子类。<br>为什么这样做呢？</p>\n<ol>\n<li>具有某个实体功能的对象实现事件的符合语义，事件的监听和发射应该是一个对象的方法。</li>\n<li>javascript的对象机制是基于原型的，支持部分多重继承，继承EventEmitter不会打乱对象原有的继承关系。</li>\n</ol>\n","excerpt":"<h3 id=\"一、util全局变量\">一、util全局变量</h3><h4 id=\"1-_util-inherits(constructor,superConstructor)\">1. <code>util.inherits(constructor,superConstructor)</code></h4><p>此方法是一个实现对象间原型继承的函数。javaScript通过原型赋值来实现继承。<br>","more":"<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//inherits.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Base</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'base'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.base = <span class=\"number\">2012</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">' this year is '</span> + <span class=\"keyword\">this</span>.base);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">Base.prototype.showName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'sub'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">util.inherits(Sub, Base);</div><div class=\"line\"><span class=\"comment\">//原有输出</span></div><div class=\"line\"><span class=\"keyword\">var</span> objBase = <span class=\"keyword\">new</span> Base();</div><div class=\"line\">objBase.showName();</div><div class=\"line\">objBase.sayHello();</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(objBase);</div><div class=\"line\"><span class=\"comment\">//继承后的子类输出</span></div><div class=\"line\"><span class=\"keyword\">var</span> objSub = <span class=\"keyword\">new</span> Sub();</div><div class=\"line\">objSub.showName();</div><div class=\"line\"><span class=\"comment\">//objSub.sayHello(); 报错</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(objSub);</div></pre></td></tr></table></figure></p>\n<pre><code>执行结果：\n<span class=\"comment\"><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">base</div><div class=\"line\">hello base <span class=\"keyword\">this</span> year is <span class=\"number\">2012</span></div><div class=\"line\">Base &#123; <span class=\"attr\">name</span>: <span class=\"string\">'base'</span>, <span class=\"attr\">base</span>: <span class=\"number\">2012</span>, <span class=\"attr\">sayHello</span>: [<span class=\"built_in\">Function</span>] &#125;</div><div class=\"line\">sub</div><div class=\"line\">Sub &#123; <span class=\"attr\">name</span>: <span class=\"string\">'sub'</span> &#125;</div></pre></td></tr></table></figure></span>\n</code></pre><p>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。</p>\n<h4 id=\"2-_util-inspect(object,[showHidden],[depth],[colors])\">2. <code>util.inspect(object,[showHidden],[depth],[colors])</code></h4><p>此方法是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。<br>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。<br>depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。<br>特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。</p>\n<h4 id=\"3-util-isArray(object)\">3.<code>util.isArray(object)</code></h4><p>如果给定的参数 “object” 是一个数组返回true，否则返回false。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</div><div class=\"line\"></div><div class=\"line\">util.isArray([])</div><div class=\"line\">  <span class=\"comment\">// true</span></div><div class=\"line\">util.isArray(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>)</div><div class=\"line\">  <span class=\"comment\">// true</span></div><div class=\"line\">util.isArray(&#123;&#125;)</div><div class=\"line\">  <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>类似的还有<code>util.isRegExp(object)</code>、<code>util.isDate(object)</code>、<code>util.isError(object)</code></p>\n<p>更多api点击<a href=\"http://nodeapi.ucdok.com/#/api/util.html\">参考链接</a></p>\n<h3 id=\"二、事件驱动\">二、事件驱动</h3><p>events是Node.js最重要的模板，原因是Node.js本身架构就是事件式的，而它提供了唯一的接口。events模块不仅用于用户代码与NOde.js下层事件循环的交互。还几乎被所有的模块依赖。</p>\n<h4 id=\"1-事件发射器\">1.事件发射器</h4><p>events模块只提供了一个对象——events.EventEmitter。EventEmitter的核心就是事件发射与时间监听器功能的封装。EventEmitter的每个事件由一个事件或若干个参数组成，事件名是一个字符串，通常表达一定的语义，对于每个事件，EventEmitter支持若干个事件监听器。当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。<br>例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> events = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>);</div><div class=\"line\"><span class=\"comment\">//实例化事件对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> emitter = <span class=\"keyword\">new</span> events.EventEmitter();</div><div class=\"line\"><span class=\"comment\">//注册事件监听1</span></div><div class=\"line\">emitter.on(<span class=\"string\">'someEvent'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg1,arg2</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listener1'</span>,arg1,arg2);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//注册事件监听2</span></div><div class=\"line\">emitter.on(<span class=\"string\">'someEvent'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg1,arg2</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listener2'</span>,arg1,arg2);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//触发事件</span></div><div class=\"line\">emitter.emit(<span class=\"string\">'someEvent'</span>,<span class=\"string\">'cky'</span>,<span class=\"number\">1991</span>);</div></pre></td></tr></table></figure></p>\n<p>执行结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Listener1 cky <span class=\"number\">1991</span></div><div class=\"line\">Listener2 cky <span class=\"number\">1991</span></div></pre></td></tr></table></figure></p>\n<p>更多请参考<a href=\"http://nodeapi.ucdok.com/#/api/events.html\">api文档</a></p>\n<h4 id=\"2-error事件\">2.error事件</h4><p>EventEmitter定义了一个特殊的事件error，它包含错误的定义，我们在遇到异常的时候通常会发射error事件，当error事件被发射时，EventEmitter规定如果没有相应的监听器，Node.js会把它当作异常，退出程序打印调用栈，我们一般要为发射error的事件对象设置监听器，避免遇到错误后整个程序崩溃。</p>\n<h4 id=\"3-继承Event\">3.继承Event</h4><p>大多数时候我们不会直接使用EventEmitter，而是在对象中继承它，包括fs，net，http在内的。只要是支持事件相应的核心模块都是EventEmiiter的子类。<br>为什么这样做呢？</p>\n<ol>\n<li>具有某个实体功能的对象实现事件的符合语义，事件的监听和发射应该是一个对象的方法。</li>\n<li>javascript的对象机制是基于原型的，支持部分多重继承，继承EventEmitter不会打乱对象原有的继承关系。</li>\n</ol>"},{"title":"postMessage解决跨域、跨窗口消息传递","_content":"最近遇到一个需求，页面嵌入了iframe框，iframe框里是一个Im在线聊天对话框。在用户切换聊天对象时，外层页面也需要获取当前用户正在聊天的对方的userid。但是由于im页面是嵌入的iframe，外层父页面既无法监听切换聊天对象的事件，也无法获取里面的dom元素，会报跨域的错误。为了解决这一问题，可以使用html5的API`postMessage`.\n\n<!-- MORE -->\n\n## postMessage简单介绍\n`postMessage()`方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。\n\n`postMessage(data,origin)`方法接受两个参数\n\n 1.data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。\n\n2.origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为\"*\"，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。\n\n## 子页面和父页面互相发送消息\n为了兼容IE和非IE的事件绑定，下面的例子直接用了jQuery监听事件，如果用原生js，注意`function(e)`中的`e`没有包装在`e.originalEvent`，需要根据实际情况获取。\n\n```\n//在im页面，监听切换用户事件，然后给别人发送对方的用户id。\n$('#im').on('click','.person-item',function(){\n    var data = {key:'getUserId',val:'18'};\n    window.parent.postMessage(JSON.stringify(data),'https://coolmogu.com');\n})\n//监听来自父页面的回执\n$(window).on('message',function(e){\n    var original = e.originalEvent;\n    if(original.source != window.parent) return;\n    console.log('父窗口说他收到了');\n});\n```\n```\n//在父页面，监听事件，\n$(window).on('message',function(e){\n    var original = e.originalEvent;\n    var data = JSON.parse(original.data);\n    if(original.origin != 'https://im.com' ||  data.key != 'getUserId'){\n        return false;\n    }\n    console.log('当前im对话的对象是' + data.val);\n    //父页面给iframe页面发送消息\n    window.frames[0].postMessage('我收到了','http://im.com');\n});\n```\n","source":"_posts/postMessage-api.md","raw":"title: postMessage解决跨域、跨窗口消息传递\ntags: Javascript学习笔记\n---\n最近遇到一个需求，页面嵌入了iframe框，iframe框里是一个Im在线聊天对话框。在用户切换聊天对象时，外层页面也需要获取当前用户正在聊天的对方的userid。但是由于im页面是嵌入的iframe，外层父页面既无法监听切换聊天对象的事件，也无法获取里面的dom元素，会报跨域的错误。为了解决这一问题，可以使用html5的API`postMessage`.\n\n<!-- MORE -->\n\n## postMessage简单介绍\n`postMessage()`方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。\n\n`postMessage(data,origin)`方法接受两个参数\n\n 1.data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。\n\n2.origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为\"*\"，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。\n\n## 子页面和父页面互相发送消息\n为了兼容IE和非IE的事件绑定，下面的例子直接用了jQuery监听事件，如果用原生js，注意`function(e)`中的`e`没有包装在`e.originalEvent`，需要根据实际情况获取。\n\n```\n//在im页面，监听切换用户事件，然后给别人发送对方的用户id。\n$('#im').on('click','.person-item',function(){\n    var data = {key:'getUserId',val:'18'};\n    window.parent.postMessage(JSON.stringify(data),'https://coolmogu.com');\n})\n//监听来自父页面的回执\n$(window).on('message',function(e){\n    var original = e.originalEvent;\n    if(original.source != window.parent) return;\n    console.log('父窗口说他收到了');\n});\n```\n```\n//在父页面，监听事件，\n$(window).on('message',function(e){\n    var original = e.originalEvent;\n    var data = JSON.parse(original.data);\n    if(original.origin != 'https://im.com' ||  data.key != 'getUserId'){\n        return false;\n    }\n    console.log('当前im对话的对象是' + data.val);\n    //父页面给iframe页面发送消息\n    window.frames[0].postMessage('我收到了','http://im.com');\n});\n```\n","slug":"postMessage-api","published":1,"date":"2017-08-14T07:34:12.000Z","updated":"2017-08-16T10:39:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489exs0015er2zd4ftqrq3","content":"<p>最近遇到一个需求，页面嵌入了iframe框，iframe框里是一个Im在线聊天对话框。在用户切换聊天对象时，外层页面也需要获取当前用户正在聊天的对方的userid。但是由于im页面是嵌入的iframe，外层父页面既无法监听切换聊天对象的事件，也无法获取里面的dom元素，会报跨域的错误。为了解决这一问题，可以使用html5的API<code>postMessage</code>.</p>\n<a id=\"more\"></a>\n<h2 id=\"postMessage简单介绍\">postMessage简单介绍</h2><p><code>postMessage()</code>方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>\n<p><code>postMessage(data,origin)</code>方法接受两个参数</p>\n<p> 1.data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。</p>\n<p>2.origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>\n<h2 id=\"子页面和父页面互相发送消息\">子页面和父页面互相发送消息</h2><p>为了兼容IE和非IE的事件绑定，下面的例子直接用了jQuery监听事件，如果用原生js，注意<code>function(e)</code>中的<code>e</code>没有包装在<code>e.originalEvent</code>，需要根据实际情况获取。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在im页面，监听切换用户事件，然后给别人发送对方的用户id。</span></div><div class=\"line\">$(<span class=\"string\">'#im'</span>).on(<span class=\"string\">'click'</span>,<span class=\"string\">'.person-item'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">key</span>:<span class=\"string\">'getUserId'</span>,<span class=\"attr\">val</span>:<span class=\"string\">'18'</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">window</span>.parent.postMessage(<span class=\"built_in\">JSON</span>.stringify(data),<span class=\"string\">'https://coolmogu.com'</span>);</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//监听来自父页面的回执</span></div><div class=\"line\">$(<span class=\"built_in\">window</span>).on(<span class=\"string\">'message'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> original = e.originalEvent;</div><div class=\"line\">    <span class=\"keyword\">if</span>(original.source != <span class=\"built_in\">window</span>.parent) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'父窗口说他收到了'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在父页面，监听事件，</span></div><div class=\"line\">$(<span class=\"built_in\">window</span>).on(<span class=\"string\">'message'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> original = e.originalEvent;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(original.data);</div><div class=\"line\">    <span class=\"keyword\">if</span>(original.origin != <span class=\"string\">'https://im.com'</span> ||  data.key != <span class=\"string\">'getUserId'</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'当前im对话的对象是'</span> + data.val);</div><div class=\"line\">    <span class=\"comment\">//父页面给iframe页面发送消息</span></div><div class=\"line\">    <span class=\"built_in\">window</span>.frames[<span class=\"number\">0</span>].postMessage(<span class=\"string\">'我收到了'</span>,<span class=\"string\">'http://im.com'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n","excerpt":"<p>最近遇到一个需求，页面嵌入了iframe框，iframe框里是一个Im在线聊天对话框。在用户切换聊天对象时，外层页面也需要获取当前用户正在聊天的对方的userid。但是由于im页面是嵌入的iframe，外层父页面既无法监听切换聊天对象的事件，也无法获取里面的dom元素，会报跨域的错误。为了解决这一问题，可以使用html5的API<code>postMessage</code>.</p>","more":"<h2 id=\"postMessage简单介绍\">postMessage简单介绍</h2><p><code>postMessage()</code>方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>\n<p><code>postMessage(data,origin)</code>方法接受两个参数</p>\n<p> 1.data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。</p>\n<p>2.origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>\n<h2 id=\"子页面和父页面互相发送消息\">子页面和父页面互相发送消息</h2><p>为了兼容IE和非IE的事件绑定，下面的例子直接用了jQuery监听事件，如果用原生js，注意<code>function(e)</code>中的<code>e</code>没有包装在<code>e.originalEvent</code>，需要根据实际情况获取。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在im页面，监听切换用户事件，然后给别人发送对方的用户id。</span></div><div class=\"line\">$(<span class=\"string\">'#im'</span>).on(<span class=\"string\">'click'</span>,<span class=\"string\">'.person-item'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">key</span>:<span class=\"string\">'getUserId'</span>,<span class=\"attr\">val</span>:<span class=\"string\">'18'</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">window</span>.parent.postMessage(<span class=\"built_in\">JSON</span>.stringify(data),<span class=\"string\">'https://coolmogu.com'</span>);</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//监听来自父页面的回执</span></div><div class=\"line\">$(<span class=\"built_in\">window</span>).on(<span class=\"string\">'message'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> original = e.originalEvent;</div><div class=\"line\">    <span class=\"keyword\">if</span>(original.source != <span class=\"built_in\">window</span>.parent) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'父窗口说他收到了'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在父页面，监听事件，</span></div><div class=\"line\">$(<span class=\"built_in\">window</span>).on(<span class=\"string\">'message'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> original = e.originalEvent;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(original.data);</div><div class=\"line\">    <span class=\"keyword\">if</span>(original.origin != <span class=\"string\">'https://im.com'</span> ||  data.key != <span class=\"string\">'getUserId'</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'当前im对话的对象是'</span> + data.val);</div><div class=\"line\">    <span class=\"comment\">//父页面给iframe页面发送消息</span></div><div class=\"line\">    <span class=\"built_in\">window</span>.frames[<span class=\"number\">0</span>].postMessage(<span class=\"string\">'我收到了'</span>,<span class=\"string\">'http://im.com'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>"},{"title":"使用pm2+github将node项目一键部署到远程服务器","_content":"每次在本地跑Node项目自娱自乐总不是很爽，一直想把自己的node项目部署到服务器上。但是我对于后端和运维知识我还是处于小白阶段，今天研究了一下午，总算是成功把自己的node项目搞了上去，又学到了新姿势。本文将介绍怎么从零开始，获得服务器，并将node项目通过github+pm2部署到远程服务器。\n<!-- more -->\n\n### 服务器环境搭建\n#### 购买服务器\n(已有服务器的可以跳过此步骤)。\n我是用的腾讯的云服务器，因为腾讯云还是比较良心，云服务器开放了免费体验功能（不知道之后会不会关闭），很适合我们这种新手先试用再购买。通过这个【[链接](https://www.qcloud.com/act/try?t=cvm)】申请了免费试用。申请成功后，就会收到该改主机的信息。我选择的1核CPU、1GB内存,系统为CentOS 7.2 64位。也许在你看到这篇文章的时候，服务器也过期了- -\n___\n现在我换成了国外的vps 便宜好用还能翻墙 嚯嚯嚯。\n\n#### 登录云服务器\n在本机终端输入以下命令即可连接上云服务器，然后需要输入给你的初始密码。\n`ssh root@服务器公网ip`\n\n#### 安装相关文件\n更新yum（云服务器自带的包管理工具）：\n```\nyum update -y\n```\n\n更新完毕后，安装Node.js：\n```\nyum install nodejs -y\n```\n\n安装Npm：\n```\nyum install npm -y\n```\n\n安装pm2：\n```\nnpm install pm2 -g\n```\n分别执行`node -v`、`npm -v`、`pm2 -v`查看是否安装成功，如果没有安装成功，前面加上`sudo`命令重试\n#### 服务器端创建新用户（可选）\n\n为服务器安全起见，创建用户(用户名：yourName)：\n```\nuseradd yourName\n```\n\n设置密码：\n```\npasswd yourName\n```\n\n添加sudo权限：\n```\nusermod -aG wheel yourName\n```\n\n#### 服务器端关闭root用户的ssh访问(可选)：\n为服务器安全起见，关闭root账户的远程访问。\n打开配置文件：\n```\nvi /etc/ssh/sshd_config\n```\n按下`i`,切换vi为输入状态\n找到如下设置，删除前面的`#`，并修改yes为no：\n```\nPermitRootLogin no\n```\n按下`esc`，切换vi为命令状态，然后输入`:wq`回车保存退出\n保存文件后，重启sshd服务：\n```\nservice sshd restart\n```\n退出root账户，并使用新创建用户访问。\n```\nssh yourName@服务器公网ip\n```\n\n### 环境说明\n本文的操作环境是\n本地：Mac OSX  \n远端服务器：腾讯云ECS（1核CPU、1GB内存），IP：119.29.101.229，系统为CentOS 7.2 64位\n采用的技术：Node.js + Express.js\nGithub：账户名：cky917\n以下命令全部带入我的账号，__自己使用时记得替换为自己的账号__。\n本文对于Git基本操作和node也不做详细讲解。\n\n### 本地创建node项目\n具体如何创建，本文不详细讨论。假设已经建立好一个名为pm2Demo的项目。\n\n### github建立链接\n登录云服务器，安装git，生成ssh-key。然后将云服务器的ssh-key加到自己的github中。\n在本地执行同样的操作。\n\n进入本地项目目录./pm2Demo，将本地项目与github远程仓库建立连接。\n```\ngit remote add origin https://github.com/cky917/pm2Demo.git\ngit push -u origin master\n```\n### pm2部署\npm2的介绍可以看看这篇[文章](https://segmentfault.com/a/1190000002539204)\n详细的部署步骤也可以看[官方配置文档](http://pm2.keymetrics.io/docs/usage/deployment/#considerations)\n\n本地安装pm2之后执行\n```\npm2 ecosystem\n```\n会生成一个ecosystem.config.js(版本原因，也可能是ecosystem.json)文件，打开该文件进行配置。修改`script`配置为node项目启动文件。\n```\napps : [\n    //由于我们此次只有一个项目,我们只配置一个app\n    {\n      name      : \"pm2Demo\",\n      script    : \"./bin/www\",\n```\n其余关于app部分的配置，可见[官方文档](http://pm2.keymetrics.io/docs/usage/application-declaration/);\n\n再配置部署部分：\n```\ndeploy : {\n    production : {//生产环境部署配置\n      user : \"cky\",//登录远程服务器的用户名\n      host : \"119.29.101.229\",//远程服务器的IP或hostname，此处可以是数组同步部署多个服务器\n      ref  : \"origin/master\",//远端名称及分支名\n      repo : \"git@github.com:cky917/pm2Demo.git\",//git仓库地址\n      path : \"/home/cky/www/production/pm2Demo\",//远程服务器部署目录，需要填写user具备写入权限的目录\n      \"post-deploy\" : \"npm install && pm2 startOrRestart ecosystem.config.js --env production\",//部署后需要执行的命令\n      \"env\"  : {\n        \"NODE_ENV\": \"production\"\n      }\n    },\n    dev : {//开发环境部署配置\n      user : \"cky\",\n      host : \"119.29.101.229\",\n      ref  : \"origin/dev\",\n      repo : \"git@github.com:cky917/pm2Demo.git\",\n      path : \"/home/cky/www/dev/pm2Demo\",\n      \"post-deploy\" : \"npm install && pm2 startOrRestart ecosystem.config.js --env dev\",\n      env  : {\n        NODE_ENV: \"dev\"\n      }\n    }\n  }\n```\n上面的代码我们部署了2个环境，当然你得有对应的分支。\n改好后，我们将ecosystem.config.js代码提交到远程github仓库去，\n```\ngit add .\ngit commit -m \"update ecosystem\"\ngit push\n```\n在云服务器端执行以下命令，将`http://github.com`加入known_hosts：\n```\nssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts\n```\n因为pm2的部署是通过ssh进行的，因此需要开通本地到远程服务器的无密码登录，同样，在Mac下，通过ssh-keygen生成RSA公钥，并拷贝到远程服务器：\n```\nscp ~/.ssh/id_rsa.pub cky@119.29.101.229:/home/cky/.ssh/authorized_keys\n```\n在本地执行命令把文件目录初始化到服务器端：\n```\npm2 deploy <configuration_file> <environment> setup\n//比如：\npm2 deploy ecosystem.config.js production setup\n```\n如果没有问题，会输出\n```\n  ...\n  ○ setup complete\n--> Success\n```\n### 一键部署代码到服务器\n在本地./pm2Demo项目下，输入以下命令部署代码到服务器\n```\npm2 deploy ecosystem.config.js production\n```\n会看到输出以下信息，表示部署成功：\n```\n Use `pm2 show <id|name>` to get more details about an app\n  ○ hook test\n  ○ successfully deployed origin/master\n--> Success\n\n```\n现在，你的代码已经被部署，而且项目也启动了。\npm2部署命令列表如下：\n```\npm2 deploy <configuration_file> <environment> <command>\n  Commands:\n    setup                run remote setup commands\n    update               update deploy to the latest release\n    revert [n]           revert to [n]th last deployment or 1\n    curr[ent]            output current release commit\n    prev[ious]           output previous release commit\n    exec|run <cmd>       execute the given <cmd>\n    list                 list previous deploy commits\n    [ref]                deploy to [ref], the \"ref\" setting, or latest tag\n```\n在这里我发现了一个问题，就是如果我的分支代码更新了，我执行部署更新命令拉取的提交记录还是初始化时的提交记录，我必须删掉服务器上的文件夹，重新执行初始化和部署的操作，不知道是本来就这样还是哪里出了问题，暂时没找到原因- -。\n\n部署成功后，在远程服务器端输入`netstat -antp`查看端口情况。可以看到3000端口已经可以访问。\n输入http://119.29.101.229:3000/ 就能访问到项目了（我把我简陋的毕设项目搞了上去 - -,管理员账户root,密码123 有兴趣可以登录试一下）\n\n### 设置开机自动启动\n可以通过pm2 startup来实现开机自启动。细节可[参考](http://pm2.keymetrics.io/docs/usage/startup/)。大致流程如下\n\n1. 通过`pm2 save`保存当前进程状态。\n2. 通过`pm2 startup [platform]`生成开机自启动的命令。（记得查看控制台输出）\n3. 将步骤2生成的命令，粘贴到控制台进行，搞定。\n\n### nginx反向代理\n通过nginx反向代理，可以让服务器上某端口，指向指定域名的80端口，这样访问时就不需要加端口号了。\n详细见[官方文档](http://pm2.keymetrics.io/docs/tutorials/pm2-nginx-production-setup)\n首先我们要在云服务器上安装nginx:\n```\nyum install nginx\n```\n安装成功后，启动nginx服务：\n```\nservice nginx start\n```\n使用命令`nginx -t`查找nginx配置文件，并使用vi命令修改该配置文件。\n我的配置如下\n\n```\nuser nginx;\nworker_processes auto;\nerror_log /var/log/nginx/error.log;\npid /run/nginx.pid;\n# Load dynamic modules. See /usr/share/nginx/README.dynamic.\ninclude /usr/share/nginx/modules/*.conf;\nevents {\n    worker_connections 1024;\n}\nhttp {\n  upstream my_nodejs_upstream {\n    server 127.0.0.1:3000;\n    keepalive 64;\n  }\n  server {\n    listen 80;\n    server_name   www.chenkeyi.com;//你的域名\n    access_log  /var/log/nginx/bysj.log;\n    error_log /var/log/nginx/bysj.error.log;\n    location / {\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Host $http_host;\n        proxy_set_header X-NginX-Proxy true;\n        proxy_http_version 1.1;\n        proxy_pass http://my_nodejs_upstream/;\n    }\n  }\n}\n```\n改完后`service nginx restart`重启nginx\n\n### 解析域名\n\n这个在腾讯云和阿里云等都提供解析域名服务。\n\n配置成功：[bysj.chenkeyi.com](http://bysj.chenkeyi.com)可以访问。\n","source":"_posts/pm2-node-service.md","raw":"title: 使用pm2+github将node项目一键部署到远程服务器\ntags:\n- node.js学习笔记 \n- web前端知识\n---\n每次在本地跑Node项目自娱自乐总不是很爽，一直想把自己的node项目部署到服务器上。但是我对于后端和运维知识我还是处于小白阶段，今天研究了一下午，总算是成功把自己的node项目搞了上去，又学到了新姿势。本文将介绍怎么从零开始，获得服务器，并将node项目通过github+pm2部署到远程服务器。\n<!-- more -->\n\n### 服务器环境搭建\n#### 购买服务器\n(已有服务器的可以跳过此步骤)。\n我是用的腾讯的云服务器，因为腾讯云还是比较良心，云服务器开放了免费体验功能（不知道之后会不会关闭），很适合我们这种新手先试用再购买。通过这个【[链接](https://www.qcloud.com/act/try?t=cvm)】申请了免费试用。申请成功后，就会收到该改主机的信息。我选择的1核CPU、1GB内存,系统为CentOS 7.2 64位。也许在你看到这篇文章的时候，服务器也过期了- -\n___\n现在我换成了国外的vps 便宜好用还能翻墙 嚯嚯嚯。\n\n#### 登录云服务器\n在本机终端输入以下命令即可连接上云服务器，然后需要输入给你的初始密码。\n`ssh root@服务器公网ip`\n\n#### 安装相关文件\n更新yum（云服务器自带的包管理工具）：\n```\nyum update -y\n```\n\n更新完毕后，安装Node.js：\n```\nyum install nodejs -y\n```\n\n安装Npm：\n```\nyum install npm -y\n```\n\n安装pm2：\n```\nnpm install pm2 -g\n```\n分别执行`node -v`、`npm -v`、`pm2 -v`查看是否安装成功，如果没有安装成功，前面加上`sudo`命令重试\n#### 服务器端创建新用户（可选）\n\n为服务器安全起见，创建用户(用户名：yourName)：\n```\nuseradd yourName\n```\n\n设置密码：\n```\npasswd yourName\n```\n\n添加sudo权限：\n```\nusermod -aG wheel yourName\n```\n\n#### 服务器端关闭root用户的ssh访问(可选)：\n为服务器安全起见，关闭root账户的远程访问。\n打开配置文件：\n```\nvi /etc/ssh/sshd_config\n```\n按下`i`,切换vi为输入状态\n找到如下设置，删除前面的`#`，并修改yes为no：\n```\nPermitRootLogin no\n```\n按下`esc`，切换vi为命令状态，然后输入`:wq`回车保存退出\n保存文件后，重启sshd服务：\n```\nservice sshd restart\n```\n退出root账户，并使用新创建用户访问。\n```\nssh yourName@服务器公网ip\n```\n\n### 环境说明\n本文的操作环境是\n本地：Mac OSX  \n远端服务器：腾讯云ECS（1核CPU、1GB内存），IP：119.29.101.229，系统为CentOS 7.2 64位\n采用的技术：Node.js + Express.js\nGithub：账户名：cky917\n以下命令全部带入我的账号，__自己使用时记得替换为自己的账号__。\n本文对于Git基本操作和node也不做详细讲解。\n\n### 本地创建node项目\n具体如何创建，本文不详细讨论。假设已经建立好一个名为pm2Demo的项目。\n\n### github建立链接\n登录云服务器，安装git，生成ssh-key。然后将云服务器的ssh-key加到自己的github中。\n在本地执行同样的操作。\n\n进入本地项目目录./pm2Demo，将本地项目与github远程仓库建立连接。\n```\ngit remote add origin https://github.com/cky917/pm2Demo.git\ngit push -u origin master\n```\n### pm2部署\npm2的介绍可以看看这篇[文章](https://segmentfault.com/a/1190000002539204)\n详细的部署步骤也可以看[官方配置文档](http://pm2.keymetrics.io/docs/usage/deployment/#considerations)\n\n本地安装pm2之后执行\n```\npm2 ecosystem\n```\n会生成一个ecosystem.config.js(版本原因，也可能是ecosystem.json)文件，打开该文件进行配置。修改`script`配置为node项目启动文件。\n```\napps : [\n    //由于我们此次只有一个项目,我们只配置一个app\n    {\n      name      : \"pm2Demo\",\n      script    : \"./bin/www\",\n```\n其余关于app部分的配置，可见[官方文档](http://pm2.keymetrics.io/docs/usage/application-declaration/);\n\n再配置部署部分：\n```\ndeploy : {\n    production : {//生产环境部署配置\n      user : \"cky\",//登录远程服务器的用户名\n      host : \"119.29.101.229\",//远程服务器的IP或hostname，此处可以是数组同步部署多个服务器\n      ref  : \"origin/master\",//远端名称及分支名\n      repo : \"git@github.com:cky917/pm2Demo.git\",//git仓库地址\n      path : \"/home/cky/www/production/pm2Demo\",//远程服务器部署目录，需要填写user具备写入权限的目录\n      \"post-deploy\" : \"npm install && pm2 startOrRestart ecosystem.config.js --env production\",//部署后需要执行的命令\n      \"env\"  : {\n        \"NODE_ENV\": \"production\"\n      }\n    },\n    dev : {//开发环境部署配置\n      user : \"cky\",\n      host : \"119.29.101.229\",\n      ref  : \"origin/dev\",\n      repo : \"git@github.com:cky917/pm2Demo.git\",\n      path : \"/home/cky/www/dev/pm2Demo\",\n      \"post-deploy\" : \"npm install && pm2 startOrRestart ecosystem.config.js --env dev\",\n      env  : {\n        NODE_ENV: \"dev\"\n      }\n    }\n  }\n```\n上面的代码我们部署了2个环境，当然你得有对应的分支。\n改好后，我们将ecosystem.config.js代码提交到远程github仓库去，\n```\ngit add .\ngit commit -m \"update ecosystem\"\ngit push\n```\n在云服务器端执行以下命令，将`http://github.com`加入known_hosts：\n```\nssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts\n```\n因为pm2的部署是通过ssh进行的，因此需要开通本地到远程服务器的无密码登录，同样，在Mac下，通过ssh-keygen生成RSA公钥，并拷贝到远程服务器：\n```\nscp ~/.ssh/id_rsa.pub cky@119.29.101.229:/home/cky/.ssh/authorized_keys\n```\n在本地执行命令把文件目录初始化到服务器端：\n```\npm2 deploy <configuration_file> <environment> setup\n//比如：\npm2 deploy ecosystem.config.js production setup\n```\n如果没有问题，会输出\n```\n  ...\n  ○ setup complete\n--> Success\n```\n### 一键部署代码到服务器\n在本地./pm2Demo项目下，输入以下命令部署代码到服务器\n```\npm2 deploy ecosystem.config.js production\n```\n会看到输出以下信息，表示部署成功：\n```\n Use `pm2 show <id|name>` to get more details about an app\n  ○ hook test\n  ○ successfully deployed origin/master\n--> Success\n\n```\n现在，你的代码已经被部署，而且项目也启动了。\npm2部署命令列表如下：\n```\npm2 deploy <configuration_file> <environment> <command>\n  Commands:\n    setup                run remote setup commands\n    update               update deploy to the latest release\n    revert [n]           revert to [n]th last deployment or 1\n    curr[ent]            output current release commit\n    prev[ious]           output previous release commit\n    exec|run <cmd>       execute the given <cmd>\n    list                 list previous deploy commits\n    [ref]                deploy to [ref], the \"ref\" setting, or latest tag\n```\n在这里我发现了一个问题，就是如果我的分支代码更新了，我执行部署更新命令拉取的提交记录还是初始化时的提交记录，我必须删掉服务器上的文件夹，重新执行初始化和部署的操作，不知道是本来就这样还是哪里出了问题，暂时没找到原因- -。\n\n部署成功后，在远程服务器端输入`netstat -antp`查看端口情况。可以看到3000端口已经可以访问。\n输入http://119.29.101.229:3000/ 就能访问到项目了（我把我简陋的毕设项目搞了上去 - -,管理员账户root,密码123 有兴趣可以登录试一下）\n\n### 设置开机自动启动\n可以通过pm2 startup来实现开机自启动。细节可[参考](http://pm2.keymetrics.io/docs/usage/startup/)。大致流程如下\n\n1. 通过`pm2 save`保存当前进程状态。\n2. 通过`pm2 startup [platform]`生成开机自启动的命令。（记得查看控制台输出）\n3. 将步骤2生成的命令，粘贴到控制台进行，搞定。\n\n### nginx反向代理\n通过nginx反向代理，可以让服务器上某端口，指向指定域名的80端口，这样访问时就不需要加端口号了。\n详细见[官方文档](http://pm2.keymetrics.io/docs/tutorials/pm2-nginx-production-setup)\n首先我们要在云服务器上安装nginx:\n```\nyum install nginx\n```\n安装成功后，启动nginx服务：\n```\nservice nginx start\n```\n使用命令`nginx -t`查找nginx配置文件，并使用vi命令修改该配置文件。\n我的配置如下\n\n```\nuser nginx;\nworker_processes auto;\nerror_log /var/log/nginx/error.log;\npid /run/nginx.pid;\n# Load dynamic modules. See /usr/share/nginx/README.dynamic.\ninclude /usr/share/nginx/modules/*.conf;\nevents {\n    worker_connections 1024;\n}\nhttp {\n  upstream my_nodejs_upstream {\n    server 127.0.0.1:3000;\n    keepalive 64;\n  }\n  server {\n    listen 80;\n    server_name   www.chenkeyi.com;//你的域名\n    access_log  /var/log/nginx/bysj.log;\n    error_log /var/log/nginx/bysj.error.log;\n    location / {\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Host $http_host;\n        proxy_set_header X-NginX-Proxy true;\n        proxy_http_version 1.1;\n        proxy_pass http://my_nodejs_upstream/;\n    }\n  }\n}\n```\n改完后`service nginx restart`重启nginx\n\n### 解析域名\n\n这个在腾讯云和阿里云等都提供解析域名服务。\n\n配置成功：[bysj.chenkeyi.com](http://bysj.chenkeyi.com)可以访问。\n","slug":"pm2-node-service","published":1,"date":"2017-01-19T08:43:33.000Z","updated":"2017-02-04T06:37:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ext0017er2zlcrfd9r6","content":"<p>每次在本地跑Node项目自娱自乐总不是很爽，一直想把自己的node项目部署到服务器上。但是我对于后端和运维知识我还是处于小白阶段，今天研究了一下午，总算是成功把自己的node项目搞了上去，又学到了新姿势。本文将介绍怎么从零开始，获得服务器，并将node项目通过github+pm2部署到远程服务器。<br><a id=\"more\"></a></p>\n<h3 id=\"服务器环境搭建\">服务器环境搭建</h3><h4 id=\"购买服务器\">购买服务器</h4><p>(已有服务器的可以跳过此步骤)。<br>我是用的腾讯的云服务器，因为腾讯云还是比较良心，云服务器开放了免费体验功能（不知道之后会不会关闭），很适合我们这种新手先试用再购买。通过这个【<a href=\"https://www.qcloud.com/act/try?t=cvm\" target=\"_blank\" rel=\"external\">链接</a>】申请了免费试用。申请成功后，就会收到该改主机的信息。我选择的1核CPU、1GB内存,系统为CentOS 7.2 64位。也许在你看到这篇文章的时候，服务器也过期了- -</p>\n<hr>\n<p>现在我换成了国外的vps 便宜好用还能翻墙 嚯嚯嚯。</p>\n<h4 id=\"登录云服务器\">登录云服务器</h4><p>在本机终端输入以下命令即可连接上云服务器，然后需要输入给你的初始密码。<br><code>ssh root@服务器公网ip</code></p>\n<h4 id=\"安装相关文件\">安装相关文件</h4><p>更新yum（云服务器自带的包管理工具）：<br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum <span class=\"keyword\">update</span> -<span class=\"built_in\">y</span></div></pre></td></tr></table></figure></p>\n<p>更新完毕后，安装Node.js：<br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum <span class=\"keyword\">install</span> nodejs -y</div></pre></td></tr></table></figure></p>\n<p>安装Npm：<br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum <span class=\"keyword\">install</span> npm -y</div></pre></td></tr></table></figure></p>\n<p>安装pm2：<br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm <span class=\"keyword\">install</span> pm2 -g</div></pre></td></tr></table></figure></p>\n<p>分别执行<code>node -v</code>、<code>npm -v</code>、<code>pm2 -v</code>查看是否安装成功，如果没有安装成功，前面加上<code>sudo</code>命令重试</p>\n<h4 id=\"服务器端创建新用户（可选）\">服务器端创建新用户（可选）</h4><p>为服务器安全起见，创建用户(用户名：yourName)：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">useradd yourName</span></div></pre></td></tr></table></figure></p>\n<p>设置密码：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">passwd yourName</span></div></pre></td></tr></table></figure></p>\n<p>添加sudo权限：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">usermod <span class=\"_\">-a</span>G wheel yourName</div></pre></td></tr></table></figure></p>\n<h4 id=\"服务器端关闭root用户的ssh访问(可选)：\">服务器端关闭root用户的ssh访问(可选)：</h4><p>为服务器安全起见，关闭root账户的远程访问。<br>打开配置文件：<br><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi <span class=\"regexp\">/etc/</span>ssh<span class=\"regexp\">/sshd_config</span></div></pre></td></tr></table></figure></p>\n<p>按下<code>i</code>,切换vi为输入状态<br>找到如下设置，删除前面的<code>#</code>，并修改yes为no：<br><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">PermitRootLogin</span> <span class=\"literal\">no</span></div></pre></td></tr></table></figure></p>\n<p>按下<code>esc</code>，切换vi为命令状态，然后输入<code>:wq</code>回车保存退出<br>保存文件后，重启sshd服务：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">service sshd restart</span></div></pre></td></tr></table></figure></p>\n<p>退出root账户，并使用新创建用户访问。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">ssh</span> <span class=\"selector-tag\">yourName</span>@服务器公网<span class=\"keyword\">ip</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"环境说明\">环境说明</h3><p>本文的操作环境是<br>本地：Mac OSX<br>远端服务器：腾讯云ECS（1核CPU、1GB内存），IP：119.29.101.229，系统为CentOS 7.2 64位<br>采用的技术：Node.js + Express.js<br>Github：账户名：cky917<br>以下命令全部带入我的账号，<strong>自己使用时记得替换为自己的账号</strong>。<br>本文对于Git基本操作和node也不做详细讲解。</p>\n<h3 id=\"本地创建node项目\">本地创建node项目</h3><p>具体如何创建，本文不详细讨论。假设已经建立好一个名为pm2Demo的项目。</p>\n<h3 id=\"github建立链接\">github建立链接</h3><p>登录云服务器，安装git，生成ssh-key。然后将云服务器的ssh-key加到自己的github中。<br>在本地执行同样的操作。</p>\n<p>进入本地项目目录./pm2Demo，将本地项目与github远程仓库建立连接。<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git remote <span class=\"keyword\">add</span><span class=\"bash\"> origin https://github.com/cky917/pm2Demo.git</span></div><div class=\"line\">git push -u origin master</div></pre></td></tr></table></figure></p>\n<h3 id=\"pm2部署\">pm2部署</h3><p>pm2的介绍可以看看这篇<a href=\"https://segmentfault.com/a/1190000002539204\" target=\"_blank\" rel=\"external\">文章</a><br>详细的部署步骤也可以看<a href=\"http://pm2.keymetrics.io/docs/usage/deployment/#considerations\" target=\"_blank\" rel=\"external\">官方配置文档</a></p>\n<p>本地安装pm2之后执行<br><figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">p<span class=\"name\">m2</span> ecosystem</div></pre></td></tr></table></figure></p>\n<p>会生成一个ecosystem.config.js(版本原因，也可能是ecosystem.json)文件，打开该文件进行配置。修改<code>script</code>配置为node项目启动文件。<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">apps :</span> [</div><div class=\"line\">    <span class=\"comment\">//由于我们此次只有一个项目,我们只配置一个app</span></div><div class=\"line\">    &#123;</div><div class=\"line\">      <span class=\"string\">name      :</span> <span class=\"string\">\"pm2Demo\"</span>,</div><div class=\"line\">      <span class=\"string\">script    :</span> <span class=\"string\">\"./bin/www\"</span>,</div></pre></td></tr></table></figure></p>\n<p>其余关于app部分的配置，可见<a href=\"http://pm2.keymetrics.io/docs/usage/application-declaration/\" target=\"_blank\" rel=\"external\">官方文档</a>;</p>\n<p>再配置部署部分：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">deploy </span>: &#123;</div><div class=\"line\">    <span class=\"attribute\">production </span>: &#123;<span class=\"comment\">//生产环境部署配置</span></div><div class=\"line\">      <span class=\"attribute\">user </span>: <span class=\"string\">\"cky\"</span>,<span class=\"comment\">//登录远程服务器的用户名</span></div><div class=\"line\">      <span class=\"attribute\">host </span>: <span class=\"string\">\"119.29.101.229\"</span>,<span class=\"comment\">//远程服务器的IP或hostname，此处可以是数组同步部署多个服务器</span></div><div class=\"line\">      <span class=\"attribute\">ref  </span>: <span class=\"string\">\"origin/master\"</span>,<span class=\"comment\">//远端名称及分支名</span></div><div class=\"line\">      <span class=\"attribute\">repo </span>: <span class=\"string\">\"git@github.com:cky917/pm2Demo.git\"</span>,<span class=\"comment\">//git仓库地址</span></div><div class=\"line\">      <span class=\"attribute\">path </span>: <span class=\"string\">\"/home/cky/www/production/pm2Demo\"</span>,<span class=\"comment\">//远程服务器部署目录，需要填写user具备写入权限的目录</span></div><div class=\"line\">      <span class=\"string\">\"post-deploy\"</span> : <span class=\"string\">\"npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production\"</span>,<span class=\"comment\">//部署后需要执行的命令</span></div><div class=\"line\">      <span class=\"string\">\"env\"</span>  : &#123;</div><div class=\"line\">        <span class=\"string\">\"NODE_ENV\"</span>: <span class=\"string\">\"production\"</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attribute\">dev </span>: &#123;<span class=\"comment\">//开发环境部署配置</span></div><div class=\"line\">      <span class=\"attribute\">user </span>: <span class=\"string\">\"cky\"</span>,</div><div class=\"line\">      <span class=\"attribute\">host </span>: <span class=\"string\">\"119.29.101.229\"</span>,</div><div class=\"line\">      <span class=\"attribute\">ref  </span>: <span class=\"string\">\"origin/dev\"</span>,</div><div class=\"line\">      <span class=\"attribute\">repo </span>: <span class=\"string\">\"git@github.com:cky917/pm2Demo.git\"</span>,</div><div class=\"line\">      <span class=\"attribute\">path </span>: <span class=\"string\">\"/home/cky/www/dev/pm2Demo\"</span>,</div><div class=\"line\">      <span class=\"string\">\"post-deploy\"</span> : <span class=\"string\">\"npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env dev\"</span>,</div><div class=\"line\">      <span class=\"attribute\">env  </span>: &#123;</div><div class=\"line\">        <span class=\"attribute\">NODE_ENV</span>: <span class=\"string\">\"dev\"</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>上面的代码我们部署了2个环境，当然你得有对应的分支。<br>改好后，我们将ecosystem.config.js代码提交到远程github仓库去，<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"keyword\">add</span><span class=\"bash\"> .</span></div><div class=\"line\">git commit -m <span class=\"string\">\"update ecosystem\"</span></div><div class=\"line\">git push</div></pre></td></tr></table></figure></p>\n<p>在云服务器端执行以下命令，将<code>http://github.com</code>加入known_hosts：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keyscan -t rsa github.com <span class=\"meta\">&gt;&gt; </span>~<span class=\"regexp\">/.ssh/known</span>_hosts</div></pre></td></tr></table></figure></p>\n<p>因为pm2的部署是通过ssh进行的，因此需要开通本地到远程服务器的无密码登录，同样，在Mac下，通过ssh-keygen生成RSA公钥，并拷贝到远程服务器：<br><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp ~<span class=\"regexp\">/.ssh/id</span>_rsa.pub cky<span class=\"variable\">@119</span>.<span class=\"number\">29.101</span>.<span class=\"number\">229</span><span class=\"symbol\">:/home/cky/</span>.ssh/authorized_keys</div></pre></td></tr></table></figure></p>\n<p>在本地执行命令把文件目录初始化到服务器端：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pm2 deploy &lt;configuration_file&gt; &lt;environment&gt; <span class=\"built_in\">setup</span></div><div class=\"line\"><span class=\"comment\">//比如：</span></div><div class=\"line\">pm2 deploy ecosystem.<span class=\"built_in\">config</span>.js production <span class=\"built_in\">setup</span></div></pre></td></tr></table></figure></p>\n<p>如果没有问题，会输出<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  ...</div><div class=\"line\">  ○ setup complete</div><div class=\"line\">--&gt; Success</div></pre></td></tr></table></figure></p>\n<h3 id=\"一键部署代码到服务器\">一键部署代码到服务器</h3><p>在本地./pm2Demo项目下，输入以下命令部署代码到服务器<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pm2 deploy ecosystem<span class=\"selector-class\">.config</span><span class=\"selector-class\">.js</span> production</div></pre></td></tr></table></figure></p>\n<p>会看到输出以下信息，表示部署成功：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">Use</span> <span class=\"string\">`pm2 show &lt;id|name&gt;`</span> <span class=\"keyword\">to</span> <span class=\"keyword\">get</span> more details about an app</div><div class=\"line\">  ○ hook <span class=\"keyword\">test</span></div><div class=\"line\">  ○ successfully deployed origin/<span class=\"keyword\">master</span></div><div class=\"line\"><span class=\"comment\">--&gt; Success</span></div></pre></td></tr></table></figure></p>\n<p>现在，你的代码已经被部署，而且项目也启动了。<br>pm2部署命令列表如下：<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">pm2 deploy <span class=\"symbol\">&lt;configuration_file&gt;</span> <span class=\"symbol\">&lt;environment&gt;</span> <span class=\"symbol\">&lt;command&gt;</span></div><div class=\"line\">  Command<span class=\"variable\">s:</span></div><div class=\"line\">    setup                run remote setup commands</div><div class=\"line\">    <span class=\"keyword\">update</span>               <span class=\"keyword\">update</span> deploy <span class=\"keyword\">to</span> the latest release</div><div class=\"line\">    revert [n]           revert <span class=\"keyword\">to</span> [n]<span class=\"keyword\">th</span> <span class=\"keyword\">last</span> deployment <span class=\"built_in\">or</span> <span class=\"number\">1</span></div><div class=\"line\">    curr[ent]            output current release commit</div><div class=\"line\">    <span class=\"keyword\">prev</span>[ious]           output <span class=\"keyword\">previous</span> release commit</div><div class=\"line\">    exec|run <span class=\"symbol\">&lt;cmd&gt;</span>       <span class=\"keyword\">execute</span> the given <span class=\"symbol\">&lt;cmd&gt;</span></div><div class=\"line\">    <span class=\"keyword\">list</span>                 <span class=\"keyword\">list</span> <span class=\"keyword\">previous</span> deploy commits</div><div class=\"line\">    [ref]                deploy <span class=\"keyword\">to</span> [ref], the <span class=\"string\">\"ref\"</span> setting, <span class=\"built_in\">or</span> latest <span class=\"keyword\">tag</span></div></pre></td></tr></table></figure></p>\n<p>在这里我发现了一个问题，就是如果我的分支代码更新了，我执行部署更新命令拉取的提交记录还是初始化时的提交记录，我必须删掉服务器上的文件夹，重新执行初始化和部署的操作，不知道是本来就这样还是哪里出了问题，暂时没找到原因- -。</p>\n<p>部署成功后，在远程服务器端输入<code>netstat -antp</code>查看端口情况。可以看到3000端口已经可以访问。<br>输入<a href=\"http://119.29.101.229:3000/\" target=\"_blank\" rel=\"external\">http://119.29.101.229:3000/</a> 就能访问到项目了（我把我简陋的毕设项目搞了上去 - -,管理员账户root,密码123 有兴趣可以登录试一下）</p>\n<h3 id=\"设置开机自动启动\">设置开机自动启动</h3><p>可以通过pm2 startup来实现开机自启动。细节可<a href=\"http://pm2.keymetrics.io/docs/usage/startup/\" target=\"_blank\" rel=\"external\">参考</a>。大致流程如下</p>\n<ol>\n<li>通过<code>pm2 save</code>保存当前进程状态。</li>\n<li>通过<code>pm2 startup [platform]</code>生成开机自启动的命令。（记得查看控制台输出）</li>\n<li>将步骤2生成的命令，粘贴到控制台进行，搞定。</li>\n</ol>\n<h3 id=\"nginx反向代理\">nginx反向代理</h3><p>通过nginx反向代理，可以让服务器上某端口，指向指定域名的80端口，这样访问时就不需要加端口号了。<br>详细见<a href=\"http://pm2.keymetrics.io/docs/tutorials/pm2-nginx-production-setup\" target=\"_blank\" rel=\"external\">官方文档</a><br>首先我们要在云服务器上安装nginx:<br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum <span class=\"keyword\">install</span> nginx</div></pre></td></tr></table></figure></p>\n<p>安装成功后，启动nginx服务：<br><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service nginx <span class=\"literal\">start</span></div></pre></td></tr></table></figure></p>\n<p>使用命令<code>nginx -t</code>查找nginx配置文件，并使用vi命令修改该配置文件。<br>我的配置如下</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">user</span> nginx;</div><div class=\"line\">worker_processes auto;</div><div class=\"line\">error_log /var/<span class=\"keyword\">log</span>/nginx/error.<span class=\"keyword\">log</span>;</div><div class=\"line\">pid /run/nginx.pid;</div><div class=\"line\"><span class=\"comment\"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span></div><div class=\"line\">include /usr/share/nginx/modules/*.conf;</div><div class=\"line\">events &#123;</div><div class=\"line\">    worker_connections <span class=\"number\">1024</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">http &#123;</div><div class=\"line\">  upstream my_nodejs_upstream &#123;</div><div class=\"line\">    server <span class=\"number\">127.0</span>.<span class=\"number\">0.1</span>:<span class=\"number\">3000</span>;</div><div class=\"line\">    keepalive <span class=\"number\">64</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  server &#123;</div><div class=\"line\">    listen <span class=\"number\">80</span>;</div><div class=\"line\">    server_name   www.chenkeyi.com;//你的域名</div><div class=\"line\">    access_log  /var/<span class=\"keyword\">log</span>/nginx/bysj.<span class=\"keyword\">log</span>;</div><div class=\"line\">    error_log /var/<span class=\"keyword\">log</span>/nginx/bysj.error.<span class=\"keyword\">log</span>;</div><div class=\"line\">    location / &#123;</div><div class=\"line\">        proxy_set_header X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</div><div class=\"line\">        proxy_set_header Host <span class=\"variable\">$http_host</span>;</div><div class=\"line\">        proxy_set_header X-NginX-Proxy true;</div><div class=\"line\">        proxy_http_version <span class=\"number\">1.1</span>;</div><div class=\"line\">        proxy_pass http://my_nodejs_upstream/;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>改完后<code>service nginx restart</code>重启nginx</p>\n<h3 id=\"解析域名\">解析域名</h3><p>这个在腾讯云和阿里云等都提供解析域名服务。</p>\n<p>配置成功：<a href=\"http://bysj.chenkeyi.com\" target=\"_blank\" rel=\"external\">bysj.chenkeyi.com</a>可以访问。</p>\n","excerpt":"<p>每次在本地跑Node项目自娱自乐总不是很爽，一直想把自己的node项目部署到服务器上。但是我对于后端和运维知识我还是处于小白阶段，今天研究了一下午，总算是成功把自己的node项目搞了上去，又学到了新姿势。本文将介绍怎么从零开始，获得服务器，并将node项目通过github+pm2部署到远程服务器。<br>","more":"</p>\n<h3 id=\"服务器环境搭建\">服务器环境搭建</h3><h4 id=\"购买服务器\">购买服务器</h4><p>(已有服务器的可以跳过此步骤)。<br>我是用的腾讯的云服务器，因为腾讯云还是比较良心，云服务器开放了免费体验功能（不知道之后会不会关闭），很适合我们这种新手先试用再购买。通过这个【<a href=\"https://www.qcloud.com/act/try?t=cvm\">链接</a>】申请了免费试用。申请成功后，就会收到该改主机的信息。我选择的1核CPU、1GB内存,系统为CentOS 7.2 64位。也许在你看到这篇文章的时候，服务器也过期了- -</p>\n<hr>\n<p>现在我换成了国外的vps 便宜好用还能翻墙 嚯嚯嚯。</p>\n<h4 id=\"登录云服务器\">登录云服务器</h4><p>在本机终端输入以下命令即可连接上云服务器，然后需要输入给你的初始密码。<br><code>ssh root@服务器公网ip</code></p>\n<h4 id=\"安装相关文件\">安装相关文件</h4><p>更新yum（云服务器自带的包管理工具）：<br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum <span class=\"keyword\">update</span> -<span class=\"built_in\">y</span></div></pre></td></tr></table></figure></p>\n<p>更新完毕后，安装Node.js：<br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum <span class=\"keyword\">install</span> nodejs -y</div></pre></td></tr></table></figure></p>\n<p>安装Npm：<br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum <span class=\"keyword\">install</span> npm -y</div></pre></td></tr></table></figure></p>\n<p>安装pm2：<br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm <span class=\"keyword\">install</span> pm2 -g</div></pre></td></tr></table></figure></p>\n<p>分别执行<code>node -v</code>、<code>npm -v</code>、<code>pm2 -v</code>查看是否安装成功，如果没有安装成功，前面加上<code>sudo</code>命令重试</p>\n<h4 id=\"服务器端创建新用户（可选）\">服务器端创建新用户（可选）</h4><p>为服务器安全起见，创建用户(用户名：yourName)：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">useradd yourName</span></div></pre></td></tr></table></figure></p>\n<p>设置密码：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">passwd yourName</span></div></pre></td></tr></table></figure></p>\n<p>添加sudo权限：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">usermod <span class=\"_\">-a</span>G wheel yourName</div></pre></td></tr></table></figure></p>\n<h4 id=\"服务器端关闭root用户的ssh访问(可选)：\">服务器端关闭root用户的ssh访问(可选)：</h4><p>为服务器安全起见，关闭root账户的远程访问。<br>打开配置文件：<br><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi <span class=\"regexp\">/etc/</span>ssh<span class=\"regexp\">/sshd_config</span></div></pre></td></tr></table></figure></p>\n<p>按下<code>i</code>,切换vi为输入状态<br>找到如下设置，删除前面的<code>#</code>，并修改yes为no：<br><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">PermitRootLogin</span> <span class=\"literal\">no</span></div></pre></td></tr></table></figure></p>\n<p>按下<code>esc</code>，切换vi为命令状态，然后输入<code>:wq</code>回车保存退出<br>保存文件后，重启sshd服务：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">service sshd restart</span></div></pre></td></tr></table></figure></p>\n<p>退出root账户，并使用新创建用户访问。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">ssh</span> <span class=\"selector-tag\">yourName</span>@服务器公网<span class=\"keyword\">ip</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"环境说明\">环境说明</h3><p>本文的操作环境是<br>本地：Mac OSX<br>远端服务器：腾讯云ECS（1核CPU、1GB内存），IP：119.29.101.229，系统为CentOS 7.2 64位<br>采用的技术：Node.js + Express.js<br>Github：账户名：cky917<br>以下命令全部带入我的账号，<strong>自己使用时记得替换为自己的账号</strong>。<br>本文对于Git基本操作和node也不做详细讲解。</p>\n<h3 id=\"本地创建node项目\">本地创建node项目</h3><p>具体如何创建，本文不详细讨论。假设已经建立好一个名为pm2Demo的项目。</p>\n<h3 id=\"github建立链接\">github建立链接</h3><p>登录云服务器，安装git，生成ssh-key。然后将云服务器的ssh-key加到自己的github中。<br>在本地执行同样的操作。</p>\n<p>进入本地项目目录./pm2Demo，将本地项目与github远程仓库建立连接。<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git remote <span class=\"keyword\">add</span><span class=\"bash\"> origin https://github.com/cky917/pm2Demo.git</div><div class=\"line\"></span>git push -u origin master</div></pre></td></tr></table></figure></p>\n<h3 id=\"pm2部署\">pm2部署</h3><p>pm2的介绍可以看看这篇<a href=\"https://segmentfault.com/a/1190000002539204\">文章</a><br>详细的部署步骤也可以看<a href=\"http://pm2.keymetrics.io/docs/usage/deployment/#considerations\">官方配置文档</a></p>\n<p>本地安装pm2之后执行<br><figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">p<span class=\"name\">m2</span> ecosystem</div></pre></td></tr></table></figure></p>\n<p>会生成一个ecosystem.config.js(版本原因，也可能是ecosystem.json)文件，打开该文件进行配置。修改<code>script</code>配置为node项目启动文件。<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">apps :</span> [</div><div class=\"line\">    <span class=\"comment\">//由于我们此次只有一个项目,我们只配置一个app</span></div><div class=\"line\">    &#123;</div><div class=\"line\">      <span class=\"string\">name      :</span> <span class=\"string\">\"pm2Demo\"</span>,</div><div class=\"line\">      <span class=\"string\">script    :</span> <span class=\"string\">\"./bin/www\"</span>,</div></pre></td></tr></table></figure></p>\n<p>其余关于app部分的配置，可见<a href=\"http://pm2.keymetrics.io/docs/usage/application-declaration/\">官方文档</a>;</p>\n<p>再配置部署部分：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">deploy </span>: &#123;</div><div class=\"line\">    <span class=\"attribute\">production </span>: &#123;<span class=\"comment\">//生产环境部署配置</span></div><div class=\"line\">      <span class=\"attribute\">user </span>: <span class=\"string\">\"cky\"</span>,<span class=\"comment\">//登录远程服务器的用户名</span></div><div class=\"line\">      <span class=\"attribute\">host </span>: <span class=\"string\">\"119.29.101.229\"</span>,<span class=\"comment\">//远程服务器的IP或hostname，此处可以是数组同步部署多个服务器</span></div><div class=\"line\">      <span class=\"attribute\">ref  </span>: <span class=\"string\">\"origin/master\"</span>,<span class=\"comment\">//远端名称及分支名</span></div><div class=\"line\">      <span class=\"attribute\">repo </span>: <span class=\"string\">\"git@github.com:cky917/pm2Demo.git\"</span>,<span class=\"comment\">//git仓库地址</span></div><div class=\"line\">      <span class=\"attribute\">path </span>: <span class=\"string\">\"/home/cky/www/production/pm2Demo\"</span>,<span class=\"comment\">//远程服务器部署目录，需要填写user具备写入权限的目录</span></div><div class=\"line\">      <span class=\"string\">\"post-deploy\"</span> : <span class=\"string\">\"npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production\"</span>,<span class=\"comment\">//部署后需要执行的命令</span></div><div class=\"line\">      <span class=\"string\">\"env\"</span>  : &#123;</div><div class=\"line\">        <span class=\"string\">\"NODE_ENV\"</span>: <span class=\"string\">\"production\"</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attribute\">dev </span>: &#123;<span class=\"comment\">//开发环境部署配置</span></div><div class=\"line\">      <span class=\"attribute\">user </span>: <span class=\"string\">\"cky\"</span>,</div><div class=\"line\">      <span class=\"attribute\">host </span>: <span class=\"string\">\"119.29.101.229\"</span>,</div><div class=\"line\">      <span class=\"attribute\">ref  </span>: <span class=\"string\">\"origin/dev\"</span>,</div><div class=\"line\">      <span class=\"attribute\">repo </span>: <span class=\"string\">\"git@github.com:cky917/pm2Demo.git\"</span>,</div><div class=\"line\">      <span class=\"attribute\">path </span>: <span class=\"string\">\"/home/cky/www/dev/pm2Demo\"</span>,</div><div class=\"line\">      <span class=\"string\">\"post-deploy\"</span> : <span class=\"string\">\"npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env dev\"</span>,</div><div class=\"line\">      <span class=\"attribute\">env  </span>: &#123;</div><div class=\"line\">        <span class=\"attribute\">NODE_ENV</span>: <span class=\"string\">\"dev\"</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>上面的代码我们部署了2个环境，当然你得有对应的分支。<br>改好后，我们将ecosystem.config.js代码提交到远程github仓库去，<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"keyword\">add</span><span class=\"bash\"> .</div><div class=\"line\"></span>git commit -m <span class=\"string\">\"update ecosystem\"</span></div><div class=\"line\">git push</div></pre></td></tr></table></figure></p>\n<p>在云服务器端执行以下命令，将<code>http://github.com</code>加入known_hosts：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keyscan -t rsa github.com <span class=\"meta\">&gt;&gt; </span>~<span class=\"regexp\">/.ssh/known</span>_hosts</div></pre></td></tr></table></figure></p>\n<p>因为pm2的部署是通过ssh进行的，因此需要开通本地到远程服务器的无密码登录，同样，在Mac下，通过ssh-keygen生成RSA公钥，并拷贝到远程服务器：<br><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp ~<span class=\"regexp\">/.ssh/id</span>_rsa.pub cky<span class=\"variable\">@119</span>.<span class=\"number\">29.101</span>.<span class=\"number\">229</span><span class=\"symbol\">:/home/cky/</span>.ssh/authorized_keys</div></pre></td></tr></table></figure></p>\n<p>在本地执行命令把文件目录初始化到服务器端：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pm2 deploy &lt;configuration_file&gt; &lt;environment&gt; <span class=\"built_in\">setup</span></div><div class=\"line\"><span class=\"comment\">//比如：</span></div><div class=\"line\">pm2 deploy ecosystem.<span class=\"built_in\">config</span>.js production <span class=\"built_in\">setup</span></div></pre></td></tr></table></figure></p>\n<p>如果没有问题，会输出<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  ...</div><div class=\"line\">  ○ setup complete</div><div class=\"line\">--&gt; Success</div></pre></td></tr></table></figure></p>\n<h3 id=\"一键部署代码到服务器\">一键部署代码到服务器</h3><p>在本地./pm2Demo项目下，输入以下命令部署代码到服务器<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pm2 deploy ecosystem<span class=\"selector-class\">.config</span><span class=\"selector-class\">.js</span> production</div></pre></td></tr></table></figure></p>\n<p>会看到输出以下信息，表示部署成功：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"keyword\">Use</span> <span class=\"string\">`pm2 show &lt;id|name&gt;`</span> <span class=\"keyword\">to</span> <span class=\"keyword\">get</span> more details about an app</div><div class=\"line\">  ○ hook <span class=\"keyword\">test</span></div><div class=\"line\">  ○ successfully deployed origin/<span class=\"keyword\">master</span></div><div class=\"line\"><span class=\"comment\">--&gt; Success</span></div></pre></td></tr></table></figure></p>\n<p>现在，你的代码已经被部署，而且项目也启动了。<br>pm2部署命令列表如下：<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">pm2 deploy <span class=\"symbol\">&lt;configuration_file&gt;</span> <span class=\"symbol\">&lt;environment&gt;</span> <span class=\"symbol\">&lt;command&gt;</span></div><div class=\"line\">  Command<span class=\"variable\">s:</span></div><div class=\"line\">    setup                run remote setup commands</div><div class=\"line\">    <span class=\"keyword\">update</span>               <span class=\"keyword\">update</span> deploy <span class=\"keyword\">to</span> the latest release</div><div class=\"line\">    revert [n]           revert <span class=\"keyword\">to</span> [n]<span class=\"keyword\">th</span> <span class=\"keyword\">last</span> deployment <span class=\"built_in\">or</span> <span class=\"number\">1</span></div><div class=\"line\">    curr[ent]            output current release commit</div><div class=\"line\">    <span class=\"keyword\">prev</span>[ious]           output <span class=\"keyword\">previous</span> release commit</div><div class=\"line\">    exec|run <span class=\"symbol\">&lt;cmd&gt;</span>       <span class=\"keyword\">execute</span> the given <span class=\"symbol\">&lt;cmd&gt;</span></div><div class=\"line\">    <span class=\"keyword\">list</span>                 <span class=\"keyword\">list</span> <span class=\"keyword\">previous</span> deploy commits</div><div class=\"line\">    [ref]                deploy <span class=\"keyword\">to</span> [ref], the <span class=\"string\">\"ref\"</span> setting, <span class=\"built_in\">or</span> latest <span class=\"keyword\">tag</span></div></pre></td></tr></table></figure></p>\n<p>在这里我发现了一个问题，就是如果我的分支代码更新了，我执行部署更新命令拉取的提交记录还是初始化时的提交记录，我必须删掉服务器上的文件夹，重新执行初始化和部署的操作，不知道是本来就这样还是哪里出了问题，暂时没找到原因- -。</p>\n<p>部署成功后，在远程服务器端输入<code>netstat -antp</code>查看端口情况。可以看到3000端口已经可以访问。<br>输入<a href=\"http://119.29.101.229:3000/\">http://119.29.101.229:3000/</a> 就能访问到项目了（我把我简陋的毕设项目搞了上去 - -,管理员账户root,密码123 有兴趣可以登录试一下）</p>\n<h3 id=\"设置开机自动启动\">设置开机自动启动</h3><p>可以通过pm2 startup来实现开机自启动。细节可<a href=\"http://pm2.keymetrics.io/docs/usage/startup/\">参考</a>。大致流程如下</p>\n<ol>\n<li>通过<code>pm2 save</code>保存当前进程状态。</li>\n<li>通过<code>pm2 startup [platform]</code>生成开机自启动的命令。（记得查看控制台输出）</li>\n<li>将步骤2生成的命令，粘贴到控制台进行，搞定。</li>\n</ol>\n<h3 id=\"nginx反向代理\">nginx反向代理</h3><p>通过nginx反向代理，可以让服务器上某端口，指向指定域名的80端口，这样访问时就不需要加端口号了。<br>详细见<a href=\"http://pm2.keymetrics.io/docs/tutorials/pm2-nginx-production-setup\">官方文档</a><br>首先我们要在云服务器上安装nginx:<br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum <span class=\"keyword\">install</span> nginx</div></pre></td></tr></table></figure></p>\n<p>安装成功后，启动nginx服务：<br><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service nginx <span class=\"literal\">start</span></div></pre></td></tr></table></figure></p>\n<p>使用命令<code>nginx -t</code>查找nginx配置文件，并使用vi命令修改该配置文件。<br>我的配置如下</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">user</span> nginx;</div><div class=\"line\">worker_processes auto;</div><div class=\"line\">error_log /var/<span class=\"keyword\">log</span>/nginx/error.<span class=\"keyword\">log</span>;</div><div class=\"line\">pid /run/nginx.pid;</div><div class=\"line\"><span class=\"comment\"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span></div><div class=\"line\">include /usr/share/nginx/modules/*.conf;</div><div class=\"line\">events &#123;</div><div class=\"line\">    worker_connections <span class=\"number\">1024</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">http &#123;</div><div class=\"line\">  upstream my_nodejs_upstream &#123;</div><div class=\"line\">    server <span class=\"number\">127.0</span>.<span class=\"number\">0.1</span>:<span class=\"number\">3000</span>;</div><div class=\"line\">    keepalive <span class=\"number\">64</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  server &#123;</div><div class=\"line\">    listen <span class=\"number\">80</span>;</div><div class=\"line\">    server_name   www.chenkeyi.com;//你的域名</div><div class=\"line\">    access_log  /var/<span class=\"keyword\">log</span>/nginx/bysj.<span class=\"keyword\">log</span>;</div><div class=\"line\">    error_log /var/<span class=\"keyword\">log</span>/nginx/bysj.error.<span class=\"keyword\">log</span>;</div><div class=\"line\">    location / &#123;</div><div class=\"line\">        proxy_set_header X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</div><div class=\"line\">        proxy_set_header Host <span class=\"variable\">$http_host</span>;</div><div class=\"line\">        proxy_set_header X-NginX-Proxy true;</div><div class=\"line\">        proxy_http_version <span class=\"number\">1.1</span>;</div><div class=\"line\">        proxy_pass http://my_nodejs_upstream/;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>改完后<code>service nginx restart</code>重启nginx</p>\n<h3 id=\"解析域名\">解析域名</h3><p>这个在腾讯云和阿里云等都提供解析域名服务。</p>\n<p>配置成功：<a href=\"http://bysj.chenkeyi.com\">bysj.chenkeyi.com</a>可以访问。</p>"},{"title":"微信公众号爬虫","_content":"最近搞了一个基于nodejs+vue的微信公众号文章爬虫，交互什么的也基本没有优化，先占个坑，之后搞好了来写写教程。\n地址：http://read.chenkeyi.com","source":"_posts/wxPachong.md","raw":"title: 微信公众号爬虫\ntags: node.js学习笔记\n---\n最近搞了一个基于nodejs+vue的微信公众号文章爬虫，交互什么的也基本没有优化，先占个坑，之后搞好了来写写教程。\n地址：http://read.chenkeyi.com","slug":"wxPachong","published":1,"date":"2017-05-10T11:31:51.000Z","updated":"2017-05-12T02:55:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489exw001aer2zo2yu5ob7","content":"<p>最近搞了一个基于nodejs+vue的微信公众号文章爬虫，交互什么的也基本没有优化，先占个坑，之后搞好了来写写教程。<br>地址：<a href=\"http://read.chenkeyi.com\" target=\"_blank\" rel=\"external\">http://read.chenkeyi.com</a></p>\n","excerpt":"","more":"<p>最近搞了一个基于nodejs+vue的微信公众号文章爬虫，交互什么的也基本没有优化，先占个坑，之后搞好了来写写教程。<br>地址：<a href=\"http://read.chenkeyi.com\">http://read.chenkeyi.com</a></p>\n"},{"title":"webpack学习笔记","_content":"webpack学习笔记\n<!-- more -->\n## 配置：\n```\nconst path = require('path');\nconst htmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    //入口文件\n    // entry: './src/script/main.js',\n    // entry:[\"./src/script/main.js\",\"./src/script/a.js\"],//把2个文件打包在一起\n    entry:{\n        main:'./src/script/main.js',\n        a:\"./src/script/a.js\"\n    },\n    //输出\n    output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: 'js/[name]-[chunkhash].js',\n        publicPath: 'http://cdn.com' //编译的文件域名\n    },\n    plugins:[\n        //https://www.npmjs.com/package/html-webpack-plugin\n        new htmlWebpackPlugin({\n            filename:'index.html',\n            template: 'index.html',\n            inject:'body', //script标签放的位置\n            title:'webpack is index',\n            minify: {\n                removeComments:true,//删除注释\n                collapseWhitespace:true\n            },\n            // chunks: ['main','a'] //指定当前html包含的chunk\n            excludeChunks:['a']//指定排除的chunk\n        }),\n        new htmlWebpackPlugin({\n            filename:'a.html',\n            template: 'index.html',\n            inject:'body', //script标签放的位置\n            title:'webpack is a',\n            minify: {\n                removeComments:true,//删除注释\n                collapseWhitespace:true\n            },\n            // chunks: ['a'] //指定当前html包含的chunk\n            excludeChunks:['main']//指定排除的chunk\n        }),\n    ]\n};\n```","source":"_posts/webpack.md","raw":"title: webpack学习笔记\ntags: web前端知识\n---\nwebpack学习笔记\n<!-- more -->\n## 配置：\n```\nconst path = require('path');\nconst htmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    //入口文件\n    // entry: './src/script/main.js',\n    // entry:[\"./src/script/main.js\",\"./src/script/a.js\"],//把2个文件打包在一起\n    entry:{\n        main:'./src/script/main.js',\n        a:\"./src/script/a.js\"\n    },\n    //输出\n    output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: 'js/[name]-[chunkhash].js',\n        publicPath: 'http://cdn.com' //编译的文件域名\n    },\n    plugins:[\n        //https://www.npmjs.com/package/html-webpack-plugin\n        new htmlWebpackPlugin({\n            filename:'index.html',\n            template: 'index.html',\n            inject:'body', //script标签放的位置\n            title:'webpack is index',\n            minify: {\n                removeComments:true,//删除注释\n                collapseWhitespace:true\n            },\n            // chunks: ['main','a'] //指定当前html包含的chunk\n            excludeChunks:['a']//指定排除的chunk\n        }),\n        new htmlWebpackPlugin({\n            filename:'a.html',\n            template: 'index.html',\n            inject:'body', //script标签放的位置\n            title:'webpack is a',\n            minify: {\n                removeComments:true,//删除注释\n                collapseWhitespace:true\n            },\n            // chunks: ['a'] //指定当前html包含的chunk\n            excludeChunks:['main']//指定排除的chunk\n        }),\n    ]\n};\n```","slug":"webpack","published":1,"date":"2017-08-08T13:00:42.000Z","updated":"2017-08-08T16:27:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ey0001cer2zqpyjtiik","content":"<p>webpack学习笔记<br><a id=\"more\"></a></p>\n<h2 id=\"配置：\">配置：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> htmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"comment\">//入口文件</span></div><div class=\"line\">    <span class=\"comment\">// entry: './src/script/main.js',</span></div><div class=\"line\">    <span class=\"comment\">// entry:[\"./src/script/main.js\",\"./src/script/a.js\"],//把2个文件打包在一起</span></div><div class=\"line\">    entry:&#123;</div><div class=\"line\">        <span class=\"attr\">main</span>:<span class=\"string\">'./src/script/main.js'</span>,</div><div class=\"line\">        <span class=\"attr\">a</span>:<span class=\"string\">\"./src/script/a.js\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">//输出</span></div><div class=\"line\">    output: &#123;</div><div class=\"line\">        <span class=\"attr\">path</span>: path.resolve(__dirname, <span class=\"string\">'./dist'</span>),</div><div class=\"line\">        <span class=\"attr\">filename</span>: <span class=\"string\">'js/[name]-[chunkhash].js'</span>,</div><div class=\"line\">        <span class=\"attr\">publicPath</span>: <span class=\"string\">'http://cdn.com'</span> <span class=\"comment\">//编译的文件域名</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">plugins</span>:[</div><div class=\"line\">        <span class=\"comment\">//https://www.npmjs.com/package/html-webpack-plugin</span></div><div class=\"line\">        <span class=\"keyword\">new</span> htmlWebpackPlugin(&#123;</div><div class=\"line\">            <span class=\"attr\">filename</span>:<span class=\"string\">'index.html'</span>,</div><div class=\"line\">            <span class=\"attr\">template</span>: <span class=\"string\">'index.html'</span>,</div><div class=\"line\">            <span class=\"attr\">inject</span>:<span class=\"string\">'body'</span>, <span class=\"comment\">//script标签放的位置</span></div><div class=\"line\">            title:<span class=\"string\">'webpack is index'</span>,</div><div class=\"line\">            <span class=\"attr\">minify</span>: &#123;</div><div class=\"line\">                <span class=\"attr\">removeComments</span>:<span class=\"literal\">true</span>,<span class=\"comment\">//删除注释</span></div><div class=\"line\">                collapseWhitespace:<span class=\"literal\">true</span></div><div class=\"line\">            &#125;,</div><div class=\"line\">            <span class=\"comment\">// chunks: ['main','a'] //指定当前html包含的chunk</span></div><div class=\"line\">            excludeChunks:[<span class=\"string\">'a'</span>]<span class=\"comment\">//指定排除的chunk</span></div><div class=\"line\">        &#125;),</div><div class=\"line\">        <span class=\"keyword\">new</span> htmlWebpackPlugin(&#123;</div><div class=\"line\">            <span class=\"attr\">filename</span>:<span class=\"string\">'a.html'</span>,</div><div class=\"line\">            <span class=\"attr\">template</span>: <span class=\"string\">'index.html'</span>,</div><div class=\"line\">            <span class=\"attr\">inject</span>:<span class=\"string\">'body'</span>, <span class=\"comment\">//script标签放的位置</span></div><div class=\"line\">            title:<span class=\"string\">'webpack is a'</span>,</div><div class=\"line\">            <span class=\"attr\">minify</span>: &#123;</div><div class=\"line\">                <span class=\"attr\">removeComments</span>:<span class=\"literal\">true</span>,<span class=\"comment\">//删除注释</span></div><div class=\"line\">                collapseWhitespace:<span class=\"literal\">true</span></div><div class=\"line\">            &#125;,</div><div class=\"line\">            <span class=\"comment\">// chunks: ['a'] //指定当前html包含的chunk</span></div><div class=\"line\">            excludeChunks:[<span class=\"string\">'main'</span>]<span class=\"comment\">//指定排除的chunk</span></div><div class=\"line\">        &#125;),</div><div class=\"line\">    ]</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>","excerpt":"<p>webpack学习笔记<br>","more":"</p>\n<h2 id=\"配置：\">配置：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> htmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"comment\">//入口文件</span></div><div class=\"line\">    <span class=\"comment\">// entry: './src/script/main.js',</span></div><div class=\"line\">    <span class=\"comment\">// entry:[\"./src/script/main.js\",\"./src/script/a.js\"],//把2个文件打包在一起</span></div><div class=\"line\">    entry:&#123;</div><div class=\"line\">        <span class=\"attr\">main</span>:<span class=\"string\">'./src/script/main.js'</span>,</div><div class=\"line\">        <span class=\"attr\">a</span>:<span class=\"string\">\"./src/script/a.js\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">//输出</span></div><div class=\"line\">    output: &#123;</div><div class=\"line\">        <span class=\"attr\">path</span>: path.resolve(__dirname, <span class=\"string\">'./dist'</span>),</div><div class=\"line\">        <span class=\"attr\">filename</span>: <span class=\"string\">'js/[name]-[chunkhash].js'</span>,</div><div class=\"line\">        <span class=\"attr\">publicPath</span>: <span class=\"string\">'http://cdn.com'</span> <span class=\"comment\">//编译的文件域名</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">plugins</span>:[</div><div class=\"line\">        <span class=\"comment\">//https://www.npmjs.com/package/html-webpack-plugin</span></div><div class=\"line\">        <span class=\"keyword\">new</span> htmlWebpackPlugin(&#123;</div><div class=\"line\">            <span class=\"attr\">filename</span>:<span class=\"string\">'index.html'</span>,</div><div class=\"line\">            <span class=\"attr\">template</span>: <span class=\"string\">'index.html'</span>,</div><div class=\"line\">            <span class=\"attr\">inject</span>:<span class=\"string\">'body'</span>, <span class=\"comment\">//script标签放的位置</span></div><div class=\"line\">            title:<span class=\"string\">'webpack is index'</span>,</div><div class=\"line\">            <span class=\"attr\">minify</span>: &#123;</div><div class=\"line\">                <span class=\"attr\">removeComments</span>:<span class=\"literal\">true</span>,<span class=\"comment\">//删除注释</span></div><div class=\"line\">                collapseWhitespace:<span class=\"literal\">true</span></div><div class=\"line\">            &#125;,</div><div class=\"line\">            <span class=\"comment\">// chunks: ['main','a'] //指定当前html包含的chunk</span></div><div class=\"line\">            excludeChunks:[<span class=\"string\">'a'</span>]<span class=\"comment\">//指定排除的chunk</span></div><div class=\"line\">        &#125;),</div><div class=\"line\">        <span class=\"keyword\">new</span> htmlWebpackPlugin(&#123;</div><div class=\"line\">            <span class=\"attr\">filename</span>:<span class=\"string\">'a.html'</span>,</div><div class=\"line\">            <span class=\"attr\">template</span>: <span class=\"string\">'index.html'</span>,</div><div class=\"line\">            <span class=\"attr\">inject</span>:<span class=\"string\">'body'</span>, <span class=\"comment\">//script标签放的位置</span></div><div class=\"line\">            title:<span class=\"string\">'webpack is a'</span>,</div><div class=\"line\">            <span class=\"attr\">minify</span>: &#123;</div><div class=\"line\">                <span class=\"attr\">removeComments</span>:<span class=\"literal\">true</span>,<span class=\"comment\">//删除注释</span></div><div class=\"line\">                collapseWhitespace:<span class=\"literal\">true</span></div><div class=\"line\">            &#125;,</div><div class=\"line\">            <span class=\"comment\">// chunks: ['a'] //指定当前html包含的chunk</span></div><div class=\"line\">            excludeChunks:[<span class=\"string\">'main'</span>]<span class=\"comment\">//指定排除的chunk</span></div><div class=\"line\">        &#125;),</div><div class=\"line\">    ]</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"《ECMAScript 6 入门》读书笔记","_content":"### let与const\n#### let\n* 块级作用域\n* 不存在变量提升\n* 暂时性死区\n* 不允许重复声明\n\n#### const\n* const声明一个只读的常量。一旦声明，常量的值就不能改变。\n* const一旦声明变量，就必须立即初始化，不能留到以后赋值。\n* 暂时性死区\n* 不允许重复声明\n* 将一个对象声明为常量必须非常小心，只是保持了指向的地址不变，不保证指向的数据不变。\n\n### 变量的解构赋值\n__用处__:\n\n1. 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。\n`let { log, sin, cos } = Math;`\n2. 交换变量的值。`[x,y] = [y,x]`\n3. 从函数返回多个值。函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。\n4. 函数参数的定义，解构赋值可以方便地将一组参数与变量名对应起来。\n```javascript\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n```\n5. 提取JSON数据。解构赋值对提取JSON对象中的数据，尤其有用。\n```javascript\nvar jsonData = {\n    id: 42,\n    status: \"OK\",\n    data: [867, 5309]\n};\nlet { id, status, data: number } = jsonData;\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n6. 输入模块的指定方法,加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。\n```javascript\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n### 字符串扩展\n传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。\n- includes()：返回布尔值，表示是否找到了参数字符串。\n- startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。\n- endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。\n\n这三个方法都支持第二个参数，表示开始搜索的位置。\n```\nvar s = 'Hello world!';\ns.startsWith('world', 6) // true\ns.endsWith('Hello', 5) // true\ns.includes('Hello', 6) // false\n```\n上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。\n\n### 数值的拓展\n`Number.isFinite()`用来检查一个数值是否为有限的（finite）。\n`Number.isNaN()`用来检查一个值是否为NaN。\n它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。\n```javascript\nisFinite(25) // true\nisFinite(\"25\") // true\nNumber.isFinite(25) // true\nNumber.isFinite(\"25\") // false\nisNaN(NaN) // true\nisNaN(\"NaN\") // true\nNumber.isNaN(NaN) // true\nNumber.isNaN(\"NaN\") // false\n```\n### 数组的拓展\n`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。\n```javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\nArray.from('hello');// ['h', 'e', 'l', 'l', 'o'];\nArray.from({ length: 3 });// [ undefined, undefined, undefined ]\n```\nArray.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n```javascript\nArray.from(arrayLike, x => x * x);\n// 等同于\nArray.from(arrayLike).map(x => x * x);\nArray.from([1, 2, 3], (x) => x * x)// [1, 4, 9]\n```\n`Array.of`总是返回参数值组成的数组。如果没有参数，就返回一个空数组。`Array.of`基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。\n```javascript\nArray.of() // []\nArray.of(undefined) // [undefined]\nArray.of(1) // [1]\nArray.of(1, 2) // [1, 2]\n```\n### 对象的拓展\n__属性的简洁表示法__\nES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n```\nvar foo = 'bar';\nvar baz = {foo};\nbaz // {foo: \"bar\"}\n// 等同于\nvar baz = {foo: foo};\nfunction f(x, y) {\n  return {x, y};\n}\n// 等同于\nfunction f(x, y) {\n  return {x: x, y: y};\n}\nf(1, 2) // Object {x: 1, y: 2}\n```\n__Object.keys()__\nES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.keys(obj);// [\"foo\", \"baz\"]\n```\n__Object.values()__\nObject.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.values(obj)// [\"bar\", 42]\n```\n__Object.entries__\n`Object.entries`方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.entries(obj)// [ [\"foo\", \"bar\"], [\"baz\", 42] ]\n```\n### symbol\nES6引入了一种新的原始数据类型Symbol，__表示独一无二的值__。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\n[详见文档](http://es6.ruanyifeng.com/#docs/symbol)\n\n### set\nES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\nSet本身是一个构造函数，用来生成Set数据结构。\n```javascript\nvar s = new Set();\n[2, 3, 5, 4, 5, 2, 2].map(x => s.add(x));\nfor (let i of s) {\n  console.log(i);// 2 3 5 4\n}\n```\n所以set可用来去除数组重复成员\n```javascript\n// 去除数组的重复成员\n[...new Set(array)]\n[...new Set([2,2,2,2,2,3])] //2,3\n```\nSet结构的实例有以下属性。\n- `Set.prototype.constructor`：构造函数，默认就是Set函数。\n- `Set.prototype.size`：返回Set实例的成员总数。\n\nSet实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n- `add(value)`：添加某个值，返回Set结构本身。\n- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。\n- `has(value)`：返回一个布尔值，表示该值是否为Set的成员。\n- `clear()`：清除所有成员，没有返回值。\n\n遍历方法：\n- `keys()`：返回键名的遍历器\n- `values()`：返回键值的遍历器\n- `entries()`：返回键值对的遍历器\n- `forEach()`：使用回调函数遍历每个成员\n\n### map\nJavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。\n\n```javascript\nvar map = new Map([\n  ['name', '张三'],\n  ['title', 'Author']\n]);\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // \"张三\"\nmap.has('title') // true\nmap.get('title') // \"Author\"\n```\n实例的属性和操作方法:\n- `size`属性返回Map结构的成员总数。\n- `set(key, value)`方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是Map本身，因此可以采用链式写法。\n- `get(key)`方法读取key对应的键值，如果找不到key，返回undefined。\n- `has(key)`方法返回一个布尔值，表示某个键是否在Map数据结构中。\n- `delete(key)`方法删除某个键，返回true。如果删除失败，返回false。\n- `clear()`方法清除所有成员，没有返回值。\n\n遍历方法\n- `keys()`：返回键名的遍历器。\n- `values()`：返回键值的遍历器。\n- `entries()`：返回所有成员的遍历器。\n- `forEach()`：遍历Map的所有成员。\n\n### proxy\n[proxy](http://es6.ruanyifeng.com/#docs/proxy)，文档再此，后续总结\n### reflect\n[reflect](http://es6.ruanyifeng.com/#docs/reflect)，文档再此，后续总结\n\n### Iterator和for...of循环\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\nIterator的遍历过程是这样的。\n1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n2. 第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员。\n3. 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员。\n4. 不断调用指针对象的`next`方法，直到它指向数据结构的结束位置。\n\n下面是一个模拟next方法返回值的例子。\n```javascript\nvar it = makeIterator(['a', 'b']);\nit.next() // { value: \"a\", done: false }\nit.next() // { value: \"b\", done: false }\nit.next() // { value: undefined, done: true }\nfunction makeIterator(array) {\n  var nextIndex = 0;\n  return {\n    next: function() {\n      return nextIndex < array.length ?\n        {value: array[nextIndex++], done: false} :\n        {value: undefined, done: true};\n    }\n  };\n}\n```\n每一次调用`next`方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n\n\n凡是部署了`Symbol.iterator`属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。\n当使用`for...of`循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。\n在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。\n有一些场合会默认调用Iterator接口（即Symbol.iterator方法）：\n1. 解构赋值\n```javascript\nlet set = new Set().add('a').add('b').add('c');\nlet [x,y] = set;// x='a'; y='b'\nlet [first, ...rest] = set;// first='a'; rest=['b','c'];\n```\n2. 扩展运算符\n```javascript\n// 例一\nvar str = 'hello';\n[...str] //  ['h','e','l','l','o']\n// 例二\nlet arr = ['b', 'c'];\n['a', ...arr, 'd']\n```\n3. yield\\*\nyield\\*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\n```javascript\nlet generator = function* () {\n  yield 1;\n  yield* [2,3,4];\n  yield 5;\n};\nvar iterator = generator();\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: 3, done: false }\niterator.next() // { value: 4, done: false }\niterator.next() // { value: 5, done: false }\niterator.next() // { value: undefined, done: true }\n```\n4. 其他场合\n由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。\n- `for...of`\n- `Array.from()`\n- `Map()`, `Set()`, `WeakMap()`, `WeakSet()`（比如new Map([['a',1],['b',2]])）\n- `Promise.all()`\n- `Promise.race()`\n\n```\nvar arr = ['a', 'b', 'c', 'd'];\nfor (let a in arr) {\n  console.log(a); // 0 1 2 3\n}\nfor (let a of arr) {\n  console.log(a); // a b c d\n}\n```\n上面代码表明，`for...in`循环读取键名，`for...of`循环读取键值。如果要通过`for...of`循环，获取数组的索引，可以借助数组实例的entries方法和keys方法，参见《数组的扩展》章节。\n`for...of`循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟`for...in`循环也不一样。\n\n### Generator 函数\n#### 简介\nGenerator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍Generator函数的语法和API，它的异步编程应用请看《异步操作》一章。语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。形式上，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。\n\nGenerator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。\n下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。\n#### yield语句\n由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。\n`yield`语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\nyield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。\n\n`for...of`循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法。\n```\nfunction *foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n```\n...待补充","source":"_posts/reading-notes-Of-ECMAScript6.md","raw":"title: 《ECMAScript 6 入门》读书笔记\ntags: 读书笔记\n---\n### let与const\n#### let\n* 块级作用域\n* 不存在变量提升\n* 暂时性死区\n* 不允许重复声明\n\n#### const\n* const声明一个只读的常量。一旦声明，常量的值就不能改变。\n* const一旦声明变量，就必须立即初始化，不能留到以后赋值。\n* 暂时性死区\n* 不允许重复声明\n* 将一个对象声明为常量必须非常小心，只是保持了指向的地址不变，不保证指向的数据不变。\n\n### 变量的解构赋值\n__用处__:\n\n1. 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。\n`let { log, sin, cos } = Math;`\n2. 交换变量的值。`[x,y] = [y,x]`\n3. 从函数返回多个值。函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。\n4. 函数参数的定义，解构赋值可以方便地将一组参数与变量名对应起来。\n```javascript\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n```\n5. 提取JSON数据。解构赋值对提取JSON对象中的数据，尤其有用。\n```javascript\nvar jsonData = {\n    id: 42,\n    status: \"OK\",\n    data: [867, 5309]\n};\nlet { id, status, data: number } = jsonData;\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n6. 输入模块的指定方法,加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。\n```javascript\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n### 字符串扩展\n传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。\n- includes()：返回布尔值，表示是否找到了参数字符串。\n- startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。\n- endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。\n\n这三个方法都支持第二个参数，表示开始搜索的位置。\n```\nvar s = 'Hello world!';\ns.startsWith('world', 6) // true\ns.endsWith('Hello', 5) // true\ns.includes('Hello', 6) // false\n```\n上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。\n\n### 数值的拓展\n`Number.isFinite()`用来检查一个数值是否为有限的（finite）。\n`Number.isNaN()`用来检查一个值是否为NaN。\n它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。\n```javascript\nisFinite(25) // true\nisFinite(\"25\") // true\nNumber.isFinite(25) // true\nNumber.isFinite(\"25\") // false\nisNaN(NaN) // true\nisNaN(\"NaN\") // true\nNumber.isNaN(NaN) // true\nNumber.isNaN(\"NaN\") // false\n```\n### 数组的拓展\n`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。\n```javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\nArray.from('hello');// ['h', 'e', 'l', 'l', 'o'];\nArray.from({ length: 3 });// [ undefined, undefined, undefined ]\n```\nArray.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n```javascript\nArray.from(arrayLike, x => x * x);\n// 等同于\nArray.from(arrayLike).map(x => x * x);\nArray.from([1, 2, 3], (x) => x * x)// [1, 4, 9]\n```\n`Array.of`总是返回参数值组成的数组。如果没有参数，就返回一个空数组。`Array.of`基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。\n```javascript\nArray.of() // []\nArray.of(undefined) // [undefined]\nArray.of(1) // [1]\nArray.of(1, 2) // [1, 2]\n```\n### 对象的拓展\n__属性的简洁表示法__\nES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n```\nvar foo = 'bar';\nvar baz = {foo};\nbaz // {foo: \"bar\"}\n// 等同于\nvar baz = {foo: foo};\nfunction f(x, y) {\n  return {x, y};\n}\n// 等同于\nfunction f(x, y) {\n  return {x: x, y: y};\n}\nf(1, 2) // Object {x: 1, y: 2}\n```\n__Object.keys()__\nES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.keys(obj);// [\"foo\", \"baz\"]\n```\n__Object.values()__\nObject.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.values(obj)// [\"bar\", 42]\n```\n__Object.entries__\n`Object.entries`方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.entries(obj)// [ [\"foo\", \"bar\"], [\"baz\", 42] ]\n```\n### symbol\nES6引入了一种新的原始数据类型Symbol，__表示独一无二的值__。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\n[详见文档](http://es6.ruanyifeng.com/#docs/symbol)\n\n### set\nES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\nSet本身是一个构造函数，用来生成Set数据结构。\n```javascript\nvar s = new Set();\n[2, 3, 5, 4, 5, 2, 2].map(x => s.add(x));\nfor (let i of s) {\n  console.log(i);// 2 3 5 4\n}\n```\n所以set可用来去除数组重复成员\n```javascript\n// 去除数组的重复成员\n[...new Set(array)]\n[...new Set([2,2,2,2,2,3])] //2,3\n```\nSet结构的实例有以下属性。\n- `Set.prototype.constructor`：构造函数，默认就是Set函数。\n- `Set.prototype.size`：返回Set实例的成员总数。\n\nSet实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n- `add(value)`：添加某个值，返回Set结构本身。\n- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。\n- `has(value)`：返回一个布尔值，表示该值是否为Set的成员。\n- `clear()`：清除所有成员，没有返回值。\n\n遍历方法：\n- `keys()`：返回键名的遍历器\n- `values()`：返回键值的遍历器\n- `entries()`：返回键值对的遍历器\n- `forEach()`：使用回调函数遍历每个成员\n\n### map\nJavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。\n\n```javascript\nvar map = new Map([\n  ['name', '张三'],\n  ['title', 'Author']\n]);\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // \"张三\"\nmap.has('title') // true\nmap.get('title') // \"Author\"\n```\n实例的属性和操作方法:\n- `size`属性返回Map结构的成员总数。\n- `set(key, value)`方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是Map本身，因此可以采用链式写法。\n- `get(key)`方法读取key对应的键值，如果找不到key，返回undefined。\n- `has(key)`方法返回一个布尔值，表示某个键是否在Map数据结构中。\n- `delete(key)`方法删除某个键，返回true。如果删除失败，返回false。\n- `clear()`方法清除所有成员，没有返回值。\n\n遍历方法\n- `keys()`：返回键名的遍历器。\n- `values()`：返回键值的遍历器。\n- `entries()`：返回所有成员的遍历器。\n- `forEach()`：遍历Map的所有成员。\n\n### proxy\n[proxy](http://es6.ruanyifeng.com/#docs/proxy)，文档再此，后续总结\n### reflect\n[reflect](http://es6.ruanyifeng.com/#docs/reflect)，文档再此，后续总结\n\n### Iterator和for...of循环\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\nIterator的遍历过程是这样的。\n1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n2. 第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员。\n3. 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员。\n4. 不断调用指针对象的`next`方法，直到它指向数据结构的结束位置。\n\n下面是一个模拟next方法返回值的例子。\n```javascript\nvar it = makeIterator(['a', 'b']);\nit.next() // { value: \"a\", done: false }\nit.next() // { value: \"b\", done: false }\nit.next() // { value: undefined, done: true }\nfunction makeIterator(array) {\n  var nextIndex = 0;\n  return {\n    next: function() {\n      return nextIndex < array.length ?\n        {value: array[nextIndex++], done: false} :\n        {value: undefined, done: true};\n    }\n  };\n}\n```\n每一次调用`next`方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n\n\n凡是部署了`Symbol.iterator`属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。\n当使用`for...of`循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。\n在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。\n有一些场合会默认调用Iterator接口（即Symbol.iterator方法）：\n1. 解构赋值\n```javascript\nlet set = new Set().add('a').add('b').add('c');\nlet [x,y] = set;// x='a'; y='b'\nlet [first, ...rest] = set;// first='a'; rest=['b','c'];\n```\n2. 扩展运算符\n```javascript\n// 例一\nvar str = 'hello';\n[...str] //  ['h','e','l','l','o']\n// 例二\nlet arr = ['b', 'c'];\n['a', ...arr, 'd']\n```\n3. yield\\*\nyield\\*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\n```javascript\nlet generator = function* () {\n  yield 1;\n  yield* [2,3,4];\n  yield 5;\n};\nvar iterator = generator();\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: 3, done: false }\niterator.next() // { value: 4, done: false }\niterator.next() // { value: 5, done: false }\niterator.next() // { value: undefined, done: true }\n```\n4. 其他场合\n由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。\n- `for...of`\n- `Array.from()`\n- `Map()`, `Set()`, `WeakMap()`, `WeakSet()`（比如new Map([['a',1],['b',2]])）\n- `Promise.all()`\n- `Promise.race()`\n\n```\nvar arr = ['a', 'b', 'c', 'd'];\nfor (let a in arr) {\n  console.log(a); // 0 1 2 3\n}\nfor (let a of arr) {\n  console.log(a); // a b c d\n}\n```\n上面代码表明，`for...in`循环读取键名，`for...of`循环读取键值。如果要通过`for...of`循环，获取数组的索引，可以借助数组实例的entries方法和keys方法，参见《数组的扩展》章节。\n`for...of`循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟`for...in`循环也不一样。\n\n### Generator 函数\n#### 简介\nGenerator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍Generator函数的语法和API，它的异步编程应用请看《异步操作》一章。语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。形式上，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。\n\nGenerator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。\n下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。\n#### yield语句\n由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。\n`yield`语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\nyield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。\n\n`for...of`循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法。\n```\nfunction *foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n```\n...待补充","slug":"reading-notes-Of-ECMAScript6","published":1,"date":"2017-01-11T08:19:38.000Z","updated":"2017-01-16T03:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ey5001fer2zbpyz1yqx","content":"<h3 id=\"let与const\">let与const</h3><h4 id=\"let\">let</h4><ul>\n<li>块级作用域</li>\n<li>不存在变量提升</li>\n<li>暂时性死区</li>\n<li>不允许重复声明</li>\n</ul>\n<h4 id=\"const\">const</h4><ul>\n<li>const声明一个只读的常量。一旦声明，常量的值就不能改变。</li>\n<li>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>\n<li>暂时性死区</li>\n<li>不允许重复声明</li>\n<li>将一个对象声明为常量必须非常小心，只是保持了指向的地址不变，不保证指向的数据不变。</li>\n</ul>\n<h3 id=\"变量的解构赋值\">变量的解构赋值</h3><p><strong>用处</strong>:</p>\n<ol>\n<li>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。<br><code>let { log, sin, cos } = Math;</code></li>\n<li>交换变量的值。<code>[x,y] = [y,x]</code></li>\n<li>从函数返回多个值。函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</li>\n<li><p>函数参数的定义，解构赋值可以方便地将一组参数与变量名对应起来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 参数是一组有次序的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class=\"line\">f([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\"><span class=\"comment\">// 参数是一组无次序的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class=\"line\">f(&#123;<span class=\"attr\">z</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>提取JSON数据。解构赋值对提取JSON对象中的数据，尤其有用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> jsonData = &#123;</div><div class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">42</span>,</div><div class=\"line\">    <span class=\"attr\">status</span>: <span class=\"string\">\"OK\"</span>,</div><div class=\"line\">    <span class=\"attr\">data</span>: [<span class=\"number\">867</span>, <span class=\"number\">5309</span>]</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123; id, status, <span class=\"attr\">data</span>: number &#125; = jsonData;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(id, status, number);</div><div class=\"line\"><span class=\"comment\">// 42, \"OK\", [867, 5309]</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>输入模块的指定方法,加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">\"source-map\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"字符串扩展\">字符串扩展</h3><p>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>\n<ul>\n<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>\n<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>\n<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>\n</ul>\n<p>这三个方法都支持第二个参数，表示开始搜索的位置。<br><figure class=\"highlight mel\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var s = <span class=\"string\">'Hello world!'</span>;</div><div class=\"line\">s.<span class=\"keyword\">startsWith</span>(<span class=\"string\">'world'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.<span class=\"keyword\">endsWith</span>(<span class=\"string\">'Hello'</span>, <span class=\"number\">5</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.includes(<span class=\"string\">'Hello'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p>\n<h3 id=\"数值的拓展\">数值的拓展</h3><p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite）。<br><code>Number.isNaN()</code>用来检查一个值是否为NaN。<br>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"string\">\"25\"</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">\"25\"</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"NaN\"</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"NaN\"</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"数组的拓展\">数组的拓展</h3><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</div><div class=\"line\">    <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</div><div class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</div><div class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</div><div class=\"line\">    <span class=\"attr\">length</span>: <span class=\"number\">3</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"string\">'hello'</span>);<span class=\"comment\">// ['h', 'e', 'l', 'l', 'o'];</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.from(&#123; <span class=\"attr\">length</span>: <span class=\"number\">3</span> &#125;);<span class=\"comment\">// [ undefined, undefined, undefined ]</span></div></pre></td></tr></table></figure></p>\n<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike, x =&gt; x * x);</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike).map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x);</div><div class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], (x) =&gt; x * x)<span class=\"comment\">// [1, 4, 9]</span></div></pre></td></tr></table></figure></p>\n<p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。<code>Array.of</code>基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.of() <span class=\"comment\">// []</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"literal\">undefined</span>) <span class=\"comment\">// [undefined]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>) <span class=\"comment\">// [1]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// [1, 2]</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"对象的拓展\">对象的拓展</h3><p><strong>属性的简洁表示法</strong><br>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> baz = &#123;foo&#125;;</div><div class=\"line\">baz <span class=\"comment\">// &#123;foo: \"bar\"&#125;</span></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"keyword\">var</span> baz = &#123;<span class=\"attr\">foo</span>: foo&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;x, y&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// Object &#123;x: 1, y: 2&#125;</span></div></pre></td></tr></table></figure></p>\n<p><strong>Object.keys()</strong><br>ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">baz</span>: <span class=\"number\">42</span> &#125;;</div><div class=\"line\"><span class=\"built_in\">Object</span>.keys(obj);<span class=\"comment\">// [\"foo\", \"baz\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong>Object.values()</strong><br>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">baz</span>: <span class=\"number\">42</span> &#125;;</div><div class=\"line\"><span class=\"built_in\">Object</span>.values(obj)<span class=\"comment\">// [\"bar\", 42]</span></div></pre></td></tr></table></figure></p>\n<p><strong>Object.entries</strong><br><code>Object.entries</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">baz</span>: <span class=\"number\">42</span> &#125;;</div><div class=\"line\"><span class=\"built_in\">Object</span>.entries(obj)<span class=\"comment\">// [ [\"foo\", \"bar\"], [\"baz\", 42] ]</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"symbol\">symbol</h3><p>ES6引入了一种新的原始数据类型Symbol，<strong>表示独一无二的值</strong>。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。<br><a href=\"http://es6.ruanyifeng.com/#docs/symbol\" target=\"_blank\" rel=\"external\">详见文档</a></p>\n<h3 id=\"set\">set</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set本身是一个构造函数，用来生成Set数据结构。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> s.add(x));</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(i);<span class=\"comment\">// 2 3 5 4</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以set可用来去除数组重复成员<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 去除数组的重复成员</span></div><div class=\"line\">[...new <span class=\"built_in\">Set</span>(array)]</div><div class=\"line\">[...new <span class=\"built_in\">Set</span>([<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])] <span class=\"comment\">//2,3</span></div></pre></td></tr></table></figure></p>\n<p>Set结构的实例有以下属性。</p>\n<ul>\n<li><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。</li>\n<li><code>Set.prototype.size</code>：返回Set实例的成员总数。</li>\n</ul>\n<p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>\n<ul>\n<li><code>add(value)</code>：添加某个值，返回Set结构本身。</li>\n<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>\n<li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li>\n<li><code>clear()</code>：清除所有成员，没有返回值。</li>\n</ul>\n<p>遍历方法：</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器</li>\n<li><code>values()</code>：返回键值的遍历器</li>\n<li><code>entries()</code>：返回键值对的遍历器</li>\n<li><code>forEach()</code>：使用回调函数遍历每个成员</li>\n</ul>\n<h3 id=\"map\">map</h3><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"string\">'name'</span>, <span class=\"string\">'张三'</span>],</div><div class=\"line\">  [<span class=\"string\">'title'</span>, <span class=\"string\">'Author'</span>]</div><div class=\"line\">]);</div><div class=\"line\">map.size <span class=\"comment\">// 2</span></div><div class=\"line\">map.has(<span class=\"string\">'name'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">map.get(<span class=\"string\">'name'</span>) <span class=\"comment\">// \"张三\"</span></div><div class=\"line\">map.has(<span class=\"string\">'title'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">map.get(<span class=\"string\">'title'</span>) <span class=\"comment\">// \"Author\"</span></div></pre></td></tr></table></figure>\n<p>实例的属性和操作方法:</p>\n<ul>\n<li><code>size</code>属性返回Map结构的成员总数。</li>\n<li><code>set(key, value)</code>方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是Map本身，因此可以采用链式写法。</li>\n<li><code>get(key)</code>方法读取key对应的键值，如果找不到key，返回undefined。</li>\n<li><code>has(key)</code>方法返回一个布尔值，表示某个键是否在Map数据结构中。</li>\n<li><code>delete(key)</code>方法删除某个键，返回true。如果删除失败，返回false。</li>\n<li><code>clear()</code>方法清除所有成员，没有返回值。</li>\n</ul>\n<p>遍历方法</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器。</li>\n<li><code>values()</code>：返回键值的遍历器。</li>\n<li><code>entries()</code>：返回所有成员的遍历器。</li>\n<li><code>forEach()</code>：遍历Map的所有成员。</li>\n</ul>\n<h3 id=\"proxy\">proxy</h3><p><a href=\"http://es6.ruanyifeng.com/#docs/proxy\" target=\"_blank\" rel=\"external\">proxy</a>，文档再此，后续总结</p>\n<h3 id=\"reflect\">reflect</h3><p><a href=\"http://es6.ruanyifeng.com/#docs/reflect\" target=\"_blank\" rel=\"external\">reflect</a>，文档再此，后续总结</p>\n<h3 id=\"Iterator和for…of循环\">Iterator和for…of循环</h3><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。<br>Iterator的遍历过程是这样的。</p>\n<ol>\n<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>\n<li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</li>\n<li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</li>\n<li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</li>\n</ol>\n<p>下面是一个模拟next方法返回值的例子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> it = makeIterator([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);</div><div class=\"line\">it.next() <span class=\"comment\">// &#123; value: \"a\", done: false &#125;</span></div><div class=\"line\">it.next() <span class=\"comment\">// &#123; value: \"b\", done: false &#125;</span></div><div class=\"line\">it.next() <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeIterator</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">next</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> nextIndex &lt; array.length ?</div><div class=\"line\">        &#123;<span class=\"attr\">value</span>: array[nextIndex++], <span class=\"attr\">done</span>: <span class=\"literal\">false</span>&#125; :</div><div class=\"line\">        &#123;<span class=\"attr\">value</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span>&#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p>\n<p>凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。<br>当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。<br>在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。<br>有一些场合会默认调用Iterator接口（即Symbol.iterator方法）：</p>\n<ol>\n<li><p>解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>().add(<span class=\"string\">'a'</span>).add(<span class=\"string\">'b'</span>).add(<span class=\"string\">'c'</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> [x,y] = set;<span class=\"comment\">// x='a'; y='b'</span></div><div class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = set;<span class=\"comment\">// first='a'; rest=['b','c'];</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>扩展运算符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 例一</span></div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'hello'</span>;</div><div class=\"line\">[...str] <span class=\"comment\">//  ['h','e','l','l','o']</span></div><div class=\"line\"><span class=\"comment\">// 例二</span></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</div><div class=\"line\">[<span class=\"string\">'a'</span>, ...arr, <span class=\"string\">'d'</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p>yield*<br>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> generator = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">yield</span>* [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">5</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> iterator = generator();</div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: 2, done: false &#125;</span></div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: 3, done: false &#125;</span></div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: 4, done: false &#125;</span></div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: 5, done: false &#125;</span></div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>其他场合<br>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>\n</li>\n</ol>\n<ul>\n<li><code>for...of</code></li>\n<li><code>Array.from()</code></li>\n<li><code>Map()</code>, <code>Set()</code>, <code>WeakMap()</code>, <code>WeakSet()</code>（比如new Map([[‘a’,1],[‘b’,2]])）</li>\n<li><code>Promise.all()</code></li>\n<li><code>Promise.race()</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> a <span class=\"keyword\">in</span> arr) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 0 1 2 3</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> a <span class=\"keyword\">of</span> arr) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// a b c d</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的entries方法和keys方法，参见《数组的扩展》章节。<br><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p>\n<h3 id=\"Generator_函数\">Generator 函数</h3><h4 id=\"简介\">简介</h4><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍Generator函数的语法和API，它的异步编程应用请看《异步操作》一章。语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。形式上，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。</p>\n<p>Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。<br>下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。</p>\n<h4 id=\"yield语句\">yield语句</h4><p>由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。<br><code>yield</code>语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br>yield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。</p>\n<p><code>for...of</code>循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">4</span>;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">5</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">6</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v <span class=\"keyword\">of</span> foo()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(v);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 1 2 3 4 5</span></div></pre></td></tr></table></figure></p>\n<p>…待补充</p>\n","excerpt":"","more":"<h3 id=\"let与const\">let与const</h3><h4 id=\"let\">let</h4><ul>\n<li>块级作用域</li>\n<li>不存在变量提升</li>\n<li>暂时性死区</li>\n<li>不允许重复声明</li>\n</ul>\n<h4 id=\"const\">const</h4><ul>\n<li>const声明一个只读的常量。一旦声明，常量的值就不能改变。</li>\n<li>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>\n<li>暂时性死区</li>\n<li>不允许重复声明</li>\n<li>将一个对象声明为常量必须非常小心，只是保持了指向的地址不变，不保证指向的数据不变。</li>\n</ul>\n<h3 id=\"变量的解构赋值\">变量的解构赋值</h3><p><strong>用处</strong>:</p>\n<ol>\n<li>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。<br><code>let { log, sin, cos } = Math;</code></li>\n<li>交换变量的值。<code>[x,y] = [y,x]</code></li>\n<li>从函数返回多个值。函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</li>\n<li><p>函数参数的定义，解构赋值可以方便地将一组参数与变量名对应起来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 参数是一组有次序的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class=\"line\">f([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\"><span class=\"comment\">// 参数是一组无次序的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class=\"line\">f(&#123;<span class=\"attr\">z</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>提取JSON数据。解构赋值对提取JSON对象中的数据，尤其有用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> jsonData = &#123;</div><div class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">42</span>,</div><div class=\"line\">    <span class=\"attr\">status</span>: <span class=\"string\">\"OK\"</span>,</div><div class=\"line\">    <span class=\"attr\">data</span>: [<span class=\"number\">867</span>, <span class=\"number\">5309</span>]</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123; id, status, <span class=\"attr\">data</span>: number &#125; = jsonData;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(id, status, number);</div><div class=\"line\"><span class=\"comment\">// 42, \"OK\", [867, 5309]</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>输入模块的指定方法,加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">\"source-map\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"字符串扩展\">字符串扩展</h3><p>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>\n<ul>\n<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>\n<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>\n<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>\n</ul>\n<p>这三个方法都支持第二个参数，表示开始搜索的位置。<br><figure class=\"highlight mel\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var s = <span class=\"string\">'Hello world!'</span>;</div><div class=\"line\">s.<span class=\"keyword\">startsWith</span>(<span class=\"string\">'world'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.<span class=\"keyword\">endsWith</span>(<span class=\"string\">'Hello'</span>, <span class=\"number\">5</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.includes(<span class=\"string\">'Hello'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p>\n<h3 id=\"数值的拓展\">数值的拓展</h3><p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite）。<br><code>Number.isNaN()</code>用来检查一个值是否为NaN。<br>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"string\">\"25\"</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">\"25\"</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"NaN\"</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"NaN\"</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"数组的拓展\">数组的拓展</h3><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</div><div class=\"line\">    <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</div><div class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</div><div class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</div><div class=\"line\">    <span class=\"attr\">length</span>: <span class=\"number\">3</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"string\">'hello'</span>);<span class=\"comment\">// ['h', 'e', 'l', 'l', 'o'];</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.from(&#123; <span class=\"attr\">length</span>: <span class=\"number\">3</span> &#125;);<span class=\"comment\">// [ undefined, undefined, undefined ]</span></div></pre></td></tr></table></figure></p>\n<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike, x =&gt; x * x);</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike).map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x);</div><div class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], (x) =&gt; x * x)<span class=\"comment\">// [1, 4, 9]</span></div></pre></td></tr></table></figure></p>\n<p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。<code>Array.of</code>基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.of() <span class=\"comment\">// []</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"literal\">undefined</span>) <span class=\"comment\">// [undefined]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>) <span class=\"comment\">// [1]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// [1, 2]</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"对象的拓展\">对象的拓展</h3><p><strong>属性的简洁表示法</strong><br>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> baz = &#123;foo&#125;;</div><div class=\"line\">baz <span class=\"comment\">// &#123;foo: \"bar\"&#125;</span></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"keyword\">var</span> baz = &#123;<span class=\"attr\">foo</span>: foo&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;x, y&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// Object &#123;x: 1, y: 2&#125;</span></div></pre></td></tr></table></figure></p>\n<p><strong>Object.keys()</strong><br>ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">baz</span>: <span class=\"number\">42</span> &#125;;</div><div class=\"line\"><span class=\"built_in\">Object</span>.keys(obj);<span class=\"comment\">// [\"foo\", \"baz\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong>Object.values()</strong><br>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">baz</span>: <span class=\"number\">42</span> &#125;;</div><div class=\"line\"><span class=\"built_in\">Object</span>.values(obj)<span class=\"comment\">// [\"bar\", 42]</span></div></pre></td></tr></table></figure></p>\n<p><strong>Object.entries</strong><br><code>Object.entries</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">baz</span>: <span class=\"number\">42</span> &#125;;</div><div class=\"line\"><span class=\"built_in\">Object</span>.entries(obj)<span class=\"comment\">// [ [\"foo\", \"bar\"], [\"baz\", 42] ]</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"symbol\">symbol</h3><p>ES6引入了一种新的原始数据类型Symbol，<strong>表示独一无二的值</strong>。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。<br><a href=\"http://es6.ruanyifeng.com/#docs/symbol\">详见文档</a></p>\n<h3 id=\"set\">set</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set本身是一个构造函数，用来生成Set数据结构。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> s.add(x));</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(i);<span class=\"comment\">// 2 3 5 4</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以set可用来去除数组重复成员<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 去除数组的重复成员</span></div><div class=\"line\">[...new <span class=\"built_in\">Set</span>(array)]</div><div class=\"line\">[...new <span class=\"built_in\">Set</span>([<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])] <span class=\"comment\">//2,3</span></div></pre></td></tr></table></figure></p>\n<p>Set结构的实例有以下属性。</p>\n<ul>\n<li><code>Set.prototype.constructor</code>：构造函数，默认就是Set函数。</li>\n<li><code>Set.prototype.size</code>：返回Set实例的成员总数。</li>\n</ul>\n<p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>\n<ul>\n<li><code>add(value)</code>：添加某个值，返回Set结构本身。</li>\n<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>\n<li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li>\n<li><code>clear()</code>：清除所有成员，没有返回值。</li>\n</ul>\n<p>遍历方法：</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器</li>\n<li><code>values()</code>：返回键值的遍历器</li>\n<li><code>entries()</code>：返回键值对的遍历器</li>\n<li><code>forEach()</code>：使用回调函数遍历每个成员</li>\n</ul>\n<h3 id=\"map\">map</h3><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"string\">'name'</span>, <span class=\"string\">'张三'</span>],</div><div class=\"line\">  [<span class=\"string\">'title'</span>, <span class=\"string\">'Author'</span>]</div><div class=\"line\">]);</div><div class=\"line\">map.size <span class=\"comment\">// 2</span></div><div class=\"line\">map.has(<span class=\"string\">'name'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">map.get(<span class=\"string\">'name'</span>) <span class=\"comment\">// \"张三\"</span></div><div class=\"line\">map.has(<span class=\"string\">'title'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">map.get(<span class=\"string\">'title'</span>) <span class=\"comment\">// \"Author\"</span></div></pre></td></tr></table></figure>\n<p>实例的属性和操作方法:</p>\n<ul>\n<li><code>size</code>属性返回Map结构的成员总数。</li>\n<li><code>set(key, value)</code>方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是Map本身，因此可以采用链式写法。</li>\n<li><code>get(key)</code>方法读取key对应的键值，如果找不到key，返回undefined。</li>\n<li><code>has(key)</code>方法返回一个布尔值，表示某个键是否在Map数据结构中。</li>\n<li><code>delete(key)</code>方法删除某个键，返回true。如果删除失败，返回false。</li>\n<li><code>clear()</code>方法清除所有成员，没有返回值。</li>\n</ul>\n<p>遍历方法</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器。</li>\n<li><code>values()</code>：返回键值的遍历器。</li>\n<li><code>entries()</code>：返回所有成员的遍历器。</li>\n<li><code>forEach()</code>：遍历Map的所有成员。</li>\n</ul>\n<h3 id=\"proxy\">proxy</h3><p><a href=\"http://es6.ruanyifeng.com/#docs/proxy\">proxy</a>，文档再此，后续总结</p>\n<h3 id=\"reflect\">reflect</h3><p><a href=\"http://es6.ruanyifeng.com/#docs/reflect\">reflect</a>，文档再此，后续总结</p>\n<h3 id=\"Iterator和for…of循环\">Iterator和for…of循环</h3><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。<br>Iterator的遍历过程是这样的。</p>\n<ol>\n<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>\n<li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</li>\n<li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</li>\n<li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</li>\n</ol>\n<p>下面是一个模拟next方法返回值的例子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> it = makeIterator([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);</div><div class=\"line\">it.next() <span class=\"comment\">// &#123; value: \"a\", done: false &#125;</span></div><div class=\"line\">it.next() <span class=\"comment\">// &#123; value: \"b\", done: false &#125;</span></div><div class=\"line\">it.next() <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeIterator</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">next</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> nextIndex &lt; array.length ?</div><div class=\"line\">        &#123;<span class=\"attr\">value</span>: array[nextIndex++], <span class=\"attr\">done</span>: <span class=\"literal\">false</span>&#125; :</div><div class=\"line\">        &#123;<span class=\"attr\">value</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span>&#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p>\n<p>凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。<br>当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。<br>在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。<br>有一些场合会默认调用Iterator接口（即Symbol.iterator方法）：</p>\n<ol>\n<li><p>解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>().add(<span class=\"string\">'a'</span>).add(<span class=\"string\">'b'</span>).add(<span class=\"string\">'c'</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> [x,y] = set;<span class=\"comment\">// x='a'; y='b'</span></div><div class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = set;<span class=\"comment\">// first='a'; rest=['b','c'];</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>扩展运算符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 例一</span></div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'hello'</span>;</div><div class=\"line\">[...str] <span class=\"comment\">//  ['h','e','l','l','o']</span></div><div class=\"line\"><span class=\"comment\">// 例二</span></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</div><div class=\"line\">[<span class=\"string\">'a'</span>, ...arr, <span class=\"string\">'d'</span>]</div></pre></td></tr></table></figure>\n</li>\n<li><p>yield*<br>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> generator = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">yield</span>* [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">5</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> iterator = generator();</div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: 2, done: false &#125;</span></div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: 3, done: false &#125;</span></div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: 4, done: false &#125;</span></div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: 5, done: false &#125;</span></div><div class=\"line\">iterator.next() <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>其他场合<br>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>\n</li>\n</ol>\n<ul>\n<li><code>for...of</code></li>\n<li><code>Array.from()</code></li>\n<li><code>Map()</code>, <code>Set()</code>, <code>WeakMap()</code>, <code>WeakSet()</code>（比如new Map([[‘a’,1],[‘b’,2]])）</li>\n<li><code>Promise.all()</code></li>\n<li><code>Promise.race()</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> a <span class=\"keyword\">in</span> arr) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 0 1 2 3</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> a <span class=\"keyword\">of</span> arr) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// a b c d</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的entries方法和keys方法，参见《数组的扩展》章节。<br><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p>\n<h3 id=\"Generator_函数\">Generator 函数</h3><h4 id=\"简介\">简介</h4><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍Generator函数的语法和API，它的异步编程应用请看《异步操作》一章。语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。形式上，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。</p>\n<p>Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。<br>下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。</p>\n<h4 id=\"yield语句\">yield语句</h4><p>由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。<br><code>yield</code>语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br>yield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。</p>\n<p><code>for...of</code>循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> *<span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">4</span>;</div><div class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">5</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">6</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v <span class=\"keyword\">of</span> foo()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(v);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 1 2 3 4 5</span></div></pre></td></tr></table></figure></p>\n<p>…待补充</p>\n"},{"title":"前端知识收集","date":"2016-01-21T06:55:50.000Z","_content":"\n整理了一些自己比较感兴趣的前端知识比较好的博文或者网址\n<!--more-->\n1. [HTTP 协议中 URI 和 URL 有什么区别？](http://www.zhihu.com/question/21950864)\n2. [从输入 URL 到页面加载完成的过程中都发生了什么事情？](http://fex.baidu.com/blog/2014/05/what-happen/)\n3. [详解js跨域问题](http://segmentfault.com/a/1190000000718840)\n4. [浅析闭包和内存泄露的问题](http://www.cnblogs.com/yakun/p/3932026.html)\n5. [HTTP缓存相关头](http://www.cnblogs.com/yjf512/p/3244882.html)\n6. [从setTimeout谈JavaScript运行机制](http://web.jobbole.com/82631/)\n7. [JavaScript Promise迷你书（中文版）](http://liubin.github.io/promises-book/#introduction)\n8. [张宁：web前端？](http://dudu.zhihu.com/story/7117186?from=timeline&isappinstalled=0) \n9. [Code Guide by @AlloyTeam](http://alloyteam.github.io/CodeGuide/)\n10. [《React 和 Webpack 小书》](https://fakefish.github.io/react-webpack-cookbook/index.html)\n","source":"_posts/前端知识收集.md","raw":"title: 前端知识收集\ndate: 2016-01-21 14:55:50\ntag: web前端知识\n---\n\n整理了一些自己比较感兴趣的前端知识比较好的博文或者网址\n<!--more-->\n1. [HTTP 协议中 URI 和 URL 有什么区别？](http://www.zhihu.com/question/21950864)\n2. [从输入 URL 到页面加载完成的过程中都发生了什么事情？](http://fex.baidu.com/blog/2014/05/what-happen/)\n3. [详解js跨域问题](http://segmentfault.com/a/1190000000718840)\n4. [浅析闭包和内存泄露的问题](http://www.cnblogs.com/yakun/p/3932026.html)\n5. [HTTP缓存相关头](http://www.cnblogs.com/yjf512/p/3244882.html)\n6. [从setTimeout谈JavaScript运行机制](http://web.jobbole.com/82631/)\n7. [JavaScript Promise迷你书（中文版）](http://liubin.github.io/promises-book/#introduction)\n8. [张宁：web前端？](http://dudu.zhihu.com/story/7117186?from=timeline&isappinstalled=0) \n9. [Code Guide by @AlloyTeam](http://alloyteam.github.io/CodeGuide/)\n10. [《React 和 Webpack 小书》](https://fakefish.github.io/react-webpack-cookbook/index.html)\n","slug":"前端知识收集","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ey9001her2zn4eeg7vd","content":"<p>整理了一些自己比较感兴趣的前端知识比较好的博文或者网址<br><a id=\"more\"></a></p>\n<ol>\n<li><a href=\"http://www.zhihu.com/question/21950864\" target=\"_blank\" rel=\"external\">HTTP 协议中 URI 和 URL 有什么区别？</a></li>\n<li><a href=\"http://fex.baidu.com/blog/2014/05/what-happen/\" target=\"_blank\" rel=\"external\">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000718840\" target=\"_blank\" rel=\"external\">详解js跨域问题</a></li>\n<li><a href=\"http://www.cnblogs.com/yakun/p/3932026.html\" target=\"_blank\" rel=\"external\">浅析闭包和内存泄露的问题</a></li>\n<li><a href=\"http://www.cnblogs.com/yjf512/p/3244882.html\" target=\"_blank\" rel=\"external\">HTTP缓存相关头</a></li>\n<li><a href=\"http://web.jobbole.com/82631/\" target=\"_blank\" rel=\"external\">从setTimeout谈JavaScript运行机制</a></li>\n<li><a href=\"http://liubin.github.io/promises-book/#introduction\" target=\"_blank\" rel=\"external\">JavaScript Promise迷你书（中文版）</a></li>\n<li><a href=\"http://dudu.zhihu.com/story/7117186?from=timeline&amp;isappinstalled=0\" target=\"_blank\" rel=\"external\">张宁：web前端？</a> </li>\n<li><a href=\"http://alloyteam.github.io/CodeGuide/\" target=\"_blank\" rel=\"external\">Code Guide by @AlloyTeam</a></li>\n<li><a href=\"https://fakefish.github.io/react-webpack-cookbook/index.html\" target=\"_blank\" rel=\"external\">《React 和 Webpack 小书》</a></li>\n</ol>\n","excerpt":"<p>整理了一些自己比较感兴趣的前端知识比较好的博文或者网址<br>","more":"</p>\n<ol>\n<li><a href=\"http://www.zhihu.com/question/21950864\">HTTP 协议中 URI 和 URL 有什么区别？</a></li>\n<li><a href=\"http://fex.baidu.com/blog/2014/05/what-happen/\">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000718840\">详解js跨域问题</a></li>\n<li><a href=\"http://www.cnblogs.com/yakun/p/3932026.html\">浅析闭包和内存泄露的问题</a></li>\n<li><a href=\"http://www.cnblogs.com/yjf512/p/3244882.html\">HTTP缓存相关头</a></li>\n<li><a href=\"http://web.jobbole.com/82631/\">从setTimeout谈JavaScript运行机制</a></li>\n<li><a href=\"http://liubin.github.io/promises-book/#introduction\">JavaScript Promise迷你书（中文版）</a></li>\n<li><a href=\"http://dudu.zhihu.com/story/7117186?from=timeline&amp;isappinstalled=0\">张宁：web前端？</a> </li>\n<li><a href=\"http://alloyteam.github.io/CodeGuide/\">Code Guide by @AlloyTeam</a></li>\n<li><a href=\"https://fakefish.github.io/react-webpack-cookbook/index.html\">《React 和 Webpack 小书》</a></li>\n</ol>"},{"title":"垂直居中布局的几种css实现方法","date":"2015-11-20T02:17:50.000Z","_content":"\n在开发中经常会需要实现一些居中布局问题，今天来总结一下垂直居中布局的css实现方法。\n<!-- more -->\n### 任意高度的垂直居中布局\n\n#### 1.父元素tabel-cell +vertical-align\n此方法的优点：兼容性好，兼容ie8+。\n```html\n<style type=\"text/css\">\n    .parent{\n        <!-- 样式内容省略 -->\n        display: tabel-cell;\n        vertical-align:middle;\n    }\n    .child{\n        <!-- 样式内容省略 -->\n    }\n</style>\n<div class=\"parent\">\n    <div class=\"child\">DEMO</div>\n</div>\n```\n<textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: table-cell;vertical-align:middle;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n#### 2. absolute + transform\n优点：不会干扰其他元素  \n缺点：兼容性不好\n```html\n<style>\n    .parent{\n        <!-- 样式内容省略 -->\n        position:relative;\n    }\n    .child{\n        <!-- 样式内容省略 -->\n        position: absolute;\n        top: 50%;\n        transform: translateY(-50%);\n        \n    }\n</style>\n<div class=\"parent\">\n    <div class=\"child\">DEMO</div>\n</div>\n```\n<textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;line-height:100px;position: absolute;top: 50%;transform: translateY(-50%);}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n#### 3.flex+align-items\n优点：和第一种方法一样只需要对父元素设置 \n缺点：兼容性不好\n```html\n    <style type=\"text/css\">\n        .parent{\n            <!-- 样式内容省略 -->\n            display: flex;\n            align-items:center;\n        }\n        .child{\n            <!-- 样式内容省略 -->\n        }\n    </style>\n    <div class=\"parent\">\n        <div class=\"child\">DEMO</div>\n    </div>\n```\n<textarea id=\"runCode3\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: flex;align-items:center;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode3')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n### 固定高度的垂直居中布局\n这个用以上的方法也可以，不过我比较喜欢用负margin实现\n```html\n    <style>\n        .parent{\n            <!-- 样式内容省略 -->\n            position:relative;\n        }\n        .child{\n            <!-- 部分样式内容省略 -->\n            height:200px;\n            position: absolute;\n            top: 50%;\n            margin-top:-100px;\n        }\n    </style>\n    <div class=\"parent\">\n        <div class=\"child\">DEMO</div>\n    </div>\n```\n<textarea id=\"runCode4\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;height:200px;position: absolute;top: 50%; margin-top:-100px;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode4')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n总结了几种方法，各有利弊，还是那句话：具体情况具体分析~ \n\nps:增加了运行代码的功能 更好的代码功能还在研究当中。","source":"_posts/各种居中布局的css实现方法.md","raw":"title: 垂直居中布局的几种css实现方法\ndate: 2015-11-20 10:17:50\ntags: css学习心得\n---\n\n在开发中经常会需要实现一些居中布局问题，今天来总结一下垂直居中布局的css实现方法。\n<!-- more -->\n### 任意高度的垂直居中布局\n\n#### 1.父元素tabel-cell +vertical-align\n此方法的优点：兼容性好，兼容ie8+。\n```html\n<style type=\"text/css\">\n    .parent{\n        <!-- 样式内容省略 -->\n        display: tabel-cell;\n        vertical-align:middle;\n    }\n    .child{\n        <!-- 样式内容省略 -->\n    }\n</style>\n<div class=\"parent\">\n    <div class=\"child\">DEMO</div>\n</div>\n```\n<textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: table-cell;vertical-align:middle;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n#### 2. absolute + transform\n优点：不会干扰其他元素  \n缺点：兼容性不好\n```html\n<style>\n    .parent{\n        <!-- 样式内容省略 -->\n        position:relative;\n    }\n    .child{\n        <!-- 样式内容省略 -->\n        position: absolute;\n        top: 50%;\n        transform: translateY(-50%);\n        \n    }\n</style>\n<div class=\"parent\">\n    <div class=\"child\">DEMO</div>\n</div>\n```\n<textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;line-height:100px;position: absolute;top: 50%;transform: translateY(-50%);}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n#### 3.flex+align-items\n优点：和第一种方法一样只需要对父元素设置 \n缺点：兼容性不好\n```html\n    <style type=\"text/css\">\n        .parent{\n            <!-- 样式内容省略 -->\n            display: flex;\n            align-items:center;\n        }\n        .child{\n            <!-- 样式内容省略 -->\n        }\n    </style>\n    <div class=\"parent\">\n        <div class=\"child\">DEMO</div>\n    </div>\n```\n<textarea id=\"runCode3\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: flex;align-items:center;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode3')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n### 固定高度的垂直居中布局\n这个用以上的方法也可以，不过我比较喜欢用负margin实现\n```html\n    <style>\n        .parent{\n            <!-- 样式内容省略 -->\n            position:relative;\n        }\n        .child{\n            <!-- 部分样式内容省略 -->\n            height:200px;\n            position: absolute;\n            top: 50%;\n            margin-top:-100px;\n        }\n    </style>\n    <div class=\"parent\">\n        <div class=\"child\">DEMO</div>\n    </div>\n```\n<textarea id=\"runCode4\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;height:200px;position: absolute;top: 50%; margin-top:-100px;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea>\n<input style=\"cursor: hand\" onclick=\"runEx('runCode4')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/>\n\n总结了几种方法，各有利弊，还是那句话：具体情况具体分析~ \n\nps:增加了运行代码的功能 更好的代码功能还在研究当中。","slug":"各种居中布局的css实现方法","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489eye001ker2zlurph54u","content":"<p>在开发中经常会需要实现一些居中布局问题，今天来总结一下垂直居中布局的css实现方法。<br><a id=\"more\"></a></p>\n<h3 id=\"任意高度的垂直居中布局\">任意高度的垂直居中布局</h3><h4 id=\"1-父元素tabel-cell_+vertical-align\">1.父元素tabel-cell +vertical-align</h4><p>此方法的优点：兼容性好，兼容ie8+。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"xml\"></span></div><div class=\"line\">    .parent&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">        display: tabel-cell;</div><div class=\"line\">        vertical-align:middle;</div><div class=\"line\">    &#125;</div><div class=\"line\">    .child&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span>DEMO<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: table-cell;vertical-align:middle;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea></p>\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"><br></p>\n<h4 id=\"2-_absolute_+_transform\">2. absolute + transform</h4><p>优点：不会干扰其他元素<br>缺点：兼容性不好<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"xml\"></span></div><div class=\"line\">    .parent&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">        position:relative;</div><div class=\"line\">    &#125;</div><div class=\"line\">    .child&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">        position: absolute;</div><div class=\"line\">        top: 50%;</div><div class=\"line\">        transform: translateY(-50%);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span>DEMO<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;line-height:100px;position: absolute;top: 50%;transform: translateY(-50%);}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea></p>\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"><br></p>\n<h4 id=\"3-flex+align-items\">3.flex+align-items</h4><p>优点：和第一种方法一样只需要对父元素设置<br>缺点：兼容性不好<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"xml\"></span></div><div class=\"line\">    .parent&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">        display: flex;</div><div class=\"line\">        align-items:center;</div><div class=\"line\">    &#125;</div><div class=\"line\">    .child&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span>DEMO<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><textarea id=\"runCode3\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: flex;align-items:center;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea></p>\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode3')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"><br></p>\n<h3 id=\"固定高度的垂直居中布局\">固定高度的垂直居中布局</h3><p>这个用以上的方法也可以，不过我比较喜欢用负margin实现<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"xml\"></span></div><div class=\"line\">    .parent&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">        position:relative;</div><div class=\"line\">    &#125;</div><div class=\"line\">    .child&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 部分样式内容省略 --&gt;</span></div><div class=\"line\">        height:200px;</div><div class=\"line\">        position: absolute;</div><div class=\"line\">        top: 50%;</div><div class=\"line\">        margin-top:-100px;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span>DEMO<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><textarea id=\"runCode4\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;height:200px;position: absolute;top: 50%; margin-top:-100px;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea></p>\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode4')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"><br></p>\n<p>总结了几种方法，各有利弊，还是那句话：具体情况具体分析~ </p>\n<p>ps:增加了运行代码的功能 更好的代码功能还在研究当中。</p>\n","excerpt":"<p>在开发中经常会需要实现一些居中布局问题，今天来总结一下垂直居中布局的css实现方法。<br>","more":"</p>\n<h3 id=\"任意高度的垂直居中布局\">任意高度的垂直居中布局</h3><h4 id=\"1-父元素tabel-cell_+vertical-align\">1.父元素tabel-cell +vertical-align</h4><p>此方法的优点：兼容性好，兼容ie8+。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">    .parent&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">        display: tabel-cell;</div><div class=\"line\">        vertical-align:middle;</div><div class=\"line\">    &#125;</div><div class=\"line\">    .child&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span>DEMO<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><textarea id=\"runCode1\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: table-cell;vertical-align:middle;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea></p>\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode1')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/></p>\n<h4 id=\"2-_absolute_+_transform\">2. absolute + transform</h4><p>优点：不会干扰其他元素<br>缺点：兼容性不好<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">    .parent&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">        position:relative;</div><div class=\"line\">    &#125;</div><div class=\"line\">    .child&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">        position: absolute;</div><div class=\"line\">        top: 50%;</div><div class=\"line\">        transform: translateY(-50%);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span>DEMO<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><textarea id=\"runCode2\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;line-height:100px;position: absolute;top: 50%;transform: translateY(-50%);}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea></p>\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode2')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/></p>\n<h4 id=\"3-flex+align-items\">3.flex+align-items</h4><p>优点：和第一种方法一样只需要对父元素设置<br>缺点：兼容性不好<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">    .parent&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">        display: flex;</div><div class=\"line\">        align-items:center;</div><div class=\"line\">    &#125;</div><div class=\"line\">    .child&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span>DEMO<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><textarea id=\"runCode3\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;display: flex;align-items:center;}.child{background-color:#aaa;width:100%;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea></p>\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode3')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/></p>\n<h3 id=\"固定高度的垂直居中布局\">固定高度的垂直居中布局</h3><p>这个用以上的方法也可以，不过我比较喜欢用负margin实现<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"xml\"></div><div class=\"line\">    .parent&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 样式内容省略 --&gt;</span></div><div class=\"line\">        position:relative;</div><div class=\"line\">    &#125;</div><div class=\"line\">    .child&#123;</div><div class=\"line\">        <span class=\"comment\">&lt;!-- 部分样式内容省略 --&gt;</span></div><div class=\"line\">        height:200px;</div><div class=\"line\">        position: absolute;</div><div class=\"line\">        top: 50%;</div><div class=\"line\">        margin-top:-100px;</div><div class=\"line\">    &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"child\"</span>&gt;</span>DEMO<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><textarea id=\"runCode4\" name=\"textarea\" rows=\"10\" cols=\"60\" class=\"runCode\"><style type=\"text/css\">.parent{height: 600px;width: 200px;background-color: #999;position:relative;}.child{background-color:#aaa;width:100%;height:200px;position: absolute;top: 50%; margin-top:-100px;}</style><div class=\"parent\"><div class=\"child\">DEMO</div></div></textarea></p>\n<p><input style=\"cursor: hand\" onclick=\"runEx('runCode4')\" type=\"button\" value=\"运行代码\" class=\"runCode-btn\"/><br/></p>\n<p>总结了几种方法，各有利弊，还是那句话：具体情况具体分析~ </p>\n<p>ps:增加了运行代码的功能 更好的代码功能还在研究当中。</p>"},{"title":"不是只有if和else","date":"2015-11-20T02:17:50.000Z","_content":"\n在我们写javascript函数的时候，经常会使用到条件判断，使用得最多的就是if else进行判断了。使用得多了渐渐会特别依赖这个最简单的方法，而导致整个函数里好多if else,甚至嵌套很多层。仔细研究，我们会发现用一大段if else的逻辑，其实用其他方法，一句话就能够完全实现同样的功能。\n\n#### 初级替代之一：三元表达式\n    var max = a>b?a:b;\n\n三元表达式的规则就是，当\"?\"前的表达式为true时，返回\":\"前的值，否则返回\":\"后的值。\n所以上面那句表达式等价于\n```javascript\nif(a>b){\n    max=a;\n}else{\n    max=b;\n}\n```\n#### 初级替代之二：switch\n\nswitch作为条件判断的方法之二，很明显可以替代一些简单但是重复的if else。实例\n\n```javascript\n    if(str==\"项链\"){//用if else\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }else{\n        type=\"人类\";\n    }\n```\n```javascript\n    switch(str){//switch\n        case \"项链\": type=\"珠宝\";\n        break;\n        case \"苹果\": type=\"水果\";\n        break;\n        case \"仙人掌\": type=\"植物\";\n        break;\n        default:\n        type==\"人类\";\n    }\n```\n但是看了上面的代码，肯定很多人会说，switch根本没有好到哪里去嘛，只是看上去稍微清晰了一点点。确实，所以我们有更简单的方法。\n\n#### 高级替代：对象字面量；\n    \n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = typeMap[str];\n\n上面两句话就完成了之前一大段的逻辑，不过还没有完全完成，因为有个默认值“人类”没有写进去。这个该怎么加进去呢？\n\n#### 还有“&&”和“||”\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = typeMap[str]||\"人类\";\n\n就这么两句话就完全实现了之前一大段逻辑判断的功能。不相信？可以试一试哦。\n```javascript\n    var type = typeMap[\"项链\"]||\"人类\";\n    console.log(type)// 珠宝\n\n    var type2 = typeMap[\"不认识\"]||\"人类\";\n    console.log(type2)// 人类\n```\n\n要了解这之中的原因，首先要了解“||”的机制。\n一般我们用“||”是用来进行布尔判断，前后都是布尔值，但是当其中一个不是布尔值时，它遵循以下原则:\n>- 如果第一个操作数是对象，则返回第一个操作数。\n- 如果第一个操作数的求值结果为false，则返回第二个操作数。\n- 如果两个操作数都是对象，则返回第一个操作数。\n- 如果两个操作数都是null，则返回null。\n- 如果两个操作数都是NaN，则返回NaN。\n- 如果两个操作数都是undefined，则返回undefined。\n\n而且这是短路操作符，也就是说，如果第一个操作数的结果为true，则不会对第二个操作数求值了。\n所以很多时候，我们也用“||” 来给变量定义默认值。如：`var a= str|| default`\n\n&&的用法和||正好相反，它的机制是：\n>- 如果第一个操作数是对象，则返回第二个操作数。\n- 如果第二个操作数是对象，且只有第一个操作数的求值结果为true，则返回第二个操作数。\n- 如果有一个操作数都是对象，则返回第一个操作数。\n- 如果有一个操作数都是null，则返回null。\n- 如果有一个操作数都是NaN，则返回NaN。\n- 如果有一个操作数都是undefined，则返回undefined。\n\n所以我们可以这么用\n```javascript\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = (year>1) && typeMap[str];\n```\n上面这段话等同于\n```javascript\nif(year>1){\n    if(str==\"项链\"){\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }\n}\n```\n然后我们还可以这样来\n```javascript\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = ((year>1) && typeMap[str]) || \"人类\";\n```\n这段话等同于\n```javascript\nif(year>1){\n    if(str==\"项链\"){\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }else{\n        type=\"人类\";\n    }\n}else{\n    type=\"人类\";\n}\n```\n卧槽，简直简便了好多对吧，不过为了维护性，还是不建议同时使用多个\"&&\" \"||\"，因为多了阅读起来就和阅读正则一样困难了。\n\n\n讲了以上几个方法，至于到底要怎么做，还是要具体情况具体分析啦。","source":"_posts/不是只有“if else”.md","raw":"title: 不是只有if和else\ndate: 2015-11-20 10:17:50\ntags: Javascript学习笔记\n---\n\n在我们写javascript函数的时候，经常会使用到条件判断，使用得最多的就是if else进行判断了。使用得多了渐渐会特别依赖这个最简单的方法，而导致整个函数里好多if else,甚至嵌套很多层。仔细研究，我们会发现用一大段if else的逻辑，其实用其他方法，一句话就能够完全实现同样的功能。\n\n#### 初级替代之一：三元表达式\n    var max = a>b?a:b;\n\n三元表达式的规则就是，当\"?\"前的表达式为true时，返回\":\"前的值，否则返回\":\"后的值。\n所以上面那句表达式等价于\n```javascript\nif(a>b){\n    max=a;\n}else{\n    max=b;\n}\n```\n#### 初级替代之二：switch\n\nswitch作为条件判断的方法之二，很明显可以替代一些简单但是重复的if else。实例\n\n```javascript\n    if(str==\"项链\"){//用if else\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }else{\n        type=\"人类\";\n    }\n```\n```javascript\n    switch(str){//switch\n        case \"项链\": type=\"珠宝\";\n        break;\n        case \"苹果\": type=\"水果\";\n        break;\n        case \"仙人掌\": type=\"植物\";\n        break;\n        default:\n        type==\"人类\";\n    }\n```\n但是看了上面的代码，肯定很多人会说，switch根本没有好到哪里去嘛，只是看上去稍微清晰了一点点。确实，所以我们有更简单的方法。\n\n#### 高级替代：对象字面量；\n    \n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = typeMap[str];\n\n上面两句话就完成了之前一大段的逻辑，不过还没有完全完成，因为有个默认值“人类”没有写进去。这个该怎么加进去呢？\n\n#### 还有“&&”和“||”\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = typeMap[str]||\"人类\";\n\n就这么两句话就完全实现了之前一大段逻辑判断的功能。不相信？可以试一试哦。\n```javascript\n    var type = typeMap[\"项链\"]||\"人类\";\n    console.log(type)// 珠宝\n\n    var type2 = typeMap[\"不认识\"]||\"人类\";\n    console.log(type2)// 人类\n```\n\n要了解这之中的原因，首先要了解“||”的机制。\n一般我们用“||”是用来进行布尔判断，前后都是布尔值，但是当其中一个不是布尔值时，它遵循以下原则:\n>- 如果第一个操作数是对象，则返回第一个操作数。\n- 如果第一个操作数的求值结果为false，则返回第二个操作数。\n- 如果两个操作数都是对象，则返回第一个操作数。\n- 如果两个操作数都是null，则返回null。\n- 如果两个操作数都是NaN，则返回NaN。\n- 如果两个操作数都是undefined，则返回undefined。\n\n而且这是短路操作符，也就是说，如果第一个操作数的结果为true，则不会对第二个操作数求值了。\n所以很多时候，我们也用“||” 来给变量定义默认值。如：`var a= str|| default`\n\n&&的用法和||正好相反，它的机制是：\n>- 如果第一个操作数是对象，则返回第二个操作数。\n- 如果第二个操作数是对象，且只有第一个操作数的求值结果为true，则返回第二个操作数。\n- 如果有一个操作数都是对象，则返回第一个操作数。\n- 如果有一个操作数都是null，则返回null。\n- 如果有一个操作数都是NaN，则返回NaN。\n- 如果有一个操作数都是undefined，则返回undefined。\n\n所以我们可以这么用\n```javascript\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = (year>1) && typeMap[str];\n```\n上面这段话等同于\n```javascript\nif(year>1){\n    if(str==\"项链\"){\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }\n}\n```\n然后我们还可以这样来\n```javascript\n    var typeMap = {\"项链\":\"珠宝\",\"苹果\":\"水果\",\"仙人掌\":\"植物\"};\n    var type = ((year>1) && typeMap[str]) || \"人类\";\n```\n这段话等同于\n```javascript\nif(year>1){\n    if(str==\"项链\"){\n        type=\"珠宝\";\n    }else if(str==\"苹果\"){\n        type=\"水果\";\n    }else if(str==\"仙人掌\"){\n        type=\"植物\";\n    }else{\n        type=\"人类\";\n    }\n}else{\n    type=\"人类\";\n}\n```\n卧槽，简直简便了好多对吧，不过为了维护性，还是不建议同时使用多个\"&&\" \"||\"，因为多了阅读起来就和阅读正则一样困难了。\n\n\n讲了以上几个方法，至于到底要怎么做，还是要具体情况具体分析啦。","slug":"不是只有“if else”","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489eyh001mer2zl7yib3zm","content":"<p>在我们写javascript函数的时候，经常会使用到条件判断，使用得最多的就是if else进行判断了。使用得多了渐渐会特别依赖这个最简单的方法，而导致整个函数里好多if else,甚至嵌套很多层。仔细研究，我们会发现用一大段if else的逻辑，其实用其他方法，一句话就能够完全实现同样的功能。</p>\n<h4 id=\"初级替代之一：三元表达式\">初级替代之一：三元表达式</h4><pre><code><span class=\"variable\"><span class=\"keyword\">var</span> max</span> = a&gt;b?a:b;\n</code></pre><p>三元表达式的规则就是，当”?”前的表达式为true时，返回”:”前的值，否则返回”:”后的值。<br>所以上面那句表达式等价于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(a&gt;b)&#123;</div><div class=\"line\">    max=a;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    max=b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"初级替代之二：switch\">初级替代之二：switch</h4><p>switch作为条件判断的方法之二，很明显可以替代一些简单但是重复的if else。实例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(str==<span class=\"string\">\"项链\"</span>)&#123;<span class=\"comment\">//用if else</span></div><div class=\"line\">    type=<span class=\"string\">\"珠宝\"</span>;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"苹果\"</span>)&#123;</div><div class=\"line\">    type=<span class=\"string\">\"水果\"</span>;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"仙人掌\"</span>)&#123;</div><div class=\"line\">    type=<span class=\"string\">\"植物\"</span>;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    type=<span class=\"string\">\"人类\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">switch</span>(str)&#123;<span class=\"comment\">//switch</span></div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"项链\"</span>: type=<span class=\"string\">\"珠宝\"</span>;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"苹果\"</span>: type=<span class=\"string\">\"水果\"</span>;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"仙人掌\"</span>: type=<span class=\"string\">\"植物\"</span>;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">    type==<span class=\"string\">\"人类\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是看了上面的代码，肯定很多人会说，switch根本没有好到哪里去嘛，只是看上去稍微清晰了一点点。确实，所以我们有更简单的方法。</p>\n<h4 id=\"高级替代：对象字面量；\">高级替代：对象字面量；</h4><pre><code><span class=\"variable\"><span class=\"keyword\">var</span> typeMap</span> = {<span class=\"string\">\"项链\"</span>:<span class=\"string\">\"珠宝\"</span>,<span class=\"string\">\"苹果\"</span>:<span class=\"string\">\"水果\"</span>,<span class=\"string\">\"仙人掌\"</span>:<span class=\"string\">\"植物\"</span>};\n<span class=\"variable\"><span class=\"keyword\">var</span> type</span> = typeMap[str];\n</code></pre><p>上面两句话就完成了之前一大段的逻辑，不过还没有完全完成，因为有个默认值“人类”没有写进去。这个该怎么加进去呢？</p>\n<h4 id=\"还有“&amp;&amp;”和“||”\">还有“&amp;&amp;”和“||”</h4><pre><code><span class=\"variable\"><span class=\"keyword\">var</span> typeMap</span> = {<span class=\"string\">\"项链\"</span>:<span class=\"string\">\"珠宝\"</span>,<span class=\"string\">\"苹果\"</span>:<span class=\"string\">\"水果\"</span>,<span class=\"string\">\"仙人掌\"</span>:<span class=\"string\">\"植物\"</span>};\n<span class=\"variable\"><span class=\"keyword\">var</span> type</span> = typeMap[str]||<span class=\"string\">\"人类\"</span>;\n</code></pre><p>就这么两句话就完全实现了之前一大段逻辑判断的功能。不相信？可以试一试哦。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> type = typeMap[<span class=\"string\">\"项链\"</span>]||<span class=\"string\">\"人类\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(type)<span class=\"comment\">// 珠宝</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> type2 = typeMap[<span class=\"string\">\"不认识\"</span>]||<span class=\"string\">\"人类\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(type2)<span class=\"comment\">// 人类</span></div></pre></td></tr></table></figure></p>\n<p>要了解这之中的原因，首先要了解“||”的机制。<br>一般我们用“||”是用来进行布尔判断，前后都是布尔值，但是当其中一个不是布尔值时，它遵循以下原则:</p>\n<blockquote>\n<ul>\n<li>如果第一个操作数是对象，则返回第一个操作数。</li>\n<li>如果第一个操作数的求值结果为false，则返回第二个操作数。</li>\n<li>如果两个操作数都是对象，则返回第一个操作数。</li>\n<li>如果两个操作数都是null，则返回null。</li>\n<li>如果两个操作数都是NaN，则返回NaN。</li>\n<li>如果两个操作数都是undefined，则返回undefined。</li>\n</ul>\n</blockquote>\n<p>而且这是短路操作符，也就是说，如果第一个操作数的结果为true，则不会对第二个操作数求值了。<br>所以很多时候，我们也用“||” 来给变量定义默认值。如：<code>var a= str|| default</code></p>\n<p>&amp;&amp;的用法和||正好相反，它的机制是：</p>\n<blockquote>\n<ul>\n<li>如果第一个操作数是对象，则返回第二个操作数。</li>\n<li>如果第二个操作数是对象，且只有第一个操作数的求值结果为true，则返回第二个操作数。</li>\n<li>如果有一个操作数都是对象，则返回第一个操作数。</li>\n<li>如果有一个操作数都是null，则返回null。</li>\n<li>如果有一个操作数都是NaN，则返回NaN。</li>\n<li>如果有一个操作数都是undefined，则返回undefined。</li>\n</ul>\n</blockquote>\n<p>所以我们可以这么用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> typeMap = &#123;<span class=\"string\">\"项链\"</span>:<span class=\"string\">\"珠宝\"</span>,<span class=\"string\">\"苹果\"</span>:<span class=\"string\">\"水果\"</span>,<span class=\"string\">\"仙人掌\"</span>:<span class=\"string\">\"植物\"</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> type = (year&gt;<span class=\"number\">1</span>) &amp;&amp; typeMap[str];</div></pre></td></tr></table></figure></p>\n<p>上面这段话等同于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(year&gt;<span class=\"number\">1</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(str==<span class=\"string\">\"项链\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"珠宝\"</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"苹果\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"水果\"</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"仙人掌\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"植物\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我们还可以这样来<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> typeMap = &#123;<span class=\"string\">\"项链\"</span>:<span class=\"string\">\"珠宝\"</span>,<span class=\"string\">\"苹果\"</span>:<span class=\"string\">\"水果\"</span>,<span class=\"string\">\"仙人掌\"</span>:<span class=\"string\">\"植物\"</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> type = ((year&gt;<span class=\"number\">1</span>) &amp;&amp; typeMap[str]) || <span class=\"string\">\"人类\"</span>;</div></pre></td></tr></table></figure></p>\n<p>这段话等同于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(year&gt;<span class=\"number\">1</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(str==<span class=\"string\">\"项链\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"珠宝\"</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"苹果\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"水果\"</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"仙人掌\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"植物\"</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        type=<span class=\"string\">\"人类\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    type=<span class=\"string\">\"人类\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>卧槽，简直简便了好多对吧，不过为了维护性，还是不建议同时使用多个”&amp;&amp;” “||”，因为多了阅读起来就和阅读正则一样困难了。</p>\n<p>讲了以上几个方法，至于到底要怎么做，还是要具体情况具体分析啦。</p>\n","excerpt":"","more":"<p>在我们写javascript函数的时候，经常会使用到条件判断，使用得最多的就是if else进行判断了。使用得多了渐渐会特别依赖这个最简单的方法，而导致整个函数里好多if else,甚至嵌套很多层。仔细研究，我们会发现用一大段if else的逻辑，其实用其他方法，一句话就能够完全实现同样的功能。</p>\n<h4 id=\"初级替代之一：三元表达式\">初级替代之一：三元表达式</h4><pre><code><span class=\"variable\"><span class=\"keyword\">var</span> max</span> = a&gt;b?a:b;\n</code></pre><p>三元表达式的规则就是，当”?”前的表达式为true时，返回”:”前的值，否则返回”:”后的值。<br>所以上面那句表达式等价于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(a&gt;b)&#123;</div><div class=\"line\">    max=a;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    max=b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"初级替代之二：switch\">初级替代之二：switch</h4><p>switch作为条件判断的方法之二，很明显可以替代一些简单但是重复的if else。实例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(str==<span class=\"string\">\"项链\"</span>)&#123;<span class=\"comment\">//用if else</span></div><div class=\"line\">    type=<span class=\"string\">\"珠宝\"</span>;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"苹果\"</span>)&#123;</div><div class=\"line\">    type=<span class=\"string\">\"水果\"</span>;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"仙人掌\"</span>)&#123;</div><div class=\"line\">    type=<span class=\"string\">\"植物\"</span>;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    type=<span class=\"string\">\"人类\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">switch</span>(str)&#123;<span class=\"comment\">//switch</span></div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"项链\"</span>: type=<span class=\"string\">\"珠宝\"</span>;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"苹果\"</span>: type=<span class=\"string\">\"水果\"</span>;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"仙人掌\"</span>: type=<span class=\"string\">\"植物\"</span>;</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">    type==<span class=\"string\">\"人类\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是看了上面的代码，肯定很多人会说，switch根本没有好到哪里去嘛，只是看上去稍微清晰了一点点。确实，所以我们有更简单的方法。</p>\n<h4 id=\"高级替代：对象字面量；\">高级替代：对象字面量；</h4><pre><code><span class=\"variable\"><span class=\"keyword\">var</span> typeMap</span> = {<span class=\"string\">\"项链\"</span>:<span class=\"string\">\"珠宝\"</span>,<span class=\"string\">\"苹果\"</span>:<span class=\"string\">\"水果\"</span>,<span class=\"string\">\"仙人掌\"</span>:<span class=\"string\">\"植物\"</span>};\n<span class=\"variable\"><span class=\"keyword\">var</span> type</span> = typeMap[str];\n</code></pre><p>上面两句话就完成了之前一大段的逻辑，不过还没有完全完成，因为有个默认值“人类”没有写进去。这个该怎么加进去呢？</p>\n<h4 id=\"还有“&amp;&amp;”和“||”\">还有“&amp;&amp;”和“||”</h4><pre><code><span class=\"variable\"><span class=\"keyword\">var</span> typeMap</span> = {<span class=\"string\">\"项链\"</span>:<span class=\"string\">\"珠宝\"</span>,<span class=\"string\">\"苹果\"</span>:<span class=\"string\">\"水果\"</span>,<span class=\"string\">\"仙人掌\"</span>:<span class=\"string\">\"植物\"</span>};\n<span class=\"variable\"><span class=\"keyword\">var</span> type</span> = typeMap[str]||<span class=\"string\">\"人类\"</span>;\n</code></pre><p>就这么两句话就完全实现了之前一大段逻辑判断的功能。不相信？可以试一试哦。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> type = typeMap[<span class=\"string\">\"项链\"</span>]||<span class=\"string\">\"人类\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(type)<span class=\"comment\">// 珠宝</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> type2 = typeMap[<span class=\"string\">\"不认识\"</span>]||<span class=\"string\">\"人类\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(type2)<span class=\"comment\">// 人类</span></div></pre></td></tr></table></figure></p>\n<p>要了解这之中的原因，首先要了解“||”的机制。<br>一般我们用“||”是用来进行布尔判断，前后都是布尔值，但是当其中一个不是布尔值时，它遵循以下原则:</p>\n<blockquote>\n<ul>\n<li>如果第一个操作数是对象，则返回第一个操作数。</li>\n<li>如果第一个操作数的求值结果为false，则返回第二个操作数。</li>\n<li>如果两个操作数都是对象，则返回第一个操作数。</li>\n<li>如果两个操作数都是null，则返回null。</li>\n<li>如果两个操作数都是NaN，则返回NaN。</li>\n<li>如果两个操作数都是undefined，则返回undefined。</li>\n</ul>\n</blockquote>\n<p>而且这是短路操作符，也就是说，如果第一个操作数的结果为true，则不会对第二个操作数求值了。<br>所以很多时候，我们也用“||” 来给变量定义默认值。如：<code>var a= str|| default</code></p>\n<p>&amp;&amp;的用法和||正好相反，它的机制是：</p>\n<blockquote>\n<ul>\n<li>如果第一个操作数是对象，则返回第二个操作数。</li>\n<li>如果第二个操作数是对象，且只有第一个操作数的求值结果为true，则返回第二个操作数。</li>\n<li>如果有一个操作数都是对象，则返回第一个操作数。</li>\n<li>如果有一个操作数都是null，则返回null。</li>\n<li>如果有一个操作数都是NaN，则返回NaN。</li>\n<li>如果有一个操作数都是undefined，则返回undefined。</li>\n</ul>\n</blockquote>\n<p>所以我们可以这么用<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> typeMap = &#123;<span class=\"string\">\"项链\"</span>:<span class=\"string\">\"珠宝\"</span>,<span class=\"string\">\"苹果\"</span>:<span class=\"string\">\"水果\"</span>,<span class=\"string\">\"仙人掌\"</span>:<span class=\"string\">\"植物\"</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> type = (year&gt;<span class=\"number\">1</span>) &amp;&amp; typeMap[str];</div></pre></td></tr></table></figure></p>\n<p>上面这段话等同于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(year&gt;<span class=\"number\">1</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(str==<span class=\"string\">\"项链\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"珠宝\"</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"苹果\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"水果\"</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"仙人掌\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"植物\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我们还可以这样来<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> typeMap = &#123;<span class=\"string\">\"项链\"</span>:<span class=\"string\">\"珠宝\"</span>,<span class=\"string\">\"苹果\"</span>:<span class=\"string\">\"水果\"</span>,<span class=\"string\">\"仙人掌\"</span>:<span class=\"string\">\"植物\"</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> type = ((year&gt;<span class=\"number\">1</span>) &amp;&amp; typeMap[str]) || <span class=\"string\">\"人类\"</span>;</div></pre></td></tr></table></figure></p>\n<p>这段话等同于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(year&gt;<span class=\"number\">1</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(str==<span class=\"string\">\"项链\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"珠宝\"</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"苹果\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"水果\"</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str==<span class=\"string\">\"仙人掌\"</span>)&#123;</div><div class=\"line\">        type=<span class=\"string\">\"植物\"</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        type=<span class=\"string\">\"人类\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    type=<span class=\"string\">\"人类\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>卧槽，简直简便了好多对吧，不过为了维护性，还是不建议同时使用多个”&amp;&amp;” “||”，因为多了阅读起来就和阅读正则一样困难了。</p>\n<p>讲了以上几个方法，至于到底要怎么做，还是要具体情况具体分析啦。</p>\n"},{"title":"利用Fiddler进行前端调试","date":"2016-02-24T01:34:50.000Z","_content":"最近刚get了一个很方便前端调试的新技能，特别在已上线网页上修复bug的时候调试很实用，比如我在本地改了一个test1.js文件想要测试效果，但是又不想很麻烦地推到测试环境，就可以用这个工具把线上的test1.js文件请求到自己的本地test1.js文件，这样你的代码可以直接进行调试了。\n\n首先我们要用的工具是[Fiddler](http://www.telerik.com/fiddler)，这是一个强大的工具，在这里我就不详细介绍了，有兴趣的可以去了解一下[慕课网：Fiddler工具的使用](http://www.imooc.com/learn/37)。\n\n我们直接进入正题：利用Fiddler进行前端调试。\n\n打开软件，我们看到的是这样的界面：\n![软件界面](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/1.png)\n左边那些就是你的网络请求列表，右边是一些工具面板。\n\n我们以coolmogu.com为例，打开本网站，出现以下请求：\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/2.png)\n\n假如我们要修改index.js，在本地我们有一个index.js，具体步骤如下图\n\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/4.png)\n\n这样再刷新页面，实际coolmogu.com以后请求的index.js就是请求的你本地的Index.js了。假如我index.js里加了一行`alert(\"cky\")`, ![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/3.png) 看看效果：\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/5.png)\n\n很简单吧，还可以用同样的方法进行css文件调试等~\n\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/6.jpg)\n\n（本来之前用的图床，结果图床挂了- -，今天来修复图片。以后图片还是放在自己的github上吧）","source":"_posts/利用fiddler进行前端调试.md","raw":"title: 利用Fiddler进行前端调试\ndate: 2016-02-24 09:34:50\ntags: web前端知识\n\n---\n最近刚get了一个很方便前端调试的新技能，特别在已上线网页上修复bug的时候调试很实用，比如我在本地改了一个test1.js文件想要测试效果，但是又不想很麻烦地推到测试环境，就可以用这个工具把线上的test1.js文件请求到自己的本地test1.js文件，这样你的代码可以直接进行调试了。\n\n首先我们要用的工具是[Fiddler](http://www.telerik.com/fiddler)，这是一个强大的工具，在这里我就不详细介绍了，有兴趣的可以去了解一下[慕课网：Fiddler工具的使用](http://www.imooc.com/learn/37)。\n\n我们直接进入正题：利用Fiddler进行前端调试。\n\n打开软件，我们看到的是这样的界面：\n![软件界面](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/1.png)\n左边那些就是你的网络请求列表，右边是一些工具面板。\n\n我们以coolmogu.com为例，打开本网站，出现以下请求：\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/2.png)\n\n假如我们要修改index.js，在本地我们有一个index.js，具体步骤如下图\n\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/4.png)\n\n这样再刷新页面，实际coolmogu.com以后请求的index.js就是请求的你本地的Index.js了。假如我index.js里加了一行`alert(\"cky\")`, ![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/3.png) 看看效果：\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/5.png)\n\n很简单吧，还可以用同样的方法进行css文件调试等~\n\n![](https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/6.jpg)\n\n（本来之前用的图床，结果图床挂了- -，今天来修复图片。以后图片还是放在自己的github上吧）","slug":"利用fiddler进行前端调试","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489eyp001per2z2mbi05p8","content":"<p>最近刚get了一个很方便前端调试的新技能，特别在已上线网页上修复bug的时候调试很实用，比如我在本地改了一个test1.js文件想要测试效果，但是又不想很麻烦地推到测试环境，就可以用这个工具把线上的test1.js文件请求到自己的本地test1.js文件，这样你的代码可以直接进行调试了。</p>\n<p>首先我们要用的工具是<a href=\"http://www.telerik.com/fiddler\" target=\"_blank\" rel=\"external\">Fiddler</a>，这是一个强大的工具，在这里我就不详细介绍了，有兴趣的可以去了解一下<a href=\"http://www.imooc.com/learn/37\" target=\"_blank\" rel=\"external\">慕课网：Fiddler工具的使用</a>。</p>\n<p>我们直接进入正题：利用Fiddler进行前端调试。</p>\n<p>打开软件，我们看到的是这样的界面：<br><img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/1.png\" alt=\"软件界面\"><br>左边那些就是你的网络请求列表，右边是一些工具面板。</p>\n<p>我们以coolmogu.com为例，打开本网站，出现以下请求：<br><img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/2.png\" alt=\"\"></p>\n<p>假如我们要修改index.js，在本地我们有一个index.js，具体步骤如下图</p>\n<p><img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/4.png\" alt=\"\"></p>\n<p>这样再刷新页面，实际coolmogu.com以后请求的index.js就是请求的你本地的Index.js了。假如我index.js里加了一行<code>alert(&quot;cky&quot;)</code>, <img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/3.png\" alt=\"\"> 看看效果：<br><img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/5.png\" alt=\"\"></p>\n<p>很简单吧，还可以用同样的方法进行css文件调试等~</p>\n<p><img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/6.jpg\" alt=\"\"></p>\n<p>（本来之前用的图床，结果图床挂了- -，今天来修复图片。以后图片还是放在自己的github上吧）</p>\n","excerpt":"","more":"<p>最近刚get了一个很方便前端调试的新技能，特别在已上线网页上修复bug的时候调试很实用，比如我在本地改了一个test1.js文件想要测试效果，但是又不想很麻烦地推到测试环境，就可以用这个工具把线上的test1.js文件请求到自己的本地test1.js文件，这样你的代码可以直接进行调试了。</p>\n<p>首先我们要用的工具是<a href=\"http://www.telerik.com/fiddler\">Fiddler</a>，这是一个强大的工具，在这里我就不详细介绍了，有兴趣的可以去了解一下<a href=\"http://www.imooc.com/learn/37\">慕课网：Fiddler工具的使用</a>。</p>\n<p>我们直接进入正题：利用Fiddler进行前端调试。</p>\n<p>打开软件，我们看到的是这样的界面：<br><img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/1.png\" alt=\"软件界面\"><br>左边那些就是你的网络请求列表，右边是一些工具面板。</p>\n<p>我们以coolmogu.com为例，打开本网站，出现以下请求：<br><img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/2.png\" alt=\"\"></p>\n<p>假如我们要修改index.js，在本地我们有一个index.js，具体步骤如下图</p>\n<p><img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/4.png\" alt=\"\"></p>\n<p>这样再刷新页面，实际coolmogu.com以后请求的index.js就是请求的你本地的Index.js了。假如我index.js里加了一行<code>alert(&quot;cky&quot;)</code>, <img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/3.png\" alt=\"\"> 看看效果：<br><img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/5.png\" alt=\"\"></p>\n<p>很简单吧，还可以用同样的方法进行css文件调试等~</p>\n<p><img src=\"https://raw.githubusercontent.com/cky917/blog/master/themes/mabao-theme/source/img/6.jpg\" alt=\"\"></p>\n<p>（本来之前用的图床，结果图床挂了- -，今天来修复图片。以后图片还是放在自己的github上吧）</p>\n"},{"title":"浏览器的重绘与重排","date":"2015-09-23T12:46:25.000Z","_content":"\n前端开发的过程中，我们不仅要实现设计师提供的炫酷设计稿，同时还要考虑到用最好的方式，最优的性能去实现它。为此，我们需要了解浏览器的重绘与重排概念。\n<!--more-->\n首先我们要先了解浏览器从下载文档到显示页面的过程，这里面就包含了重绘与重排。\n>简单讲，通常在文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了，再根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。\n\n重绘的概念：\n>重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。\n\n重排（也称作回流）是更明显的一种改变，可以理解为渲染树需要重新计算。\n\n触发重排的常见情况有三种：\n1. DOM元素的几何属性变化\n一个DOM元素的几何属性实现改变，会使浏览器重新构建此节点，而且也许会带来相关元素的重排。浏览器会计算相关元素如兄弟元素、子元素的尺寸，进行重新绘制。可见，重排一定会引起浏览器的重绘，一个元素的重排通常带来一系列的反应，性能代价是高昂的。\n\n2. DOM树的结构变化\n    当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。浏览器的布局过程类似于树的前序遍历，是一个从从上到下从左到右的过程。所以，如果在Body最前面插入一个元素，会导致整个文档树的重排，而在最后插入元素，不会影响前面的元素。\n3. 获取某些属性\n    当获取某些属性时，浏览器为了取得正确的值，也会触发重排。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()\n\n    所以，在多次使用这些值时，应该进行缓存。\n\n开发中减少重排次数和缩小重排范围的方法：\n1. 将多次改变样式属性的操作合并为一次操作，也就是将需要改变的的样式写在css中，并给一个类名，在js中只需要改变className即可。\n\n2. 需要多次重排的元素，position值最好为absolute或者fix，让它脱离文档流，这样就不会影响其他元素。所以有动画效果的元素最好设置绝对定位。\n\n3. 需要增加多个节点，可以一次性构建一个html片段，然后一次性添加到文档中去，而不是循环添加每一行。\n\n4. 由于display为none的元素不再渲染树中，对隐藏元素的操作不会引发其他元素的重排。如果要对一个元素进行复杂操作，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。\n\n5. 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。","source":"_posts/浏览器的重绘与重排.md","raw":"title: 浏览器的重绘与重排\ndate: 2015-9-23 20:46:25\ntag: web前端知识\n---\n\n前端开发的过程中，我们不仅要实现设计师提供的炫酷设计稿，同时还要考虑到用最好的方式，最优的性能去实现它。为此，我们需要了解浏览器的重绘与重排概念。\n<!--more-->\n首先我们要先了解浏览器从下载文档到显示页面的过程，这里面就包含了重绘与重排。\n>简单讲，通常在文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了，再根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。\n\n重绘的概念：\n>重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。\n\n重排（也称作回流）是更明显的一种改变，可以理解为渲染树需要重新计算。\n\n触发重排的常见情况有三种：\n1. DOM元素的几何属性变化\n一个DOM元素的几何属性实现改变，会使浏览器重新构建此节点，而且也许会带来相关元素的重排。浏览器会计算相关元素如兄弟元素、子元素的尺寸，进行重新绘制。可见，重排一定会引起浏览器的重绘，一个元素的重排通常带来一系列的反应，性能代价是高昂的。\n\n2. DOM树的结构变化\n    当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。浏览器的布局过程类似于树的前序遍历，是一个从从上到下从左到右的过程。所以，如果在Body最前面插入一个元素，会导致整个文档树的重排，而在最后插入元素，不会影响前面的元素。\n3. 获取某些属性\n    当获取某些属性时，浏览器为了取得正确的值，也会触发重排。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()\n\n    所以，在多次使用这些值时，应该进行缓存。\n\n开发中减少重排次数和缩小重排范围的方法：\n1. 将多次改变样式属性的操作合并为一次操作，也就是将需要改变的的样式写在css中，并给一个类名，在js中只需要改变className即可。\n\n2. 需要多次重排的元素，position值最好为absolute或者fix，让它脱离文档流，这样就不会影响其他元素。所以有动画效果的元素最好设置绝对定位。\n\n3. 需要增加多个节点，可以一次性构建一个html片段，然后一次性添加到文档中去，而不是循环添加每一行。\n\n4. 由于display为none的元素不再渲染树中，对隐藏元素的操作不会引发其他元素的重排。如果要对一个元素进行复杂操作，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。\n\n5. 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。","slug":"浏览器的重绘与重排","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489eyq001rer2zygkyb1r1","content":"<p>前端开发的过程中，我们不仅要实现设计师提供的炫酷设计稿，同时还要考虑到用最好的方式，最优的性能去实现它。为此，我们需要了解浏览器的重绘与重排概念。<br><a id=\"more\"></a><br>首先我们要先了解浏览器从下载文档到显示页面的过程，这里面就包含了重绘与重排。</p>\n<blockquote>\n<p>简单讲，通常在文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了，再根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。</p>\n</blockquote>\n<p>重绘的概念：</p>\n<blockquote>\n<p>重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。</p>\n</blockquote>\n<p>重排（也称作回流）是更明显的一种改变，可以理解为渲染树需要重新计算。</p>\n<p>触发重排的常见情况有三种：</p>\n<ol>\n<li><p>DOM元素的几何属性变化<br>一个DOM元素的几何属性实现改变，会使浏览器重新构建此节点，而且也许会带来相关元素的重排。浏览器会计算相关元素如兄弟元素、子元素的尺寸，进行重新绘制。可见，重排一定会引起浏览器的重绘，一个元素的重排通常带来一系列的反应，性能代价是高昂的。</p>\n</li>\n<li><p>DOM树的结构变化<br> 当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。浏览器的布局过程类似于树的前序遍历，是一个从从上到下从左到右的过程。所以，如果在Body最前面插入一个元素，会导致整个文档树的重排，而在最后插入元素，不会影响前面的元素。</p>\n</li>\n<li><p>获取某些属性<br> 当获取某些属性时，浏览器为了取得正确的值，也会触发重排。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()</p>\n<p> 所以，在多次使用这些值时，应该进行缓存。</p>\n</li>\n</ol>\n<p>开发中减少重排次数和缩小重排范围的方法：</p>\n<ol>\n<li><p>将多次改变样式属性的操作合并为一次操作，也就是将需要改变的的样式写在css中，并给一个类名，在js中只需要改变className即可。</p>\n</li>\n<li><p>需要多次重排的元素，position值最好为absolute或者fix，让它脱离文档流，这样就不会影响其他元素。所以有动画效果的元素最好设置绝对定位。</p>\n</li>\n<li><p>需要增加多个节点，可以一次性构建一个html片段，然后一次性添加到文档中去，而不是循环添加每一行。</p>\n</li>\n<li><p>由于display为none的元素不再渲染树中，对隐藏元素的操作不会引发其他元素的重排。如果要对一个元素进行复杂操作，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。</p>\n</li>\n<li><p>在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。</p>\n</li>\n</ol>\n","excerpt":"<p>前端开发的过程中，我们不仅要实现设计师提供的炫酷设计稿，同时还要考虑到用最好的方式，最优的性能去实现它。为此，我们需要了解浏览器的重绘与重排概念。<br>","more":"<br>首先我们要先了解浏览器从下载文档到显示页面的过程，这里面就包含了重绘与重排。</p>\n<blockquote>\n<p>简单讲，通常在文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了，再根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。</p>\n</blockquote>\n<p>重绘的概念：</p>\n<blockquote>\n<p>重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。</p>\n</blockquote>\n<p>重排（也称作回流）是更明显的一种改变，可以理解为渲染树需要重新计算。</p>\n<p>触发重排的常见情况有三种：</p>\n<ol>\n<li><p>DOM元素的几何属性变化<br>一个DOM元素的几何属性实现改变，会使浏览器重新构建此节点，而且也许会带来相关元素的重排。浏览器会计算相关元素如兄弟元素、子元素的尺寸，进行重新绘制。可见，重排一定会引起浏览器的重绘，一个元素的重排通常带来一系列的反应，性能代价是高昂的。</p>\n</li>\n<li><p>DOM树的结构变化<br> 当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。浏览器的布局过程类似于树的前序遍历，是一个从从上到下从左到右的过程。所以，如果在Body最前面插入一个元素，会导致整个文档树的重排，而在最后插入元素，不会影响前面的元素。</p>\n</li>\n<li><p>获取某些属性<br> 当获取某些属性时，浏览器为了取得正确的值，也会触发重排。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()</p>\n<p> 所以，在多次使用这些值时，应该进行缓存。</p>\n</li>\n</ol>\n<p>开发中减少重排次数和缩小重排范围的方法：</p>\n<ol>\n<li><p>将多次改变样式属性的操作合并为一次操作，也就是将需要改变的的样式写在css中，并给一个类名，在js中只需要改变className即可。</p>\n</li>\n<li><p>需要多次重排的元素，position值最好为absolute或者fix，让它脱离文档流，这样就不会影响其他元素。所以有动画效果的元素最好设置绝对定位。</p>\n</li>\n<li><p>需要增加多个节点，可以一次性构建一个html片段，然后一次性添加到文档中去，而不是循环添加每一行。</p>\n</li>\n<li><p>由于display为none的元素不再渲染树中，对隐藏元素的操作不会引发其他元素的重排。如果要对一个元素进行复杂操作，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。</p>\n</li>\n<li><p>在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。</p>\n</li>\n</ol>"},{"title":"用js原生实现Ajax的get和post","date":"2015-08-18T02:17:50.000Z","_content":"\n虽然jquery的ajax挺方便，但是了解了原生实现的原理也是很不错的。而且封装好的原生Js Ajax用起来也挺方便的~ XD~\n<!--more-->\n\n#### 参数序列化函数\n```javascript\nfunction serialize (data) {//将参数序列化\n    if (!data) return '';\n    var pairs = [];\n    for (var name in data){\n        if (!data.hasOwnerProperty(name)) continue;\n        if (typeof data[name] === 'function') continue;\n        var value = data[name].toString();\n        name = uncodeURIComponent(name);\n        value = uncodeURIComponent(value);\n        pairs.push(name + '=' + value);\n  }\n  return pairs.join('&');\n}\n```\n#### 原生封装Ajax的get方法\n```javascript\n  function get(url,options,callback){\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function (){\n        if (xhr.readyState == 4) {\n              if ((xhr.status > 200 && xhr.status < 300) || xhr.status == 304) {\n                callback(xhr.responseText);\n            }else {\n                alert(\"request failed : \" + xhr.status);\n            }\n        };\n    }\n    xhr.open(\"get\",url + \"?\" + serialize(options),true);\n    xhr.send(null);//get 不将数据作为参数传入\n    }\n```\n***调用方式***：\n```javascript\n  get(url,json,function(data){\n  console.log('data');\n  //如果data为json对象，需要JSON.parse(data)解析之后才可以用\n  })\n```\n\n#### 原生封装Ajax的post方法\n```javascript\n  function post(url, options, callback) {\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function(callback) {\n          if(xhr.readyState == 4) {\n            if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n                  callback(xhr.responseText);\n            }else {\n                alert('request failed!' + xhr.status);\n              }\n        }\n      }\n      xhr.open('post', url, true);\n      xhr.send(serialize(options));\n    }\n      \n  //用法：getCookie(\"loginSuc\");\n```\n","source":"_posts/用js原生实现Ajax的get和post.md","raw":"title: 用js原生实现Ajax的get和post\ndate: 2015-08-18 10:17:50\ntags: Javascript学习笔记\n\n---\n\n虽然jquery的ajax挺方便，但是了解了原生实现的原理也是很不错的。而且封装好的原生Js Ajax用起来也挺方便的~ XD~\n<!--more-->\n\n#### 参数序列化函数\n```javascript\nfunction serialize (data) {//将参数序列化\n    if (!data) return '';\n    var pairs = [];\n    for (var name in data){\n        if (!data.hasOwnerProperty(name)) continue;\n        if (typeof data[name] === 'function') continue;\n        var value = data[name].toString();\n        name = uncodeURIComponent(name);\n        value = uncodeURIComponent(value);\n        pairs.push(name + '=' + value);\n  }\n  return pairs.join('&');\n}\n```\n#### 原生封装Ajax的get方法\n```javascript\n  function get(url,options,callback){\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function (){\n        if (xhr.readyState == 4) {\n              if ((xhr.status > 200 && xhr.status < 300) || xhr.status == 304) {\n                callback(xhr.responseText);\n            }else {\n                alert(\"request failed : \" + xhr.status);\n            }\n        };\n    }\n    xhr.open(\"get\",url + \"?\" + serialize(options),true);\n    xhr.send(null);//get 不将数据作为参数传入\n    }\n```\n***调用方式***：\n```javascript\n  get(url,json,function(data){\n  console.log('data');\n  //如果data为json对象，需要JSON.parse(data)解析之后才可以用\n  })\n```\n\n#### 原生封装Ajax的post方法\n```javascript\n  function post(url, options, callback) {\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function(callback) {\n          if(xhr.readyState == 4) {\n            if((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n                  callback(xhr.responseText);\n            }else {\n                alert('request failed!' + xhr.status);\n              }\n        }\n      }\n      xhr.open('post', url, true);\n      xhr.send(serialize(options));\n    }\n      \n  //用法：getCookie(\"loginSuc\");\n```\n","slug":"用js原生实现Ajax的get和post","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489eyu001uer2z6xjdvdn9","content":"<p>虽然jquery的ajax挺方便，但是了解了原生实现的原理也是很不错的。而且封装好的原生Js Ajax用起来也挺方便的~ XD~<br><a id=\"more\"></a></p>\n<h4 id=\"参数序列化函数\">参数序列化函数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">serialize</span> (<span class=\"params\">data</span>) </span>&#123;<span class=\"comment\">//将参数序列化</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!data) <span class=\"keyword\">return</span> <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> pairs = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> name <span class=\"keyword\">in</span> data)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!data.hasOwnerProperty(name)) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> data[name] === <span class=\"string\">'function'</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> value = data[name].toString();</div><div class=\"line\">        name = uncodeURIComponent(name);</div><div class=\"line\">        value = uncodeURIComponent(value);</div><div class=\"line\">        pairs.push(name + <span class=\"string\">'='</span> + value);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> pairs.join(<span class=\"string\">'&amp;'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"原生封装Ajax的get方法\">原生封装Ajax的get方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\">url,options,callback</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">    xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (xhr.readyState == <span class=\"number\">4</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((xhr.status &gt; <span class=\"number\">200</span> &amp;&amp; xhr.status &lt; <span class=\"number\">300</span>) || xhr.status == <span class=\"number\">304</span>) &#123;</div><div class=\"line\">              callback(xhr.responseText);</div><div class=\"line\">          &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              alert(<span class=\"string\">\"request failed : \"</span> + xhr.status);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  xhr.open(<span class=\"string\">\"get\"</span>,url + <span class=\"string\">\"?\"</span> + serialize(options),<span class=\"literal\">true</span>);</div><div class=\"line\">  xhr.send(<span class=\"literal\">null</span>);<span class=\"comment\">//get 不将数据作为参数传入</span></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p><strong><em>调用方式</em></strong>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">get(url,json,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'data'</span>);</div><div class=\"line\"><span class=\"comment\">//如果data为json对象，需要JSON.parse(data)解析之后才可以用</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h4 id=\"原生封装Ajax的post方法\">原生封装Ajax的post方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post</span>(<span class=\"params\">url, options, callback</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">    xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(xhr.readyState == <span class=\"number\">4</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>((xhr.status &gt;= <span class=\"number\">200</span> &amp;&amp; xhr.status &lt; <span class=\"number\">300</span>) || xhr.status == <span class=\"number\">304</span>) &#123;</div><div class=\"line\">                callback(xhr.responseText);</div><div class=\"line\">          &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              alert(<span class=\"string\">'request failed!'</span> + xhr.status);</div><div class=\"line\">            &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    xhr.open(<span class=\"string\">'post'</span>, url, <span class=\"literal\">true</span>);</div><div class=\"line\">    xhr.send(serialize(options));</div><div class=\"line\">  &#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//用法：getCookie(\"loginSuc\");</span></div></pre></td></tr></table></figure>\n","excerpt":"<p>虽然jquery的ajax挺方便，但是了解了原生实现的原理也是很不错的。而且封装好的原生Js Ajax用起来也挺方便的~ XD~<br>","more":"</p>\n<h4 id=\"参数序列化函数\">参数序列化函数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">serialize</span> (<span class=\"params\">data</span>) </span>&#123;<span class=\"comment\">//将参数序列化</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!data) <span class=\"keyword\">return</span> <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> pairs = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> name <span class=\"keyword\">in</span> data)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!data.hasOwnerProperty(name)) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> data[name] === <span class=\"string\">'function'</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> value = data[name].toString();</div><div class=\"line\">        name = uncodeURIComponent(name);</div><div class=\"line\">        value = uncodeURIComponent(value);</div><div class=\"line\">        pairs.push(name + <span class=\"string\">'='</span> + value);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> pairs.join(<span class=\"string\">'&amp;'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"原生封装Ajax的get方法\">原生封装Ajax的get方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\">url,options,callback</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">    xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (xhr.readyState == <span class=\"number\">4</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((xhr.status &gt; <span class=\"number\">200</span> &amp;&amp; xhr.status &lt; <span class=\"number\">300</span>) || xhr.status == <span class=\"number\">304</span>) &#123;</div><div class=\"line\">              callback(xhr.responseText);</div><div class=\"line\">          &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              alert(<span class=\"string\">\"request failed : \"</span> + xhr.status);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  xhr.open(<span class=\"string\">\"get\"</span>,url + <span class=\"string\">\"?\"</span> + serialize(options),<span class=\"literal\">true</span>);</div><div class=\"line\">  xhr.send(<span class=\"literal\">null</span>);<span class=\"comment\">//get 不将数据作为参数传入</span></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p><strong><em>调用方式</em></strong>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">get(url,json,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'data'</span>);</div><div class=\"line\"><span class=\"comment\">//如果data为json对象，需要JSON.parse(data)解析之后才可以用</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h4 id=\"原生封装Ajax的post方法\">原生封装Ajax的post方法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post</span>(<span class=\"params\">url, options, callback</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\">    xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(xhr.readyState == <span class=\"number\">4</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span>((xhr.status &gt;= <span class=\"number\">200</span> &amp;&amp; xhr.status &lt; <span class=\"number\">300</span>) || xhr.status == <span class=\"number\">304</span>) &#123;</div><div class=\"line\">                callback(xhr.responseText);</div><div class=\"line\">          &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              alert(<span class=\"string\">'request failed!'</span> + xhr.status);</div><div class=\"line\">            &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    xhr.open(<span class=\"string\">'post'</span>, url, <span class=\"literal\">true</span>);</div><div class=\"line\">    xhr.send(serialize(options));</div><div class=\"line\">  &#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//用法：getCookie(\"loginSuc\");</span></div></pre></td></tr></table></figure>"},{"title":"Array类型对象的一些常用方法","date":"2015-11-20T02:10:50.000Z","_content":"\nAarry类型是js中很常见的类型，Js原生就给了它一些很方便的方法供我们使用，不需要我们去实现。现在我们来总结一下这些常用的方法。\n<!-- more -->\n** splice() **\n\n第一个介绍的是最强大的数组方法`splice()`，它既可以用于插入数组项，还能用于删除和替换。\n`splice()`方法接受参数，第一个参数是删除数组项的起始位置，第二个参数是删除数组项个数，后面的参数是在删除后添加的数组项内容。\n`splice()`返回的是从原始数组中删除的数组项，若没有删除，则返回空数组。\n\n删除：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(0,2); //返回[\"red\",\"blue\"]，此时colors 为[\"black\",\"green\",\"white\"]\n```\n插入：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(2,0,\"aaa\",\"bbb\"); //返回空数组，此时colors 为[\"red\", \"blue\", \"aaa\", \"bbb\", \"black\", \"green\", \"white\"]\n```\n替换：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(2,1,\"aaa\"); //返回[\"black\"], 此时colors为[\"red\", \"blue\",\"aaa\", \"green\", \"white\"]\n```\n** toString() 与 valueOf() **\n\n调用数组的`toString()`方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用数组的`valueOf()`方法返回的还是数组。\n例：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.toString(); //\"red,blue,black\"\n    colors.valueOf(); //[\"red\", \"blue\", \"black\"] \n```\n** join() **\n\n数组继承的toString()、valueOf()方法，在默认情况下逗号以逗号分隔字符串的形式返回，而如果使用`join()`方法，则可以使用不同的分隔符来构建这个字符串。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.join(\",\"); //\"red,blue,black\"\n    colors.join(\"|\"); //\"red|blue|black\"\n    colors.join(\"\");//\"redblueblack\"\n```\n** push() 和 unshift() **\n\n这两个方法的功能刚好相反。\n`push()`方法可以接受任意数量的参数，把它们逐个添加到数组**末尾**，并返回新数组长度。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.push(\"aaa\",\"bbb\"); //返回5\n    alert(colors);  //[\"red\", \"blue\", \"black\", \"aaa\", \"bbb\"]\n```\n`unshift()`方法可以接受任意数量的参数，把它们逐个添加到数组**前端**，并返回新数组长度。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.push(\"aaa\",\"bbb\"); //返回5\n    alert(colors);  //[\"aaa\", \"bbb\",\"red\", \"blue\", \"black\"]\n```\n** pop() 和 shift() **\n\n这两个方法的功能也是相反的\n`pop()`方法从数组末尾移除**最后一项**，减少数组的length值，然后返回移除的项。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.pop(); //返回 \"black\"\n```\n`shift()`方法从数组末尾移除**第一项**，减少数组的length值，然后返回移除的项。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.pop(); //返回 \"red\"\n```\n我们可以结合push()和pop()方法，实现类似**栈**的LIFO(Last-in-First-out)后进先出。\n也可以结合unshift()和shift()方法，实现类似**队列**的FIFO(First-in-First-out)先进先出。\n\n** reverse() 与 sort() **\n\n`reverse()`方法会反转数组项的顺序,返回经过排序后的数组。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.reverse(); //返回[\"black\", \"blue\", \"red\"]\n```\n`sort()`方法按升序排列数组项，但是由于它其实是先调用数组项的`toString()`方法，然后比较的是字符串，所以如果需要比较数字大小的时候，建议给其传一个比较函数。\n```javascript\n    function compare(value1,value2){ //按升序\n       return value1-value2;\n    }\n    var values = [0,1,33,12,4];\n    values.sort(compare);// [0, 1, 4, 12, 33]\n```\n** slice() **\n`slice()`方法能够给予当前数组中的一或多个项创建一个新数组。slice()方法可接受一或两个参数，即要返回项的起始和结束位置。\n在只有一个参数的情况下，slice()方法返回从参数指定位置到当前数组末尾的所有项。\n如果有两个参数，则返回起始和结束位置之间的项——但不包括结束位置的项。 注意,slice()方法不会影响原始数组。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"];\n    colors.slice(1); //[\"blue\", \"black\", \"green\", \"white\"]\n    colors.slice(1,4); //[\"blue\", \"black\", \"green\"]\n```\n","source":"_posts/数组的常用方法.md","raw":"title: Array类型对象的一些常用方法\ndate: 2015-11-20 10:10:50\ntags: Javascript学习笔记\n---\n\nAarry类型是js中很常见的类型，Js原生就给了它一些很方便的方法供我们使用，不需要我们去实现。现在我们来总结一下这些常用的方法。\n<!-- more -->\n** splice() **\n\n第一个介绍的是最强大的数组方法`splice()`，它既可以用于插入数组项，还能用于删除和替换。\n`splice()`方法接受参数，第一个参数是删除数组项的起始位置，第二个参数是删除数组项个数，后面的参数是在删除后添加的数组项内容。\n`splice()`返回的是从原始数组中删除的数组项，若没有删除，则返回空数组。\n\n删除：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(0,2); //返回[\"red\",\"blue\"]，此时colors 为[\"black\",\"green\",\"white\"]\n```\n插入：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(2,0,\"aaa\",\"bbb\"); //返回空数组，此时colors 为[\"red\", \"blue\", \"aaa\", \"bbb\", \"black\", \"green\", \"white\"]\n```\n替换：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"]; \n    colors.splice(2,1,\"aaa\"); //返回[\"black\"], 此时colors为[\"red\", \"blue\",\"aaa\", \"green\", \"white\"]\n```\n** toString() 与 valueOf() **\n\n调用数组的`toString()`方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用数组的`valueOf()`方法返回的还是数组。\n例：\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.toString(); //\"red,blue,black\"\n    colors.valueOf(); //[\"red\", \"blue\", \"black\"] \n```\n** join() **\n\n数组继承的toString()、valueOf()方法，在默认情况下逗号以逗号分隔字符串的形式返回，而如果使用`join()`方法，则可以使用不同的分隔符来构建这个字符串。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.join(\",\"); //\"red,blue,black\"\n    colors.join(\"|\"); //\"red|blue|black\"\n    colors.join(\"\");//\"redblueblack\"\n```\n** push() 和 unshift() **\n\n这两个方法的功能刚好相反。\n`push()`方法可以接受任意数量的参数，把它们逐个添加到数组**末尾**，并返回新数组长度。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.push(\"aaa\",\"bbb\"); //返回5\n    alert(colors);  //[\"red\", \"blue\", \"black\", \"aaa\", \"bbb\"]\n```\n`unshift()`方法可以接受任意数量的参数，把它们逐个添加到数组**前端**，并返回新数组长度。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.push(\"aaa\",\"bbb\"); //返回5\n    alert(colors);  //[\"aaa\", \"bbb\",\"red\", \"blue\", \"black\"]\n```\n** pop() 和 shift() **\n\n这两个方法的功能也是相反的\n`pop()`方法从数组末尾移除**最后一项**，减少数组的length值，然后返回移除的项。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.pop(); //返回 \"black\"\n```\n`shift()`方法从数组末尾移除**第一项**，减少数组的length值，然后返回移除的项。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.pop(); //返回 \"red\"\n```\n我们可以结合push()和pop()方法，实现类似**栈**的LIFO(Last-in-First-out)后进先出。\n也可以结合unshift()和shift()方法，实现类似**队列**的FIFO(First-in-First-out)先进先出。\n\n** reverse() 与 sort() **\n\n`reverse()`方法会反转数组项的顺序,返回经过排序后的数组。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\"];\n    colors.reverse(); //返回[\"black\", \"blue\", \"red\"]\n```\n`sort()`方法按升序排列数组项，但是由于它其实是先调用数组项的`toString()`方法，然后比较的是字符串，所以如果需要比较数字大小的时候，建议给其传一个比较函数。\n```javascript\n    function compare(value1,value2){ //按升序\n       return value1-value2;\n    }\n    var values = [0,1,33,12,4];\n    values.sort(compare);// [0, 1, 4, 12, 33]\n```\n** slice() **\n`slice()`方法能够给予当前数组中的一或多个项创建一个新数组。slice()方法可接受一或两个参数，即要返回项的起始和结束位置。\n在只有一个参数的情况下，slice()方法返回从参数指定位置到当前数组末尾的所有项。\n如果有两个参数，则返回起始和结束位置之间的项——但不包括结束位置的项。 注意,slice()方法不会影响原始数组。\n```javascript\n    var colors = [\"red\",\"blue\",\"black\",\"green\",\"white\"];\n    colors.slice(1); //[\"blue\", \"black\", \"green\", \"white\"]\n    colors.slice(1,4); //[\"blue\", \"black\", \"green\"]\n```\n","slug":"数组的常用方法","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489eyv001wer2z1tit21jw","content":"<p>Aarry类型是js中很常见的类型，Js原生就给了它一些很方便的方法供我们使用，不需要我们去实现。现在我们来总结一下这些常用的方法。<br><a id=\"more\"></a><br><strong> splice() </strong></p>\n<p>第一个介绍的是最强大的数组方法<code>splice()</code>，它既可以用于插入数组项，还能用于删除和替换。<br><code>splice()</code>方法接受参数，第一个参数是删除数组项的起始位置，第二个参数是删除数组项个数，后面的参数是在删除后添加的数组项内容。<br><code>splice()</code>返回的是从原始数组中删除的数组项，若没有删除，则返回空数组。</p>\n<p>删除：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"white\"</span>]; </div><div class=\"line\">colors.splice(<span class=\"number\">0</span>,<span class=\"number\">2</span>); <span class=\"comment\">//返回[\"red\",\"blue\"]，此时colors 为[\"black\",\"green\",\"white\"]</span></div></pre></td></tr></table></figure></p>\n<p>插入：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"white\"</span>]; </div><div class=\"line\">colors.splice(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"string\">\"aaa\"</span>,<span class=\"string\">\"bbb\"</span>); <span class=\"comment\">//返回空数组，此时colors 为[\"red\", \"blue\", \"aaa\", \"bbb\", \"black\", \"green\", \"white\"]</span></div></pre></td></tr></table></figure></p>\n<p>替换：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"white\"</span>]; </div><div class=\"line\">colors.splice(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"string\">\"aaa\"</span>); <span class=\"comment\">//返回[\"black\"], 此时colors为[\"red\", \"blue\",\"aaa\", \"green\", \"white\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> toString() 与 valueOf() </strong></p>\n<p>调用数组的<code>toString()</code>方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用数组的<code>valueOf()</code>方法返回的还是数组。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.toString(); <span class=\"comment\">//\"red,blue,black\"</span></div><div class=\"line\">colors.valueOf(); <span class=\"comment\">//[\"red\", \"blue\", \"black\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> join() </strong></p>\n<p>数组继承的toString()、valueOf()方法，在默认情况下逗号以逗号分隔字符串的形式返回，而如果使用<code>join()</code>方法，则可以使用不同的分隔符来构建这个字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.join(<span class=\"string\">\",\"</span>); <span class=\"comment\">//\"red,blue,black\"</span></div><div class=\"line\">colors.join(<span class=\"string\">\"|\"</span>); <span class=\"comment\">//\"red|blue|black\"</span></div><div class=\"line\">colors.join(<span class=\"string\">\"\"</span>);<span class=\"comment\">//\"redblueblack\"</span></div></pre></td></tr></table></figure></p>\n<p><strong> push() 和 unshift() </strong></p>\n<p>这两个方法的功能刚好相反。<br><code>push()</code>方法可以接受任意数量的参数，把它们逐个添加到数组<strong>末尾</strong>，并返回新数组长度。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.push(<span class=\"string\">\"aaa\"</span>,<span class=\"string\">\"bbb\"</span>); <span class=\"comment\">//返回5</span></div><div class=\"line\">alert(colors);  <span class=\"comment\">//[\"red\", \"blue\", \"black\", \"aaa\", \"bbb\"]</span></div></pre></td></tr></table></figure></p>\n<p><code>unshift()</code>方法可以接受任意数量的参数，把它们逐个添加到数组<strong>前端</strong>，并返回新数组长度。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.push(<span class=\"string\">\"aaa\"</span>,<span class=\"string\">\"bbb\"</span>); <span class=\"comment\">//返回5</span></div><div class=\"line\">alert(colors);  <span class=\"comment\">//[\"aaa\", \"bbb\",\"red\", \"blue\", \"black\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> pop() 和 shift() </strong></p>\n<p>这两个方法的功能也是相反的<br><code>pop()</code>方法从数组末尾移除<strong>最后一项</strong>，减少数组的length值，然后返回移除的项。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.pop(); <span class=\"comment\">//返回 \"black\"</span></div></pre></td></tr></table></figure></p>\n<p><code>shift()</code>方法从数组末尾移除<strong>第一项</strong>，减少数组的length值，然后返回移除的项。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.pop(); <span class=\"comment\">//返回 \"red\"</span></div></pre></td></tr></table></figure></p>\n<p>我们可以结合push()和pop()方法，实现类似<strong>栈</strong>的LIFO(Last-in-First-out)后进先出。<br>也可以结合unshift()和shift()方法，实现类似<strong>队列</strong>的FIFO(First-in-First-out)先进先出。</p>\n<p><strong> reverse() 与 sort() </strong></p>\n<p><code>reverse()</code>方法会反转数组项的顺序,返回经过排序后的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.reverse(); <span class=\"comment\">//返回[\"black\", \"blue\", \"red\"]</span></div></pre></td></tr></table></figure></p>\n<p><code>sort()</code>方法按升序排列数组项，但是由于它其实是先调用数组项的<code>toString()</code>方法，然后比较的是字符串，所以如果需要比较数字大小的时候，建议给其传一个比较函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1,value2</span>)</span>&#123; <span class=\"comment\">//按升序</span></div><div class=\"line\">   <span class=\"keyword\">return</span> value1-value2;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">33</span>,<span class=\"number\">12</span>,<span class=\"number\">4</span>];</div><div class=\"line\">values.sort(compare);<span class=\"comment\">// [0, 1, 4, 12, 33]</span></div></pre></td></tr></table></figure></p>\n<p><strong> slice() </strong><br><code>slice()</code>方法能够给予当前数组中的一或多个项创建一个新数组。slice()方法可接受一或两个参数，即要返回项的起始和结束位置。<br>在只有一个参数的情况下，slice()方法返回从参数指定位置到当前数组末尾的所有项。<br>如果有两个参数，则返回起始和结束位置之间的项——但不包括结束位置的项。 注意,slice()方法不会影响原始数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"white\"</span>];</div><div class=\"line\">colors.slice(<span class=\"number\">1</span>); <span class=\"comment\">//[\"blue\", \"black\", \"green\", \"white\"]</span></div><div class=\"line\">colors.slice(<span class=\"number\">1</span>,<span class=\"number\">4</span>); <span class=\"comment\">//[\"blue\", \"black\", \"green\"]</span></div></pre></td></tr></table></figure></p>\n","excerpt":"<p>Aarry类型是js中很常见的类型，Js原生就给了它一些很方便的方法供我们使用，不需要我们去实现。现在我们来总结一下这些常用的方法。<br>","more":"<br><strong> splice() </strong></p>\n<p>第一个介绍的是最强大的数组方法<code>splice()</code>，它既可以用于插入数组项，还能用于删除和替换。<br><code>splice()</code>方法接受参数，第一个参数是删除数组项的起始位置，第二个参数是删除数组项个数，后面的参数是在删除后添加的数组项内容。<br><code>splice()</code>返回的是从原始数组中删除的数组项，若没有删除，则返回空数组。</p>\n<p>删除：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"white\"</span>]; </div><div class=\"line\">colors.splice(<span class=\"number\">0</span>,<span class=\"number\">2</span>); <span class=\"comment\">//返回[\"red\",\"blue\"]，此时colors 为[\"black\",\"green\",\"white\"]</span></div></pre></td></tr></table></figure></p>\n<p>插入：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"white\"</span>]; </div><div class=\"line\">colors.splice(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"string\">\"aaa\"</span>,<span class=\"string\">\"bbb\"</span>); <span class=\"comment\">//返回空数组，此时colors 为[\"red\", \"blue\", \"aaa\", \"bbb\", \"black\", \"green\", \"white\"]</span></div></pre></td></tr></table></figure></p>\n<p>替换：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"white\"</span>]; </div><div class=\"line\">colors.splice(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"string\">\"aaa\"</span>); <span class=\"comment\">//返回[\"black\"], 此时colors为[\"red\", \"blue\",\"aaa\", \"green\", \"white\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> toString() 与 valueOf() </strong></p>\n<p>调用数组的<code>toString()</code>方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用数组的<code>valueOf()</code>方法返回的还是数组。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.toString(); <span class=\"comment\">//\"red,blue,black\"</span></div><div class=\"line\">colors.valueOf(); <span class=\"comment\">//[\"red\", \"blue\", \"black\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> join() </strong></p>\n<p>数组继承的toString()、valueOf()方法，在默认情况下逗号以逗号分隔字符串的形式返回，而如果使用<code>join()</code>方法，则可以使用不同的分隔符来构建这个字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.join(<span class=\"string\">\",\"</span>); <span class=\"comment\">//\"red,blue,black\"</span></div><div class=\"line\">colors.join(<span class=\"string\">\"|\"</span>); <span class=\"comment\">//\"red|blue|black\"</span></div><div class=\"line\">colors.join(<span class=\"string\">\"\"</span>);<span class=\"comment\">//\"redblueblack\"</span></div></pre></td></tr></table></figure></p>\n<p><strong> push() 和 unshift() </strong></p>\n<p>这两个方法的功能刚好相反。<br><code>push()</code>方法可以接受任意数量的参数，把它们逐个添加到数组<strong>末尾</strong>，并返回新数组长度。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.push(<span class=\"string\">\"aaa\"</span>,<span class=\"string\">\"bbb\"</span>); <span class=\"comment\">//返回5</span></div><div class=\"line\">alert(colors);  <span class=\"comment\">//[\"red\", \"blue\", \"black\", \"aaa\", \"bbb\"]</span></div></pre></td></tr></table></figure></p>\n<p><code>unshift()</code>方法可以接受任意数量的参数，把它们逐个添加到数组<strong>前端</strong>，并返回新数组长度。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.push(<span class=\"string\">\"aaa\"</span>,<span class=\"string\">\"bbb\"</span>); <span class=\"comment\">//返回5</span></div><div class=\"line\">alert(colors);  <span class=\"comment\">//[\"aaa\", \"bbb\",\"red\", \"blue\", \"black\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> pop() 和 shift() </strong></p>\n<p>这两个方法的功能也是相反的<br><code>pop()</code>方法从数组末尾移除<strong>最后一项</strong>，减少数组的length值，然后返回移除的项。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.pop(); <span class=\"comment\">//返回 \"black\"</span></div></pre></td></tr></table></figure></p>\n<p><code>shift()</code>方法从数组末尾移除<strong>第一项</strong>，减少数组的length值，然后返回移除的项。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.pop(); <span class=\"comment\">//返回 \"red\"</span></div></pre></td></tr></table></figure></p>\n<p>我们可以结合push()和pop()方法，实现类似<strong>栈</strong>的LIFO(Last-in-First-out)后进先出。<br>也可以结合unshift()和shift()方法，实现类似<strong>队列</strong>的FIFO(First-in-First-out)先进先出。</p>\n<p><strong> reverse() 与 sort() </strong></p>\n<p><code>reverse()</code>方法会反转数组项的顺序,返回经过排序后的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>];</div><div class=\"line\">colors.reverse(); <span class=\"comment\">//返回[\"black\", \"blue\", \"red\"]</span></div></pre></td></tr></table></figure></p>\n<p><code>sort()</code>方法按升序排列数组项，但是由于它其实是先调用数组项的<code>toString()</code>方法，然后比较的是字符串，所以如果需要比较数字大小的时候，建议给其传一个比较函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1,value2</span>)</span>&#123; <span class=\"comment\">//按升序</span></div><div class=\"line\">   <span class=\"keyword\">return</span> value1-value2;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">33</span>,<span class=\"number\">12</span>,<span class=\"number\">4</span>];</div><div class=\"line\">values.sort(compare);<span class=\"comment\">// [0, 1, 4, 12, 33]</span></div></pre></td></tr></table></figure></p>\n<p><strong> slice() </strong><br><code>slice()</code>方法能够给予当前数组中的一或多个项创建一个新数组。slice()方法可接受一或两个参数，即要返回项的起始和结束位置。<br>在只有一个参数的情况下，slice()方法返回从参数指定位置到当前数组末尾的所有项。<br>如果有两个参数，则返回起始和结束位置之间的项——但不包括结束位置的项。 注意,slice()方法不会影响原始数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> colors = [<span class=\"string\">\"red\"</span>,<span class=\"string\">\"blue\"</span>,<span class=\"string\">\"black\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"white\"</span>];</div><div class=\"line\">colors.slice(<span class=\"number\">1</span>); <span class=\"comment\">//[\"blue\", \"black\", \"green\", \"white\"]</span></div><div class=\"line\">colors.slice(<span class=\"number\">1</span>,<span class=\"number\">4</span>); <span class=\"comment\">//[\"blue\", \"black\", \"green\"]</span></div></pre></td></tr></table></figure></p>"},{"title":"好玩的cookie","date":"2015-07-25T02:17:50.000Z","_content":"最近接触了cookie，发现浏览器cookie真的挺好玩的，前端做的事也可以在网页关闭或刷新后依然存在，多难得啊（被用户清除了cookie就没办法了...）。cookie可以帮助前端实现一些用户行为储存，进而实现一些针对用户的操作。\n<!--more-->\ncookie的增删查改也并不难，但是有一些细节还是得注意。\n\n***cookie的设置/修改封装函数***\n\n1. 直接也可以设置:`document.cookie= 'name=value'`;\n2. 更推荐封装函数：\n```javascript\n// 设置expires\n// var date=new Date(); \n// var expiresDays=10; \n// 将date设置为10天以后的时间 \n// date.setTime(date.getTime()+expiresDays*24*3600*1000); \nfunction setCookie(name,value,expires,path,domain,secure){\n    var cookie = encodeURIComponent(name) + '=' +encodeURIComponent(value);\n    if(expires){\n        cookie += ';expires=' + expires.toGMTString();//失效时间\n    }\n    if(path){\n        cookie += ';path=' +path;\n    }\n    if(domain){\n        cookie +=';secure' + secure;//http协议时生效，默认false\n    }\n    document.cookie = cookie;\n\n    //用法：set(\"loginSuc\",\"yes\",date,path,domain,secure)\n}\n```\n\n***cookie的获取封装函数***\n\n```javascript\n   String.prototype.trim=function(){//去除字符串两端空格\n      return this.replace(/(^\\s*)|(\\s*$)/g, ”); \n     }\n   function getcookie(Name) {\n       var cookie = {};\n       var all = document.cookie;\n      if (all === '')\n           return cookie;\n       var list = all.split('; ');\n       for (var i = 0; i < list.length; i++) {\n           var item = list[i];\n           var p = item.indexOf('=');\n           var name = item.substring(0, p);\n           name = decodeURIComponent(name).trim();//注意这里有个坑，除了第一个name，后面的name前面都有一个空格，所以要处理掉前面的空格才行；\n           var value = item.substring(p + 1);\n           value = decodeURIComponent(value);\n           cookie[name] = value;\n       }\n       return cookie[Name];\n   }\n//用法：getCookie(\"loginSuc\");\n```\n***cookie的删除函数封装***\n```javascript\n    function removeCookie(name) { \n        var exp = new Date(); \n        exp.setTime(exp.getTime() - 1); \n        var cval=getCookie(name); \n        if(cval!=null) document.cookie= name + \"=\"+cval+\";expires=\"+exp.toGMTString(); \n    } \n```\n\n使用cookie我们可以设置用户的登录状态，亦或是点击了不再显示后就设置一个不再显示的cookie,通过获取cookie来达到效果。感觉棒棒哒！","source":"_posts/好玩的cookie.md","raw":"title: 好玩的cookie\ndate: 2015-07-25 10:17:50\ntags: Javascript学习笔记\n\n---\n最近接触了cookie，发现浏览器cookie真的挺好玩的，前端做的事也可以在网页关闭或刷新后依然存在，多难得啊（被用户清除了cookie就没办法了...）。cookie可以帮助前端实现一些用户行为储存，进而实现一些针对用户的操作。\n<!--more-->\ncookie的增删查改也并不难，但是有一些细节还是得注意。\n\n***cookie的设置/修改封装函数***\n\n1. 直接也可以设置:`document.cookie= 'name=value'`;\n2. 更推荐封装函数：\n```javascript\n// 设置expires\n// var date=new Date(); \n// var expiresDays=10; \n// 将date设置为10天以后的时间 \n// date.setTime(date.getTime()+expiresDays*24*3600*1000); \nfunction setCookie(name,value,expires,path,domain,secure){\n    var cookie = encodeURIComponent(name) + '=' +encodeURIComponent(value);\n    if(expires){\n        cookie += ';expires=' + expires.toGMTString();//失效时间\n    }\n    if(path){\n        cookie += ';path=' +path;\n    }\n    if(domain){\n        cookie +=';secure' + secure;//http协议时生效，默认false\n    }\n    document.cookie = cookie;\n\n    //用法：set(\"loginSuc\",\"yes\",date,path,domain,secure)\n}\n```\n\n***cookie的获取封装函数***\n\n```javascript\n   String.prototype.trim=function(){//去除字符串两端空格\n      return this.replace(/(^\\s*)|(\\s*$)/g, ”); \n     }\n   function getcookie(Name) {\n       var cookie = {};\n       var all = document.cookie;\n      if (all === '')\n           return cookie;\n       var list = all.split('; ');\n       for (var i = 0; i < list.length; i++) {\n           var item = list[i];\n           var p = item.indexOf('=');\n           var name = item.substring(0, p);\n           name = decodeURIComponent(name).trim();//注意这里有个坑，除了第一个name，后面的name前面都有一个空格，所以要处理掉前面的空格才行；\n           var value = item.substring(p + 1);\n           value = decodeURIComponent(value);\n           cookie[name] = value;\n       }\n       return cookie[Name];\n   }\n//用法：getCookie(\"loginSuc\");\n```\n***cookie的删除函数封装***\n```javascript\n    function removeCookie(name) { \n        var exp = new Date(); \n        exp.setTime(exp.getTime() - 1); \n        var cval=getCookie(name); \n        if(cval!=null) document.cookie= name + \"=\"+cval+\";expires=\"+exp.toGMTString(); \n    } \n```\n\n使用cookie我们可以设置用户的登录状态，亦或是点击了不再显示后就设置一个不再显示的cookie,通过获取cookie来达到效果。感觉棒棒哒！","slug":"好玩的cookie","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ez2001zer2zyp2c9rkc","content":"<p>最近接触了cookie，发现浏览器cookie真的挺好玩的，前端做的事也可以在网页关闭或刷新后依然存在，多难得啊（被用户清除了cookie就没办法了…）。cookie可以帮助前端实现一些用户行为储存，进而实现一些针对用户的操作。<br><a id=\"more\"></a><br>cookie的增删查改也并不难，但是有一些细节还是得注意。</p>\n<p><strong><em>cookie的设置/修改封装函数</em></strong></p>\n<ol>\n<li>直接也可以设置:<code>document.cookie= &#39;name=value&#39;</code>;</li>\n<li>更推荐封装函数：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 设置expires</span></div><div class=\"line\"><span class=\"comment\">// var date=new Date(); </span></div><div class=\"line\"><span class=\"comment\">// var expiresDays=10; </span></div><div class=\"line\"><span class=\"comment\">// 将date设置为10天以后的时间 </span></div><div class=\"line\"><span class=\"comment\">// date.setTime(date.getTime()+expiresDays*24*3600*1000); </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setCookie</span>(<span class=\"params\">name,value,expires,path,domain,secure</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> cookie = <span class=\"built_in\">encodeURIComponent</span>(name) + <span class=\"string\">'='</span> +<span class=\"built_in\">encodeURIComponent</span>(value);</div><div class=\"line\">    <span class=\"keyword\">if</span>(expires)&#123;</div><div class=\"line\">        cookie += <span class=\"string\">';expires='</span> + expires.toGMTString();<span class=\"comment\">//失效时间</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(path)&#123;</div><div class=\"line\">        cookie += <span class=\"string\">';path='</span> +path;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(domain)&#123;</div><div class=\"line\">        cookie +=<span class=\"string\">';secure'</span> + secure;<span class=\"comment\">//http协议时生效，默认false</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">document</span>.cookie = cookie;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//用法：set(\"loginSuc\",\"yes\",date,path,domain,secure)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong><em>cookie的获取封装函数</em></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"built_in\">String</span>.prototype.trim=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//去除字符串两端空格</span></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.replace(<span class=\"regexp\">/(^\\s*)|(\\s*$)/g</span>, ”); </div><div class=\"line\">     &#125;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getcookie</span>(<span class=\"params\">Name</span>) </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">var</span> cookie = &#123;&#125;;</div><div class=\"line\">       <span class=\"keyword\">var</span> all = <span class=\"built_in\">document</span>.cookie;</div><div class=\"line\">      <span class=\"keyword\">if</span> (all === <span class=\"string\">''</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> cookie;</div><div class=\"line\">       <span class=\"keyword\">var</span> list = all.split(<span class=\"string\">'; '</span>);</div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; list.length; i++) &#123;</div><div class=\"line\">           <span class=\"keyword\">var</span> item = list[i];</div><div class=\"line\">           <span class=\"keyword\">var</span> p = item.indexOf(<span class=\"string\">'='</span>);</div><div class=\"line\">           <span class=\"keyword\">var</span> name = item.substring(<span class=\"number\">0</span>, p);</div><div class=\"line\">           name = <span class=\"built_in\">decodeURIComponent</span>(name).trim();<span class=\"comment\">//注意这里有个坑，除了第一个name，后面的name前面都有一个空格，所以要处理掉前面的空格才行；</span></div><div class=\"line\">           <span class=\"keyword\">var</span> value = item.substring(p + <span class=\"number\">1</span>);</div><div class=\"line\">           value = <span class=\"built_in\">decodeURIComponent</span>(value);</div><div class=\"line\">           cookie[name] = value;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> cookie[Name];</div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"comment\">//用法：getCookie(\"loginSuc\");</span></div></pre></td></tr></table></figure>\n<p><strong><em>cookie的删除函数封装</em></strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeCookie</span>(<span class=\"params\">name</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">var</span> exp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); </div><div class=\"line\">    exp.setTime(exp.getTime() - <span class=\"number\">1</span>); </div><div class=\"line\">    <span class=\"keyword\">var</span> cval=getCookie(name); </div><div class=\"line\">    <span class=\"keyword\">if</span>(cval!=<span class=\"literal\">null</span>) <span class=\"built_in\">document</span>.cookie= name + <span class=\"string\">\"=\"</span>+cval+<span class=\"string\">\";expires=\"</span>+exp.toGMTString(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用cookie我们可以设置用户的登录状态，亦或是点击了不再显示后就设置一个不再显示的cookie,通过获取cookie来达到效果。感觉棒棒哒！</p>\n","excerpt":"<p>最近接触了cookie，发现浏览器cookie真的挺好玩的，前端做的事也可以在网页关闭或刷新后依然存在，多难得啊（被用户清除了cookie就没办法了…）。cookie可以帮助前端实现一些用户行为储存，进而实现一些针对用户的操作。<br>","more":"<br>cookie的增删查改也并不难，但是有一些细节还是得注意。</p>\n<p><strong><em>cookie的设置/修改封装函数</em></strong></p>\n<ol>\n<li>直接也可以设置:<code>document.cookie= &#39;name=value&#39;</code>;</li>\n<li>更推荐封装函数：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 设置expires</span></div><div class=\"line\"><span class=\"comment\">// var date=new Date(); </span></div><div class=\"line\"><span class=\"comment\">// var expiresDays=10; </span></div><div class=\"line\"><span class=\"comment\">// 将date设置为10天以后的时间 </span></div><div class=\"line\"><span class=\"comment\">// date.setTime(date.getTime()+expiresDays*24*3600*1000); </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setCookie</span>(<span class=\"params\">name,value,expires,path,domain,secure</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> cookie = <span class=\"built_in\">encodeURIComponent</span>(name) + <span class=\"string\">'='</span> +<span class=\"built_in\">encodeURIComponent</span>(value);</div><div class=\"line\">    <span class=\"keyword\">if</span>(expires)&#123;</div><div class=\"line\">        cookie += <span class=\"string\">';expires='</span> + expires.toGMTString();<span class=\"comment\">//失效时间</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(path)&#123;</div><div class=\"line\">        cookie += <span class=\"string\">';path='</span> +path;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(domain)&#123;</div><div class=\"line\">        cookie +=<span class=\"string\">';secure'</span> + secure;<span class=\"comment\">//http协议时生效，默认false</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">document</span>.cookie = cookie;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//用法：set(\"loginSuc\",\"yes\",date,path,domain,secure)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong><em>cookie的获取封装函数</em></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"built_in\">String</span>.prototype.trim=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//去除字符串两端空格</span></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.replace(<span class=\"regexp\">/(^\\s*)|(\\s*$)/g</span>, ”); </div><div class=\"line\">     &#125;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getcookie</span>(<span class=\"params\">Name</span>) </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">var</span> cookie = &#123;&#125;;</div><div class=\"line\">       <span class=\"keyword\">var</span> all = <span class=\"built_in\">document</span>.cookie;</div><div class=\"line\">      <span class=\"keyword\">if</span> (all === <span class=\"string\">''</span>)</div><div class=\"line\">           <span class=\"keyword\">return</span> cookie;</div><div class=\"line\">       <span class=\"keyword\">var</span> list = all.split(<span class=\"string\">'; '</span>);</div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; list.length; i++) &#123;</div><div class=\"line\">           <span class=\"keyword\">var</span> item = list[i];</div><div class=\"line\">           <span class=\"keyword\">var</span> p = item.indexOf(<span class=\"string\">'='</span>);</div><div class=\"line\">           <span class=\"keyword\">var</span> name = item.substring(<span class=\"number\">0</span>, p);</div><div class=\"line\">           name = <span class=\"built_in\">decodeURIComponent</span>(name).trim();<span class=\"comment\">//注意这里有个坑，除了第一个name，后面的name前面都有一个空格，所以要处理掉前面的空格才行；</span></div><div class=\"line\">           <span class=\"keyword\">var</span> value = item.substring(p + <span class=\"number\">1</span>);</div><div class=\"line\">           value = <span class=\"built_in\">decodeURIComponent</span>(value);</div><div class=\"line\">           cookie[name] = value;</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">return</span> cookie[Name];</div><div class=\"line\">   &#125;</div><div class=\"line\"><span class=\"comment\">//用法：getCookie(\"loginSuc\");</span></div></pre></td></tr></table></figure>\n<p><strong><em>cookie的删除函数封装</em></strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeCookie</span>(<span class=\"params\">name</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">var</span> exp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(); </div><div class=\"line\">    exp.setTime(exp.getTime() - <span class=\"number\">1</span>); </div><div class=\"line\">    <span class=\"keyword\">var</span> cval=getCookie(name); </div><div class=\"line\">    <span class=\"keyword\">if</span>(cval!=<span class=\"literal\">null</span>) <span class=\"built_in\">document</span>.cookie= name + <span class=\"string\">\"=\"</span>+cval+<span class=\"string\">\";expires=\"</span>+exp.toGMTString(); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用cookie我们可以设置用户的登录状态，亦或是点击了不再显示后就设置一个不再显示的cookie,通过获取cookie来达到效果。感觉棒棒哒！</p>"},{"title":"请问，你也是一只蘑菇吗","date":"2015-10-28T02:17:50.000Z","_content":"\n我博客名字的来源。\n<!--more-->\n\n以前听过一个冷笑话\n>在一家精神病医院里，有个新来的大夫，收治了一个病人。那个病人很奇怪，既不疯疯癫癫打人，也不大呼小叫吵吵嚷嚷，他只是每天很安静很安静的，撑着一把黑伞，蹲在墙边，不吃不喝的。\n大夫决定对病人进行治疗。可是他用尽了所有的办法，一点成效都没有，那个病人始终都不理睬他，对他的任何话和行为都没有反应。\n最后，那个大夫也去找了把黑伞来，和病人一样撑着伞蹲在墙角，默默的，丝毫不打扰他。\n终于，太阳落山的时候，那个病人缓缓的转头，看了大夫一眼，然后他笑了，轻声的说：‘请问，你也是一只蘑菇吗？’”\n\n\n后来看见这个故事的续集\n>那个大夫就这样每天陪着病人，撑着伞蹲在墙角，默默的，丝毫不打扰他。时间久了，病人渐渐认同大夫和自己一样，也是一只蘑菇。\n有一天，大夫忽然站起来，伸手伸脚活络身体，围着桌子跑圈。病人感到很奇怪，疑惑的问他：‘你不是一只蘑菇吗？’\n“我是啊！”大夫回答说。\n“那你怎么可以走来走去？！”病人更惊讶了。\n“蘑菇当然可以走来走去！”大夫理直气壮。\n病人觉得有道理，后来，他也开始站起来走来走去。\n又有一天，大夫端来很香的饭菜，坐在病人身边大吃大喝。病人感到很奇怪，疑惑的问他：“难道，你不是一只蘑菇吗？”\n“我当然是一只蘑菇！”大夫回答说。\n“那你怎么可以吃东西呢？！”病人更惊讶了。\n“谁说蘑菇不可以吃东西？！蘑菇当然可以吃东西！”大夫理直气壮的，咬了一口鸡腿。\n病人觉得很有道理，于是他也开始吃东西。\n后来这个病人就康复了，很快他出院了，像一个正常人一样的生活，虽然在他的心底，他依旧认为自己是一只蘑菇。\n\n每个人都有蘑菇的一面，在自己的世界，向阴生长。不过，不需担心，因为总能遇到一个人走到你身边，蹲下来。\n而这时你只用问一句：“请问，你也是一只蘑菇吗？” 就好了。\n\n","source":"_posts/请问，你也是一只蘑菇吗.md","raw":"title: 请问，你也是一只蘑菇吗\ndate: 2015-10-28 10:17:50\ntag: 矫情不是病\n---\n\n我博客名字的来源。\n<!--more-->\n\n以前听过一个冷笑话\n>在一家精神病医院里，有个新来的大夫，收治了一个病人。那个病人很奇怪，既不疯疯癫癫打人，也不大呼小叫吵吵嚷嚷，他只是每天很安静很安静的，撑着一把黑伞，蹲在墙边，不吃不喝的。\n大夫决定对病人进行治疗。可是他用尽了所有的办法，一点成效都没有，那个病人始终都不理睬他，对他的任何话和行为都没有反应。\n最后，那个大夫也去找了把黑伞来，和病人一样撑着伞蹲在墙角，默默的，丝毫不打扰他。\n终于，太阳落山的时候，那个病人缓缓的转头，看了大夫一眼，然后他笑了，轻声的说：‘请问，你也是一只蘑菇吗？’”\n\n\n后来看见这个故事的续集\n>那个大夫就这样每天陪着病人，撑着伞蹲在墙角，默默的，丝毫不打扰他。时间久了，病人渐渐认同大夫和自己一样，也是一只蘑菇。\n有一天，大夫忽然站起来，伸手伸脚活络身体，围着桌子跑圈。病人感到很奇怪，疑惑的问他：‘你不是一只蘑菇吗？’\n“我是啊！”大夫回答说。\n“那你怎么可以走来走去？！”病人更惊讶了。\n“蘑菇当然可以走来走去！”大夫理直气壮。\n病人觉得有道理，后来，他也开始站起来走来走去。\n又有一天，大夫端来很香的饭菜，坐在病人身边大吃大喝。病人感到很奇怪，疑惑的问他：“难道，你不是一只蘑菇吗？”\n“我当然是一只蘑菇！”大夫回答说。\n“那你怎么可以吃东西呢？！”病人更惊讶了。\n“谁说蘑菇不可以吃东西？！蘑菇当然可以吃东西！”大夫理直气壮的，咬了一口鸡腿。\n病人觉得很有道理，于是他也开始吃东西。\n后来这个病人就康复了，很快他出院了，像一个正常人一样的生活，虽然在他的心底，他依旧认为自己是一只蘑菇。\n\n每个人都有蘑菇的一面，在自己的世界，向阴生长。不过，不需担心，因为总能遇到一个人走到你身边，蹲下来。\n而这时你只用问一句：“请问，你也是一只蘑菇吗？” 就好了。\n\n","slug":"请问，你也是一只蘑菇吗","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ez40021er2zafcptutt","content":"<p>我博客名字的来源。<br><a id=\"more\"></a></p>\n<p>以前听过一个冷笑话</p>\n<blockquote>\n<p>在一家精神病医院里，有个新来的大夫，收治了一个病人。那个病人很奇怪，既不疯疯癫癫打人，也不大呼小叫吵吵嚷嚷，他只是每天很安静很安静的，撑着一把黑伞，蹲在墙边，不吃不喝的。<br>大夫决定对病人进行治疗。可是他用尽了所有的办法，一点成效都没有，那个病人始终都不理睬他，对他的任何话和行为都没有反应。<br>最后，那个大夫也去找了把黑伞来，和病人一样撑着伞蹲在墙角，默默的，丝毫不打扰他。<br>终于，太阳落山的时候，那个病人缓缓的转头，看了大夫一眼，然后他笑了，轻声的说：‘请问，你也是一只蘑菇吗？’”</p>\n</blockquote>\n<p>后来看见这个故事的续集</p>\n<blockquote>\n<p>那个大夫就这样每天陪着病人，撑着伞蹲在墙角，默默的，丝毫不打扰他。时间久了，病人渐渐认同大夫和自己一样，也是一只蘑菇。<br>有一天，大夫忽然站起来，伸手伸脚活络身体，围着桌子跑圈。病人感到很奇怪，疑惑的问他：‘你不是一只蘑菇吗？’<br>“我是啊！”大夫回答说。<br>“那你怎么可以走来走去？！”病人更惊讶了。<br>“蘑菇当然可以走来走去！”大夫理直气壮。<br>病人觉得有道理，后来，他也开始站起来走来走去。<br>又有一天，大夫端来很香的饭菜，坐在病人身边大吃大喝。病人感到很奇怪，疑惑的问他：“难道，你不是一只蘑菇吗？”<br>“我当然是一只蘑菇！”大夫回答说。<br>“那你怎么可以吃东西呢？！”病人更惊讶了。<br>“谁说蘑菇不可以吃东西？！蘑菇当然可以吃东西！”大夫理直气壮的，咬了一口鸡腿。<br>病人觉得很有道理，于是他也开始吃东西。<br>后来这个病人就康复了，很快他出院了，像一个正常人一样的生活，虽然在他的心底，他依旧认为自己是一只蘑菇。</p>\n</blockquote>\n<p>每个人都有蘑菇的一面，在自己的世界，向阴生长。不过，不需担心，因为总能遇到一个人走到你身边，蹲下来。<br>而这时你只用问一句：“请问，你也是一只蘑菇吗？” 就好了。</p>\n","excerpt":"<p>我博客名字的来源。<br>","more":"</p>\n<p>以前听过一个冷笑话</p>\n<blockquote>\n<p>在一家精神病医院里，有个新来的大夫，收治了一个病人。那个病人很奇怪，既不疯疯癫癫打人，也不大呼小叫吵吵嚷嚷，他只是每天很安静很安静的，撑着一把黑伞，蹲在墙边，不吃不喝的。<br>大夫决定对病人进行治疗。可是他用尽了所有的办法，一点成效都没有，那个病人始终都不理睬他，对他的任何话和行为都没有反应。<br>最后，那个大夫也去找了把黑伞来，和病人一样撑着伞蹲在墙角，默默的，丝毫不打扰他。<br>终于，太阳落山的时候，那个病人缓缓的转头，看了大夫一眼，然后他笑了，轻声的说：‘请问，你也是一只蘑菇吗？’”</p>\n</blockquote>\n<p>后来看见这个故事的续集</p>\n<blockquote>\n<p>那个大夫就这样每天陪着病人，撑着伞蹲在墙角，默默的，丝毫不打扰他。时间久了，病人渐渐认同大夫和自己一样，也是一只蘑菇。<br>有一天，大夫忽然站起来，伸手伸脚活络身体，围着桌子跑圈。病人感到很奇怪，疑惑的问他：‘你不是一只蘑菇吗？’<br>“我是啊！”大夫回答说。<br>“那你怎么可以走来走去？！”病人更惊讶了。<br>“蘑菇当然可以走来走去！”大夫理直气壮。<br>病人觉得有道理，后来，他也开始站起来走来走去。<br>又有一天，大夫端来很香的饭菜，坐在病人身边大吃大喝。病人感到很奇怪，疑惑的问他：“难道，你不是一只蘑菇吗？”<br>“我当然是一只蘑菇！”大夫回答说。<br>“那你怎么可以吃东西呢？！”病人更惊讶了。<br>“谁说蘑菇不可以吃东西？！蘑菇当然可以吃东西！”大夫理直气壮的，咬了一口鸡腿。<br>病人觉得很有道理，于是他也开始吃东西。<br>后来这个病人就康复了，很快他出院了，像一个正常人一样的生活，虽然在他的心底，他依旧认为自己是一只蘑菇。</p>\n</blockquote>\n<p>每个人都有蘑菇的一面，在自己的世界，向阴生长。不过，不需担心，因为总能遇到一个人走到你身边，蹲下来。<br>而这时你只用问一句：“请问，你也是一只蘑菇吗？” 就好了。</p>"},{"title":"请问您今天要来点兔子吗","date":"2015-11-06T02:17:50.000Z","_content":"再次推一下萌出血的点兔第二季ED（循环洗脑版！！）\n顺便 \nmarkdown 嵌入视频测试~ \n\niframe部分的代码是从A站拷的 科科\n\n<iframe id=\"ACFlashPlayer-re\" frameborder=\"0\" allowfullscreen=\"\" src=\"https://ssl.acfun.tv/block-player-homura.html?salt=167350321&amp;forFlash_=edae4e96-0f5e-4e15-d4c8-5b6c74bd3515,s106,ac2260637,#token=d2d835iu51nn4s4i;vid=2770596;postMessage=1;autoplay=0;fullscreen=0;from=http://www.acfun.tv;hint=小贴士：按下“←”和“→”键即可后退或前进一小段。\" style=\"height: 592px; width: 700px; left: 0px; top: 0px;\"></iframe>\n","source":"_posts/请问您今天要来点兔子吗.md","raw":"title: 请问您今天要来点兔子吗\ndate: 2015-11-06 10:17:50\ntag: 二次元\n---\n再次推一下萌出血的点兔第二季ED（循环洗脑版！！）\n顺便 \nmarkdown 嵌入视频测试~ \n\niframe部分的代码是从A站拷的 科科\n\n<iframe id=\"ACFlashPlayer-re\" frameborder=\"0\" allowfullscreen=\"\" src=\"https://ssl.acfun.tv/block-player-homura.html?salt=167350321&amp;forFlash_=edae4e96-0f5e-4e15-d4c8-5b6c74bd3515,s106,ac2260637,#token=d2d835iu51nn4s4i;vid=2770596;postMessage=1;autoplay=0;fullscreen=0;from=http://www.acfun.tv;hint=小贴士：按下“←”和“→”键即可后退或前进一小段。\" style=\"height: 592px; width: 700px; left: 0px; top: 0px;\"></iframe>\n","slug":"请问您今天要来点兔子吗","published":1,"updated":"2016-09-22T16:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8489ez70024er2zz298blyj","content":"<p>再次推一下萌出血的点兔第二季ED（循环洗脑版！！）<br>顺便<br>markdown 嵌入视频测试~ </p>\n<p>iframe部分的代码是从A站拷的 科科</p>\n<iframe id=\"ACFlashPlayer-re\" frameborder=\"0\" allowfullscreen src=\"https://ssl.acfun.tv/block-player-homura.html?salt=167350321&amp;forFlash_=edae4e96-0f5e-4e15-d4c8-5b6c74bd3515,s106,ac2260637,#token=d2d835iu51nn4s4i;vid=2770596;postMessage=1;autoplay=0;fullscreen=0;from=http://www.acfun.tv;hint=小贴士：按下“←”和“→”键即可后退或前进一小段。\" style=\"height: 592px; width: 700px; left: 0px; top: 0px;\"></iframe>\n","excerpt":"","more":"<p>再次推一下萌出血的点兔第二季ED（循环洗脑版！！）<br>顺便<br>markdown 嵌入视频测试~ </p>\n<p>iframe部分的代码是从A站拷的 科科</p>\n<iframe id=\"ACFlashPlayer-re\" frameborder=\"0\" allowfullscreen=\"\" src=\"https://ssl.acfun.tv/block-player-homura.html?salt=167350321&amp;forFlash_=edae4e96-0f5e-4e15-d4c8-5b6c74bd3515,s106,ac2260637,#token=d2d835iu51nn4s4i;vid=2770596;postMessage=1;autoplay=0;fullscreen=0;from=http://www.acfun.tv;hint=小贴士：按下“←”和“→”键即可后退或前进一小段。\" style=\"height: 592px; width: 700px; left: 0px; top: 0px;\"></iframe>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj8489evx0000er2z08b4pr2a","tag_id":"cj8489ew80004er2zf9nsjdll","_id":"cj8489ewn0009er2z1yrt58p5"},{"post_id":"cj8489ew40002er2zovnihxbg","tag_id":"cj8489ewm0008er2zswuk66kj","_id":"cj8489ews000eer2ztiegjaxf"},{"post_id":"cj8489ewd0005er2zs4ww69kt","tag_id":"cj8489ewm0008er2zswuk66kj","_id":"cj8489ewv000ier2zt61kdqyj"},{"post_id":"cj8489ewg0006er2z324dw0xg","tag_id":"cj8489ewu000ger2z7660lo8r","_id":"cj8489ex1000mer2z72z28akd"},{"post_id":"cj8489ewz000ler2zufb145a1","tag_id":"cj8489ewu000ger2z7660lo8r","_id":"cj8489ex8000per2z5ke1q9sd"},{"post_id":"cj8489ewj0007er2zoux7mdh5","tag_id":"cj8489ewm0008er2zswuk66kj","_id":"cj8489exa000rer2zl6uxj5hj"},{"post_id":"cj8489ewn000aer2zmk5enu0f","tag_id":"cj8489ex8000oer2zkiy6wlzi","_id":"cj8489exd000ver2zgttv3qp9"},{"post_id":"cj8489exd000wer2z6inz343u","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489exj000zer2z8rw3k863"},{"post_id":"cj8489exf000xer2ztvaxk7re","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489exl0011er2zz9vnvz1u"},{"post_id":"cj8489exj0010er2zw0o81464","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489exs0014er2zgf5ayf86"},{"post_id":"cj8489ewp000ber2zfeolf5rt","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489ext0016er2zjowtupiq"},{"post_id":"cj8489ewp000ber2zfeolf5rt","tag_id":"cj8489ex8000oer2zkiy6wlzi","_id":"cj8489exw0019er2zuz5o91mt"},{"post_id":"cj8489exl0012er2zmkscepoz","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489ey0001ber2z6z7ad0r3"},{"post_id":"cj8489exs0015er2zd4ftqrq3","tag_id":"cj8489ewm0008er2zswuk66kj","_id":"cj8489ey5001eer2zhsz2otfe"},{"post_id":"cj8489ewr000der2zhiej50bj","tag_id":"cj8489ex8000oer2zkiy6wlzi","_id":"cj8489ey8001ger2zvet2jdn8"},{"post_id":"cj8489ext0017er2zlcrfd9r6","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489eyd001jer2ziy770ta6"},{"post_id":"cj8489ext0017er2zlcrfd9r6","tag_id":"cj8489ex8000oer2zkiy6wlzi","_id":"cj8489eyg001ler2z7ksee9a5"},{"post_id":"cj8489exw001aer2zo2yu5ob7","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489eyn001oer2zt3sf2umn"},{"post_id":"cj8489ewt000fer2znet7nmgk","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489eyq001qer2zuotdx3a3"},{"post_id":"cj8489ey0001cer2zqpyjtiik","tag_id":"cj8489ex8000oer2zkiy6wlzi","_id":"cj8489eyt001ter2zatilv4cj"},{"post_id":"cj8489ewu000her2zyyofply2","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489eyv001ver2z5ky5jtn1"},{"post_id":"cj8489ey9001her2zn4eeg7vd","tag_id":"cj8489ex8000oer2zkiy6wlzi","_id":"cj8489ez1001yer2z8l766gwd"},{"post_id":"cj8489eye001ker2zlurph54u","tag_id":"cj8489ew80004er2zf9nsjdll","_id":"cj8489ez40020er2za8mw13ap"},{"post_id":"cj8489eww000jer2z8kk3nrgz","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489ez60023er2z5wze3p31"},{"post_id":"cj8489eyh001mer2zl7yib3zm","tag_id":"cj8489ewm0008er2zswuk66kj","_id":"cj8489ez80025er2zivpx2t4p"},{"post_id":"cj8489eyp001per2z2mbi05p8","tag_id":"cj8489ex8000oer2zkiy6wlzi","_id":"cj8489ez90027er2zga3upyks"},{"post_id":"cj8489ex4000ner2z2cjal4me","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489ez90028er2z3vq9ch4d"},{"post_id":"cj8489eyq001rer2zygkyb1r1","tag_id":"cj8489ex8000oer2zkiy6wlzi","_id":"cj8489ez9002aer2ztk0brfgb"},{"post_id":"cj8489eyu001uer2z6xjdvdn9","tag_id":"cj8489ewm0008er2zswuk66kj","_id":"cj8489ez9002ber2zaucjtp6h"},{"post_id":"cj8489ex9000qer2zojv6x34v","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489eza002der2z6x6w07v2"},{"post_id":"cj8489eyv001wer2z1tit21jw","tag_id":"cj8489ewm0008er2zswuk66kj","_id":"cj8489eza002eer2zqvot9lxh"},{"post_id":"cj8489ez2001zer2zyp2c9rkc","tag_id":"cj8489ewm0008er2zswuk66kj","_id":"cj8489eza002fer2z7f15ge6h"},{"post_id":"cj8489exa000ser2z28vmmaq8","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489eza002ger2z7u5gey93"},{"post_id":"cj8489exc000uer2zsb0v8ml6","tag_id":"cj8489exb000ter2zaqaxqs2j","_id":"cj8489eza002her2zwdulwkcp"},{"post_id":"cj8489ey5001fer2zbpyz1yqx","tag_id":"cj8489ez80026er2z1qk6noxk","_id":"cj8489ezb002ier2zswn88vbu"},{"post_id":"cj8489ez40021er2zafcptutt","tag_id":"cj8489ez90029er2z3lrwi1v5","_id":"cj8489ezb002jer2zo9jxvvf1"},{"post_id":"cj8489ez70024er2zz298blyj","tag_id":"cj8489eza002cer2zu1r7xmzm","_id":"cj8489ezb002ker2zas86ts8r"}],"Tag":[{"name":"css学习心得","_id":"cj8489ew80004er2zf9nsjdll"},{"name":"Javascript学习笔记","_id":"cj8489ewm0008er2zswuk66kj"},{"name":"生活琐事","_id":"cj8489ewu000ger2z7660lo8r"},{"name":"web前端知识","_id":"cj8489ex8000oer2zkiy6wlzi"},{"name":"node.js学习笔记","_id":"cj8489exb000ter2zaqaxqs2j"},{"name":"读书笔记","_id":"cj8489ez80026er2z1qk6noxk"},{"name":"矫情不是病","_id":"cj8489ez90029er2z3lrwi1v5"},{"name":"二次元","_id":"cj8489eza002cer2zu1r7xmzm"}]}}